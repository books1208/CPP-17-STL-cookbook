<!DOCTYPE html>
<!-- saved from url=(0194)file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x53eax6709x5934x6587x4ef6x7684x5e93x4e2dx542fx7528x5185x8054x53d8x91cf -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>C++17 STL Cook book</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
    .markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p,html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div{display:inline}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  300px/2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}/**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}.emoji {
  height: 0.8em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}
    /* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

    </style>
    <link rel="stylesheet" href="./C++17 STL Cook book_files/katex.min.css">
  </head>
  <body for="html-export">
    <div class="mume markdown-preview">
    <div><h1 class="mume-header" id="%E7%9B%AE%E5%BD%95" ebook-toc-level-1="" heading="&amp;#x76EE;&amp;#x5F55;">目录</h1>

<ul>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x524dx8a00">前言</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5173x4e8ex672cx4e66">关于本书</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5404x7ae0x6897x6982">各章梗概</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x7b2c1x7ae0-c17x7684x65b0x7279x6027">第1章 C++17的新特性</a>
<ul>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x7ed3x6784x5316x7ed1x5b9ax6765x89e3x5305x7ed1x5b9ax7684x8fd4x56dex503c">使用结构化绑定来解包绑定的返回值</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5c06x53d8x91cfx4f5cx7528x57dfx9650x5236x5728ifx548cswitchx533ax57dfx5185">将变量作用域限制在if和switch区域内</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x65b0x7684x62ecx53f7x521dx59cbx5316x89c4x5219">新的括号初始化规则</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x6784x9020x51fdx6570x81eax52a8x63a8x5bfcx6a21x677fx7684x7c7bx578b">构造函数自动推导模板的类型</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528constexpr-ifx7b80x5316x7f16x8bd1">使用constexpr-if简化编译</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x53eax6709x5934x6587x4ef6x7684x5e93x4e2dx542fx7528x5185x8054x53d8x91cf">只有头文件的库中启用内联变量</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x6298x53e0x8868x8fbex5f0fx5b9ex73b0x8f85x52a9x51fdx6570">使用折叠表达式实现辅助函数</a></li>
</ul>
</li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x7b2c2x7ae0-stlx5bb9x5668">第2章 STL容器</a>
<ul>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x64e6x9664x79fbx9664stdvectorx5143x7d20">擦除/移除std::vector元素</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4ee5o1x7684x65f6x95f4x590dx6742x5ea6x5220x9664x672ax6392x5e8fstdvectorx4e2dx7684x5143x7d20">以O(1)的时间复杂度删除未排序std::vector中的元素</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5febx901fx6216x5b89x5168x7684x8bbfx95eestdvectorx5b9ex4f8bx7684x65b9x6cd5">快速或安全的访问std::vector实例的方法</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4fddx6301x5bf9stdvectorx5b9ex4f8bx7684x6392x5e8f">保持对std::vector实例的排序</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5411stdmapx5b9ex4f8bx4e2dx9ad8x6548x5e76x6709x6761x4ef6x7684x63d2x5165x5143x7d20">向std::map实例中高效并有条件的插入元素</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4e86x89e3stdmapinsertx65b0x7684x63d2x5165x63d0x793ax8bedx4e49">了解std::map::insert新的插入提示语义</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x9ad8x6548x7684x4feex6539stdmapx5143x7d20x7684x952ex503c">高效的修改std::map元素的键值</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-stdunordered_mapx4e2dx4f7fx7528x81eax5b9ax4e49x7c7bx578b">std::unordered_map中使用自定义类型</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x8fc7x6ee4x7528x6237x7684x91cdx590dx8f93x5165xff0cx5e76x4ee5x5b57x6bcdx5e8fx5c06x91cdx590dx4fe1x606fx6253x5370x51fax2014x2014stdset">过滤用户的重复输入，并以字母序将重复信息打印出——std::set</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x7b80x5355x7684x9006x6ce2x5170x8868x793ax6cd5x8ba1x7b97x5668x2014x2014stdstack">实现简单的逆波兰表示法计算器——std::stack</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x8bcdx9891x8ba1x6570x5668x2014x2014stdmap">实现词频计数器——std::map</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x5199x4f5cx98cex683cx52a9x624bx7528x6765x67e5x627ex6587x672cx4e2dx5f88x957fx7684x53e5x5b50x2014x2014stdmultimap">实现写作风格助手用来查找文本中很长的句子——std::multimap</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x4e2ax4ebax5f85x529ex4e8bx9879x5217x8868x2014x2014stdpriority_queue">实现个人待办事项列表——std::priority_queue</a></li>
</ul>
</li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x7b2c3x7ae0-x8fedx4ee3x5668">第3章 迭代器</a>
<ul>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5efax7acbx53efx8fedx4ee3x533ax57df">建立可迭代区域</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x8ba9x81eax5df1x7684x8fedx4ee3x5668x4e0estlx7684x8fedx4ee3x5668x517cx5bb9">让自己的迭代器与STL的迭代器兼容</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x8fedx4ee3x9002x914dx5668x586bx5145x901ax7528x6570x636ex7ed3x6784">使用迭代适配器填充通用数据结构</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x8fedx4ee3x5668x5b9ex73b0x7b97x6cd5">使用迭代器实现算法</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x53cdx5411x8fedx4ee3x9002x914dx5668x8fdbx884cx8fedx4ee3">使用反向迭代适配器进行迭代</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x54e8x5175x7ec8x6b62x8fedx4ee3">使用哨兵终止迭代</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x68c0x67e5x8fc7x7684x8fedx4ee3x5668x81eax52a8x5316x68c0x67e5x8fedx4ee3x5668x4ee3x7801">使用检查过的迭代器自动化检查迭代器代码</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x6784x5efazipx8fedx4ee3x9002x914dx5668">构建zip迭代适配器</a></li>
</ul>
</li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x7b2c4x7ae0-lambdax8868x8fbex5f0f">第4章 Lambda表达式</a>
<ul>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528lambdax8868x8fbex5f0fx5b9ax4e49x51fdx6570">使用Lambda表达式定义函数</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528lambdax4e3astdfunctionx6dfbx52a0x591ax6001x6027">使用Lambda为std::function添加多态性</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5e76x7f6ex51fdx6570">并置函数</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x901ax8fc7x903bx8f91x8fdex63a5x521bx5efax590dx6742x8c13x8bcd">通过逻辑连接创建复杂谓词</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x540cx4e00x8f93x5165x8c03x7528x591ax4e2ax51fdx6570">使用同一输入调用多个函数</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528stdaccumulatex548clambdax51fdx6570x5b9ex73b0transform_if">使用std::accumulate和Lambda函数实现transform_if</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x7f16x8bd1x65f6x751fx6210x7b1bx5361x5c14x4e58x79ef">编译时生成笛卡尔乘积</a></li>
</ul>
</li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x7b2c5x7ae0-stlx57fax7840x7b97x6cd5">第5章 STL基础算法</a>
<ul>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5bb9x5668x95f4x76f8x4e92x590dx5236x5143x7d20">容器间相互复制元素</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5bb9x5668x5143x7d20x6392x5e8f">容器元素排序</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4ecex5bb9x5668x4e2dx5220x9664x6307x5b9ax5143x7d20">从容器中删除指定元素</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x6539x53d8x5bb9x5668x5185x5bb9">改变容器内容</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5728x6709x5e8fx548cx65e0x5e8fx7684vectorx4e2dx67e5x627ex5143x7d20">在有序和无序的vector中查找元素</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5c06vectorx4e2dx7684x503cx63a7x5236x5728x7279x5b9ax6570x503cx8303x56f4x5185x2014x2014stdclamp">将vector中的值控制在特定数值范围内——std::clamp</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5728x5b57x7b26x4e32x4e2dx5b9ax4f4dx6a21x5f0fx5e76x9009x62e9x6700x4f73x5b9ex73b0x2014x2014stdsearch">在字符串中定位模式并选择最佳实现——std::search</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5bf9x5927vectorx8fdbx884cx91c7x6837">对大vector进行采样</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x751fx6210x8f93x5165x5e8fx5217x7684x5e8fx5217">生成输入序列的序列</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x5b57x5178x5408x5e76x5de5x5177">实现字典合并工具</a></li>
</ul>
</li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x7b2c6x7ae0-stlx7b97x6cd5x7684x9ad8x7ea7x4f7fx7528x65b9x5f0f">第6章 STL算法的高级使用方式</a>
<ul>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528stlx7b97x6cd5x5b9ex73b0x5355x8bcdx67e5x627ex6811x7c7b">使用STL算法实现单词查找树类</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x6811x5b9ex73b0x641cx7d22x8f93x5165x5efax8baex751fx6210x5668">使用树实现搜索输入建议生成器</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528stlx6570x503cx7b97x6cd5x5b9ex73b0x5085x91ccx53f6x53d8x6362">使用STL数值算法实现傅里叶变换</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x8ba1x7b97x4e24x4e2avectorx7684x8befx5deex548c">计算两个vector的误差和</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528asciix5b57x7b26x66fcx5fb7x5c14x5e03x7f57x7279x96c6x5408">使用ASCII字符曼德尔布罗特集合</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x5206x5272x7b97x6cd5">实现分割算法</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5c06x6807x51c6x7b97x6cd5x8fdbx884cx7ec4x5408">将标准算法进行组合</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5220x9664x8bcdx7ec4x95f4x8fdex7eedx7684x7a7ax683c">删除词组间连续的空格</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x538bx7f29x548cx89e3x538bx7f29x5b57x7b26x4e32">压缩和解压缩字符串</a></li>
</ul>
</li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x7b2c7x7ae0-x5b57x7b26x4e32-x6d41x548cx6b63x5219x8868x8fbe">第7章 字符串, 流和正则表达</a>
<ul>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x521bx5efax3001x8fdex63a5x548cx8f6cx6362x5b57x7b26x4e32">创建、连接和转换字符串</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x6d88x9664x5b57x7b26x4e32x5f00x59cbx548cx7ed3x675fx5904x7684x7a7ax683c">消除字符串开始和结束处的空格</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x65e0x9700x6784x9020x83b7x53d6stdstring">无需构造获取std::string</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4ecex7528x6237x7684x8f93x5165x8bfbx53d6x6570x503c">从用户的输入读取数值</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x8ba1x7b97x6587x4ef6x4e2dx7684x5355x8bcdx6570x91cf">计算文件中的单词数量</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x683cx5f0fx5316x8f93x51fa">格式化输出</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x8f93x5165x6587x4ef6x521dx59cbx5316x590dx6742x5bf9x8c61">使用输入文件初始化复杂对象</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x8fedx4ee3x5668x586bx5145x5bb9x5668x2014x2014stdistream">迭代器填充容器——std::istream</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x8fedx4ee3x5668x8fdbx884cx6253x5370x2014x2014stdostream">迭代器进行打印——std::ostream</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x7279x5b9ax4ee3x7801x6bb5x5c06x8f93x51fax91cdx5b9ax5411x5230x6587x4ef6">使用特定代码段将输出重定向到文件</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x901ax8fc7x96c6x6210stdchar_traitsx521bx5efax81eax5b9ax4e49x5b57x7b26x4e32x7c7b">通过集成std::char_traits创建自定义字符串类</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x6b63x5219x8868x8fbex5f0fx5e93x6807x8bb0x8f93x5165">使用正则表达式库标记输入</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x7b80x5355x6253x5370x4e0dx540cx683cx5f0fx7684x6570x5b57">简单打印不同格式的数字</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4ecestdiostreamx9519x8befx4e2dx83b7x53d6x53efx8bfbx5f02x5e38">从std::iostream错误中获取可读异常</a></li>
</ul>
</li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x7b2c8x7ae0-x5de5x5177x7c7b">第8章 工具类</a>
<ul>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x8f6cx6362x4e0dx540cx7684x65f6x95f4x5355x4f4dx2014x2014stdratio">转换不同的时间单位——std::ratio</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x8f6cx6362x7eddx5bf9x65f6x95f4x548cx76f8x5bf9x65f6x95f4x2014x2014stdchrono">转换绝对时间和相对时间——std::chrono</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b89x5168x7684x6807x8bc6x5931x8d25x2014x2014stdoptional">安全的标识失败——std::optional</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5bf9x5143x7ec4x4f7fx7528x51fdx6570">对元组使用函数</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x5143x7ec4x5febx901fx6784x6210x6570x636ex7ed3x6784">使用元组快速构成数据结构</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5c06codevoidcodex66ffx6362x4e3ax66f4x4e3ax5b89x5168x7684stdany">将<code>void*</code>替换为更为安全的std::any</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b58x50a8x4e0dx540cx7684x7c7bx578bx2014x2014stdvariant">存储不同的类型——std::variant</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x81eax52a8x5316x7ba1x7406x8d44x6e90x2014x2014stdunique_ptr">自动化管理资源——std::unique_ptr</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5904x7406x5171x4eabx5806x5185x5b58x2014x2014stdshared_ptr">处理共享堆内存——std::shared_ptr</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5bf9x5171x4eabx5bf9x8c61x4f7fx7528x5f31x6307x9488">对共享对象使用弱指针</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x667ax80fdx6307x9488x7b80x5316x5904x7406x9057x7559api">使用智能指针简化处理遗留API</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5171x4eabx540cx4e00x5bf9x8c61x7684x4e0dx540cx6210x5458">共享同一对象的不同成员</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x9009x62e9x5408x9002x7684x5f15x64cex751fx6210x968fx673ax6570">选择合适的引擎生成随机数</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x8ba9stlx4ee5x6307x5b9ax5206x5e03x65b9x5f0fx4ea7x751fx968fx673ax6570">让STL以指定分布方式产生随机数</a></li>
</ul>
</li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x7b2c9x7ae0-x5e76x884cx548cx5e76x53d1">第9章 并行和并发</a>
<ul>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x6807x51c6x7b97x6cd5x7684x81eax52a8x5e76x884c">标准算法的自动并行</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x8ba9x7a0bx5e8fx5728x7279x5b9ax65f6x95f4x4f11x7720">让程序在特定时间休眠</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x542fx52a8x548cx505cx6b62x7ebfx7a0b">启动和停止线程</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x6253x9020x5f02x5e38x5b89x5168x7684x5171x4eabx9501x2014x2014stdunique_lockx548cstdshared_lock">打造异常安全的共享锁——std::unique_lock和std::shared_lock</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x907fx514dx6b7bx9501x2014x2014stdscoped_lock">避免死锁——std::scoped_lock</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x540cx6b65x5e76x884cx4e2dx4f7fx7528stdcout">同步并行中使用std::cout</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x8fdbx884cx5ef6x8fdfx521dx59cbx5316x2014x2014stdcall_once">进行延迟初始化——std::call_once</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5c06x6267x884cx7684x7a0bx5e8fx63a8x5230x540ex53f0x2014x2014stdasync">将执行的程序推到后台——std::async</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x751fx4ea7x8005x6d88x8d39x8005x6a21x578bx2014x2014stdcondition_variable">实现生产者/消费者模型——std::condition_variable</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x591ax751fx4ea7x8005x591ax6d88x8d39x8005x6a21x578bx2014x2014stdcondition_variable">实现多生产者/多消费者模型——std::condition_variable</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5e76x884casciix66fcx5fb7x5c14x5e03x7f57x7279x6e32x67d3x5668x2014x2014stdasync">并行ASCII曼德尔布罗特渲染器——std::async</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x4e00x4e2ax5c0fx578bx81eax52a8x5316x5e76x884cx5e93x2014x2014stdfuture">实现一个小型自动化并行库——std::future</a></li>
</ul>
</li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x7b2c10x7ae0-x6587x4ef6x7cfbx7edf">第10章 文件系统</a>
<ul>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x6807x51c6x5316x8defx5f84">实现标准化路径</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x4f7fx7528x76f8x5bf9x8defx5f84x83b7x53d6x89c4x8303x7684x6587x4ef6x8defx5f84">使用相对路径获取规范的文件路径</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5217x51fax76eex5f55x4e0bx7684x6240x6709x6587x4ef6">列出目录下的所有文件</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x4e00x4e2ax7c7bx4f3cgrepx7684x6587x672cx641cx7d22x5de5x5177">实现一个类似grep的文本搜索工具</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x4e00x4e2ax81eax52a8x6587x4ef6x91cdx547dx540dx5668">实现一个自动文件重命名器</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x4e00x4e2ax78c1x76d8x4f7fx7528x7edfx8ba1x5668">实现一个磁盘使用统计器</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x8ba1x7b97x6587x4ef6x7c7bx578bx7684x7edfx8ba1x4fe1x606f">计算文件类型的统计信息</a></li>
<li><a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/C++17%20STL%20Cook%20book.html#ebook-heading-x5b9ex73b0x4e00x4e2ax5de5x5177xff1ax901ax8fc7x7b26x53f7x94fex63a5x51cfx5c11x91cdx590dx6587x4ef6xff0cx4ecex800cx63a7x5236x6587x4ef6x5939x5927x5c0f">实现一个工具：通过符号链接减少重复文件，从而控制文件夹大小</a></li>
</ul>
</li>
</ul>
</div><div id="ebook-heading-x524dx8a00" ebook-toc-level-1="" heading="前言"><div><h1 class="mume-header" id="%E5%89%8D%E8%A8%80">前言</h1>

<p>《C++17 STL Cookbook》将结合C++代码实例和标准库(STL)，教会你如何充分使用C++17。这里要说明的是，本书会尽可能的去使用STL，从而教会大家使用C++17。</p>
<p>C++是一门伟大且具有力量的语言。它使用简单的高级接口，将隐藏复杂的解决方式隐藏于背后，不过这样就意味着需要编写高效和低开销的底层代码实现。国际标准化组织(ISO)C++标准委员会致力于改进C++标准。C++11标准为C++带来了大量不错的特性，C++14和C++17也为C++加入了些新的特性。</p>
<p>目前为止，C++作为一门编程语言提供了语言相应的语言特性个标准库工具，用于处理复杂的标准数据结构和算法，包括：智能指针、Lambda表达式、常量表达式、便捷式可控线程的并发编程、正则表达式、随机数发生器、异常、可变参数模板(C++的部分模板类是图灵完备的!)、自定义文字、便捷式文件系统遍历等等。这些功能使它成为一种通用的语言，并在软件行业的所有领域，用于实现高质量和高性能的软件。</p>
<p>不过，很多编程者只将C++当做一门编程语言学习，而不太重视标准库(STL)的使用。不使用C++所带的标准库，将会让C++看起来就像是具有class的C语言，21世纪的现代化程序不应该写成这样。并且，这样的使用令人沮丧，就像是卸掉了它的一条手臂一样。</p>
<p>Bjarne Stroustrup(C++之父)在他的《C++程序设计语言》(C++11版本)中写到</p>
<blockquote>
<p>请牢记，标准库和语言功能都是为了支撑以软件质量为目标的编程技术。他们应被组合起来发挥作用——如同建房子的砖块——而非个别地采用来相对孤立地去解决某个特定问题。</p>
</blockquote>
<p>这段话能很明确的概括我写这本书的目的。本书的所有例子都与实际息息相关，处理这些问题时，只依赖与STL，不依赖其他的库。少了其他库的依赖，就能很容易的将程序运行起来，不必去为开发环境所困扰。 我希望你们受这些例子的启发，找到使用标准库的灵感，用伟大的编程语言作为解决更高级问题的基石。</p>
</div></div><div id="ebook-heading-x5173x4e8ex672cx4e66" ebook-toc-level-1="" heading="关于本书"><div><h1 class="mume-header" id="%E5%85%B3%E4%BA%8E%E6%9C%AC%E4%B9%A6">关于本书</h1>

<p>本书中所有的例子都很简单，都可以很容易编译和运行，不过读者们还是需要注意一下自己所选择的操作系统和编译器。下面就让我们来看一下在编译和运行本书例程时，所要注意的一些内容。</p>
<h1 class="mume-header" id="%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E4%BE%8B%E7%A8%8B">编译和运行例程</h1>

<p>本书的所有例子都在Linux和Mac OS进行开发和验证，我们使用GNU的C++编译器<strong>g++</strong>，和LLVM的C++编译器 <strong>clang++</strong>。</p>
<p>shell环境下可以使用如下的命令使用g++编译例程：</p>
<p><code>$ g++ -std c++lz —o recipe_app recipe_code.cpp</code></p>
<p>要使用clang++的话，命令行类似:</p>
<p><code>$ clang++ -std C++ Iz -o recipe_app recipe_code.cpp</code></p>
<p>上面两个例子都假设我们的C++例程写在 <code>recipe_code.cpp</code>文件中。完成编译后，生成可执行二进制文件<code>recipe_app</code>，然后使用如下命令执行它：</p>
<p><code>$ . /recipe_app</code></p>
<p>书中很多例子，都是通过标准输入读取整个文件的内容。遇到这样的例子时，我们使用标准UNIX管道和<code>cat</code>命令直接将文件内容传输给我们的应用，命令如下所示：</p>
<p><code>$ cat file.txt | ./recipe_app</code></p>
<p>上面的方法适用于Linux和Mac OS系统。在微软Windows Shell中，需要使用如下的命令:</p>
<p><code>&gt; recipe app.exe &lt; file.txt</code></p>
<p>如果你不想在Shell命令行中运行，你可以在Microsoft Visual Studio IDE中运行，不过需要你修改一下配置, <code>"Configuration properties &gt; Debugging "</code>,并且添加<code>"&lt; file. txt"</code> ，使用 Visual Studio加载应用就能直接运行程序了。(Visual Studio IDE的话选定对应的解决方案，右键后选择“属性”，在“调试”页面输入相应的命令行参数)</p>
<h1 class="mume-header" id="%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87">前期准备</h1>

<p>如果最近你阅读了本书中C++17的新特性，并使用前卫的编译器编译了这些代码，你可能会在编译阶段遇到一些问题。因为你使用到的一些C++17 STL新特性可能还没有在编译器中进行实现。</p>
<p>运行本书代码时，需要给<code>&lt;execution_policy&gt;</code> 和<code>&lt;filesystem&gt;</code>头文件添加前缀<code>experimental/</code> 。其会将你将是用到的一些STL算法、数值等等包含入你的代码中，不过这也取决于编译器标准库的更新程度和稳定性。</p>
<p>这同样使用于命名空间的新特性。标准库中，实验部分的实现并不在<code>std</code>命名空间中，而是在<code>std::experimental</code>中。</p>
<h1 class="mume-header" id="%E9%80%82%E8%AF%BB%E7%BE%A4%E4%BD%93">适读群体</h1>

<p>如果你没有编写过C++程序的经验，那么请将本书放回书架。如果你只想学习有关语言基础的知识，那么本书不是你理想的选择。当你了解完语言基础后，本书会对你的语言技巧进行升级。</p>
<p>除此之外，如果你符合如下的描述的话，可以继续阅读本书：</p>
<ul>
<li>已经了解过C++的基础，不过现在你不知道下一步自己该怎么走，这是因为你与资深C++达人还有很大的差距。</li>
<li>C++基础十分牢靠，但是你对STL知之甚少。</li>
<li>对C++的某个老版本比较了解，比如C++98、C++11或C++14。</li>
</ul>
<p>以上这些描述，都是基于你使用C++的频度而论。本书储备了很多优秀的STL新特性，等待你去发现。</p>
<h1 class="mume-header" id="%E7%AB%A0%E8%8A%82%E8%AE%BE%E8%AE%A1">章节设计</h1>

<p>本书中你会发现几个经常出现的标题：</p>
<p>(<em>译者：这些副标题只在本节翻译，正文中使用英文原文作为副标题</em>)</p>
<ul>
<li>Getting ready</li>
<li>How to do it</li>
<li>How it works</li>
<li>There's more</li>
<li>See also</li>
</ul>
<p>下面简单介绍一些这几个副标题所涵盖的内容：</p>
<h2 class="mume-header" id="%E5%87%86%E5%A4%87%E5%BC%80%E5%A7%8B-getting-ready">准备开始 Getting ready</h2>

<p>本节会说明我们的期望，以及如何在初期对环境或软件进行配置。</p>
<h2 class="mume-header" id="%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90-how-to-do-it">如何完成 How to do it...</h2>

<p>本节包含实现所需的步骤。</p>
<h2 class="mume-header" id="%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C-how-it-works">如何工作 How it works...</h2>

<p>本节会对前一节所发生的事情，进行详细解释。</p>
<h2 class="mume-header" id="%E4%BF%A1%E6%81%AF%E8%A1%A5%E5%85%85-theres-more">信息补充 There's more...</h2>

<p>本节包含了一些式例相关的补充信息，以便读者对式例有更深入的了解。</p>
<h2 class="mume-header" id="%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF-see-also">更多信息 See also</h2>

<p>为式例提供一些帮助链接，有助于了解C++的更多知识。</p>
<h1 class="mume-header" id="%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F"><s>文本样式</s></h1>

<p><s>本书中，使用不同的文本样式区分不同种类的信息。下面的一些例子会解释这些风格的含义。</s></p>
<p><s>文本的代码，数据库表名，文件夹名，文件名，文件的扩展名，路径名，虚拟的URL，用户输入和推特引用，会展示成这种样式： "下一步需要修改<code>build.properties</code> 文件。"</s></p>
<p>代码块为这种样式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">my_wrapper<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> T3<span class="token operator">&gt;</span> make <span class="token function">wrapper</span> <span class="token punctuation">(</span>Tl t <span class="token number">1</span><span class="token punctuation">,</span> T <span class="token number">2</span> t2<span class="token punctuation">,</span> T3 t3<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> t <span class="token number">1</span><span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p><s><strong>新术语</strong>和<strong>关键字</strong>使用粗体。你在屏幕上看到的单词，例如菜单或对话框，会是这种样式: "完成后，点击执行。"</s></p>
<p><s><em>警告或重要说明会显示在一个方框中。</em></s></p>
<p><s><em>提示和技巧会用斜体样式</em></s></p>
<h1 class="mume-header" id="%E8%AF%BB%E8%80%85%E5%8F%8D%E9%A6%88">读者反馈</h1>

<p>我们欢迎读者的反馈。这样我们就知道这本书哪里好，哪里不好。读者的反馈对于我们来说十分重要，并且能帮助我们确定读者关注的重点，从而让读者在阅读本书时的收获最大化。一般的反馈可以通过发送电子邮件到 <code>feedback@packtpub.com</code>，并在主题中提到这本书的名字即可。如果您是某个方便的专家，并且对写作或写书感兴趣的话， <a href="http://xn--www-p18d1b68beu1b65df50ausbuw1gpvct92h013at86a.packtpub.com/authors">可以了解一下我们的作者指南www.packtpub.com/authors</a> 。</p>
<h1 class="mume-header" id="%E5%AE%A2%E6%88%B7%E6%94%AF%E6%8C%81">客户支持</h1>

<p>现在您已经是本书的主人，我们会为您购买本书的行为，提供相应的支持服务。</p>
<h1 class="mume-header" id="%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD">源码下载</h1>

<p>可使用您在 <a href="http://www.packtpub.com/">http://www.packtpub.com</a> 的账号下载本书式例代码。 如果您在别处购买了本书，可以通过访问 <a href="http://wmv.packtpub.com/support">http://wmv.packtpub.com/support</a> ，客服会将注册文件直接发送给您。</p>
<p>您可以按照以下步骤下载代码：</p>
<ul>
<li>网页端使用您的电子邮件地址和密码进行登录或注册。将鼠标悬停在“SUPPORT”标签上。点击“Downloads &amp; Errata”。搜索框内键入本书的名字。选择你所查找的书籍，并下载其代码包。只需您在购买本书的下拉菜单中点击“Code Download”即可。</li>
<li>压缩包下载完毕后，请确认您所使用的解压缩软件的版本和所解压的文件夹地址。Windows：WinRAR / 7-Zip；Mac ：Zipeg / iZip / UnRarX；Linux ：7-Zip / PeaZip。</li>
</ul>
<p>本书代码github的托管地址为 <a href="https://github.com/PacktPublishing/Cpp17-STL-Cookbook">https://github.com/PacktPublishing/Cpp17-STL-Cookbook</a></p>
<p>其他书籍的代码包和视频目录在 <a href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a> 下都能看到。</p>
<p>快去看一下吧！</p>
<h1 class="mume-header" id="%E5%8B%98%E8%AF%AF%E5%88%97%E8%A1%A8">勘误列表</h1>

<p>尽管我们很认真的保证本书内容的正确性，但难免还是会出现错误。如果您在我们的书或代码中发现了疑似错误的地方，请反馈给我们，我们将感激不尽。如果这真是个错误，我们将在后续的版本中修复这个问题，以免误导更多的读者。如果您发现了任何错误，请访问 <a href="http://mvw.packtpub.com/submit-errata">http://mvw.packtpub.com/submit-errata</a> 选择本书，点击勘误提交的链接，然后详述你发现的问题。当您的勘误得到了验证，您的勘误将会记录在我们的勘误列表上。</p>
<p>想要了解之前的勘误列表, 可以在 <a href="https://mwv.packtpub.com/books/content/support">https://mwv.packtpub.com/books/content/support</a> 上面输入书籍的名字查找对应的勘误列表。想要看到的内容将会出现在勘误栏下。</p>
<h1 class="mume-header" id="%E7%9B%97%E7%89%88%E5%BF%85%E7%A9%B6">盗版必究</h1>

<p>互联网上存在着盗版问题。Packt非常重视我们的版权和许可证。如果您在网上发现我们的作品的非法副本，请提供地址或网站名称，以便我们进行维权。</p>
<p>请通过 <code>copyright@packtpub.com</code> 联系我们，麻烦在邮件内附上与涉嫌盗版的相关资料。感谢您帮助我们保护相关作品的只是产权。</p>
<h1 class="mume-header" id="%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94">问题解答</h1>

<p>如果您对本书有任何的问题，您可以通过向 <code>questions@packtpub.com</code>发送邮件告诉我们，我们会尽可能的解答您所提出的问题。</p>
</div></div><div id="ebook-heading-x5404x7ae0x6897x6982" ebook-toc-level-1="" heading="各章梗概"><div><h1 class="mume-header" id="%E5%90%84%E7%AB%A0%E6%A2%97%E6%A6%82">各章梗概</h1>

<p>第1章，C++17新特性。介绍那些对C++语言来说很重大的改变，以便后续的章节中将精力集中在STL上。</p>
<p>第2章，STL容器。STL容器在C++17标准中进行了升级，让我们见识一下STL容器的数据类型是多么的丰富。粗略的了解一下容器后，再仔细了解其添加的内容。</p>
<p>第3章，迭代器。迭代器是STL中很重要的概念，其将STL算法和容器数据类型二者紧密联系在一起。我们将用实际例子来了解如何使用迭代器，从而更好的了解迭代器的概念。</p>
<p>第4章，Lambda表达式。这是一种很有意思的编程模式，其为纯函数式编程的方式。C++11标准引入Lambda表达式，C++14和C++17标准为其添加了一些新特性。</p>
<p>第5章，STL基础算法。介绍了STL的标准算法的特点，简单易用、高效、鲁棒性好和高度通用。我们将学习如何使用它们，这样就可以集中精力在解决问题上，而不是浪费时间去重新发明轮子。</p>
<p>第6章，STL算法的高级使用方式。演示如何通过使用STL基本算法，以更简洁的方式编写更复杂的算法，而无需重复代码。本章中，充分利用STL解决更复杂问题的同时，将学习如何结合现有的算法，来创建真正符合需求的新算法。</p>
<p>第7章，字符串，流和正则表达。对STL中关于字符串、通用I/O流和正则表达式的类型进行详细概述。</p>
<p>第8章，工具类。了解STL如何生成随机数、测量时间、管理动态内存、优雅地提示错误等等。我们会来了解一下这些极为有用、高可移植性的工具类，并且会介绍C++17带来的全新STL工具。</p>
<p>第9章，并行和并发。多处理器领域编写代码时，并行和并发就变得很重要。C++11标准首先引入并行和并发的概念，随后C++17进行加强，这对于我们编写并发程序来说有很大的帮助。</p>
<p>第10章，文件系统。虽然之前的STL提供对单个文件读取和操作，但这还无法达到用户的需求。C++17添加了很多新的操作(独立于操作系统库)用于处理文件系统路径，以及对目录进行遍历。</p>
</div></div><div id="ebook-heading-x7b2c1x7ae0-c17x7684x65b0x7279x6027" ebook-toc-level-1="" heading="第1章 C++17的新特性"><div><h1 class="mume-header" id="%E7%AC%AC1%E7%AB%A0-c17%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">第1章 C++17的新特性</h1>

<p>C++11，C++14和C++17标准为C++添加了许多新特性。当前的C++已经和10年前的C++完全不同了。C++标准并不是用来规范语言的，其实为了让相应编译器理解相应的语义，也是为了更好的理解C++标准模板库(STL)。</p>
<p>这本书中的例子展示了如何充分的利用STL。不过，作为本书的第1章，我们还是需要了解一下那些比较重要的新语言特性。掌握了这些新的语言特性，有助于你编写可读性高、可维护性强和表达性清晰的代码。</p>
<p>我们将了解到如何单独访问组对、元组和结构化绑定的数据结构的成员，以及如何使用新的<code>if</code>和<code>switch</code>限制变量的作用范围。新的括号初始化语法于C++11的语法有歧义，虽然看上去是相同的，不过这个已经被<em>新括号初始化规则</em>所修复。模板类实例的类型现在可以从构造函数的参数中自动推断出来，如果对一个模板类进行不同类型的特化，将会产生完全不同的代码，不过现在用<code>constexpr-if</code>就能很容易的表示。大多数情况下，使用折叠表达式处理模板函数的可变参数包，会变得更加容易。最后，在只有头文件的库中使用声明内联变量，来定义全局静态对象会变得更加舒服，这之前的标准中只能在函数中进行。</p>
<p>库的实现者可能比实现应用程序的开发者对本章的示例更感兴趣。虽然我们有足够的理由去了解这些特性，但为了理解本书的其余部分，无需立即理解本章的所有示例。</p>
</div></div><div id="ebook-heading-x4f7fx7528x7ed3x6784x5316x7ed1x5b9ax6765x89e3x5305x7ed1x5b9ax7684x8fd4x56dex503c" ebook-toc-level-2="" heading="使用结构化绑定来解包绑定的返回值"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E6%9D%A5%E8%A7%A3%E5%8C%85%E7%BB%91%E5%AE%9A%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">使用结构化绑定来解包绑定的返回值</h1>

<p>C++17配备了一种新的特性——<strong>结构化绑定</strong>，其可以结合语法糖来自动推到类型，并可以从组对、元组和结构体中提取单独的变量。其他编程语言中，这种特性也被成为<strong>解包</strong>。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>使用结构化绑定是为了能够更加简单的，为绑定了多个变量的结构体进行赋值。我们先来看下在C++17标准之前是如何完成这个功能的。然后，我们将会看到一些使用C++17实现该功能的例子：</p>
<ul>
<li>
<p>访问<code>std::pair</code>中的一个元素：假设我们有一个数学函数<code>divide_remainder</code>，需要输入一个除数和一个被除数作为参数，返回得到的分数的整数部分和余数。可以使用一个<code>std::pair</code>来绑定这两个值:</p>
<p><code>std::pair&lt;int, int&gt; divide_remainder(int dividend, int divisor);</code></p>
</li>
</ul>
<p>考虑使用如下的方式访问组对中的单个值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">result</span> <span class="token punctuation">(</span><span class="token function">divide_remainder</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"16 / 3 is "</span> <span class="token operator">&lt;&lt;</span>
          <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" with a remainder of "</span>
          <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><p>与上面的代码段不同，我们现在可以将相应的值赋予对应的变量，这样写出来的代码可读性更高:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">[</span>fraction<span class="token punctuation">,</span> remainder<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">divide_remainder</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"16 / 3 is "</span>
          <span class="token operator">&lt;&lt;</span> fraction <span class="token operator">&lt;&lt;</span> <span class="token string">" with a remainder of "</span>
          <span class="token operator">&lt;&lt;</span> remainder <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><ul>
<li>也能对<code>std::tuple</code>进行结构化绑定：让我们使用下面的实例函数，获取股票的在线信息：</li>
</ul>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span>time_point<span class="token punctuation">,</span> <span class="token keyword keyword-unsigned">unsigned</span><span class="token operator">&gt;</span>
<span class="token function">stock_info</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>我们可以使用如下的方式获取这个例子的各个变量的值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> valid_time<span class="token punctuation">,</span> price<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">stock_info</span><span class="token punctuation">(</span><span class="token string">"INTC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><ul>
<li>结构化绑定也能用在自定义结构体上。假设有这么一个结构体：</li>
</ul>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">employee</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> id<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string role<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> salary<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>现在我们来看下如何使用结构化绑定访问每一个成员。我们假设有一组<code>employee</code>结构体的实例，存在于<code>vector</code>中，下面使用循环将其内容进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>employee<span class="token operator">&gt;</span> employees<span class="token punctuation">{</span>
        <span class="token comment">/* Initialized from somewhere */</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> role<span class="token punctuation">,</span> salary<span class="token punctuation">]</span> <span class="token operator">:</span> employees<span class="token punctuation">)</span><span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Name: "</span> <span class="token operator">&lt;&lt;</span> name
                  <span class="token operator">&lt;&lt;</span> <span class="token string">"Role: "</span> <span class="token operator">&lt;&lt;</span> role
                  <span class="token operator">&lt;&lt;</span> <span class="token string">"Salary: "</span> <span class="token operator">&lt;&lt;</span> salary <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre><h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>结构化绑定以以下方式进行应用：</p>
<p><code>auto [var1, var2, ...] = &lt;pair, tuple, struct, or array expression&gt;;</code></p>
<ul>
<li><code>var1, var2, ...</code>表示一个变量列表，其变量数量必须匹配表达式所对应的结构。</li>
<li><code>&lt;pair, tuple, struct, or array expression&gt;</code>必须是下面的其中一种：
<ul>
<li>一个<code>std::pair</code>实例。</li>
<li>一个<code>std::tuple</code>实例。</li>
<li>一个结构体实例。其所有成员都必须是非静态成员，每个成员以基础类定义。结构体中的第一个声明成员赋予第一个变量的值，第二个声明的编程赋予第二个变量的值，依次类推。</li>
<li>固定长度的数组。</li>
</ul>
</li>
<li><code>auto</code>部分，也就是<code>var</code>的类型，可以是<code>auto</code>,<code>const auto</code>,<code>const auto&amp;</code>和<code>auto&amp;&amp;</code>。</li>
</ul>
<blockquote>
<p>Note:</p>
<p>不仅为了性能，还必须确保在适当的时刻使用引用，尽量减少不必要的副本。</p>
</blockquote>
<p>如果中括号中变量不够，那么编译器将会报错:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-float">float</span><span class="token punctuation">,</span> <span class="token keyword keyword-long">long</span><span class="token operator">&gt;</span> <span class="token function">tup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> tup<span class="token punctuation">;</span> <span class="token comment">// Does not work</span>
</pre><p>这个例子中想要将三个成员值，只赋予两个变量。编译器会立即发现这个错误，并且提示我们:</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>error: type 'std::tuple&lt;int, float, long&gt;' decomposes into 3 elements, but only 2 names were provided
auto [a, b] = tup;
</code></pre><h2 class="mume-header" id="theres-more">There's more...</h2>

<p>STL中的基础数据结构都能通过结构结构化绑定直接进行访问，而无需修改任何东西。考虑下面这个例子，循环中打印<code>std::map</code>中的元素：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> animal_population <span class="token punctuation">{</span>
  <span class="token punctuation">{</span><span class="token string">"humans"</span><span class="token punctuation">,</span> <span class="token number">7000000000</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span><span class="token string">"chickens"</span><span class="token punctuation">,</span> <span class="token number">17863376000</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span><span class="token string">"camels"</span><span class="token punctuation">,</span> <span class="token number">24246291</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span><span class="token string">"sheep"</span><span class="token punctuation">,</span> <span class="token number">1086881528</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>species<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">:</span> animal_population<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"There are "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> species
            <span class="token operator">&lt;&lt;</span> <span class="token string">" on this planet.\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>从<code>std::map</code>容器中获取元素的方式比较特殊，我们会在每次迭代时获得一个<code>std::pair&lt;const key_type, value_type&gt;</code>实例。另外每个实例都需要进行结构化绑定(<code>key_type</code>绑定到<code>species</code>字符串上，<code>value_type</code>为一个<code>size_t</code>格式的统计数字)，从而达到访问每一个成员的目的。</p>
<p>在C++17之前，使用<code>std::tie</code>可达到类似的效果:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> remainder<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span><span class="token function">tie</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ignore<span class="token punctuation">,</span> remainder<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">divide_remainder</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"16 % 5 is "</span> <span class="token operator">&lt;&lt;</span> remainder <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><p>这个例子展示了如何将结果组对解压到两个变量中。<code>std::tie</code>的能力远没有结构化绑定强，因为在进行赋值的时候，所有变量需要提前定义。另外，本例也展示了一种在<code>std::tie</code>中有，而结构化绑定没有的功能：可以使用<code>std::ignore</code>的值，作为虚拟变量。分数部分将会赋予到这个虚拟变量中，因为这里我们不需要用到分数值，所以使用虚拟变量忽略分数值。</p>
<blockquote>
<p>Note:</p>
<p>使用结构化绑定时，就不能再使用std::tie创建虚拟变量了，所以我们不得不绑定所有值到命名过的变量上。对部分成员进行绑定的做法是高效的，因为编译器可以很容易的对未绑定的变量进行优化。</p>
</blockquote>
<p>回到之前的例子，<code>divide_remainder</code>函数也可以通过使用传入输出参数的方式进行实现：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-bool">bool</span> <span class="token function">divide_remainder</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> dividend<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> divisor<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> <span class="token operator">&amp;</span>fraction<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> <span class="token operator">&amp;</span>remainder<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>调用该函数的方式如下所示：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> fraction<span class="token punctuation">,</span> remainder<span class="token punctuation">;</span>
<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-bool">bool</span> success <span class="token punctuation">{</span><span class="token function">divide_remainder</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> fraction<span class="token punctuation">,</span> remainder<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"16 / 3 is "</span> <span class="token operator">&lt;&lt;</span> fraction <span class="token operator">&lt;&lt;</span> <span class="token string">" with a remainder of "</span>
            <span class="token operator">&lt;&lt;</span> remainder <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>很多人都很喜欢使用特别复杂的结构，比如组对、元组和结构体，他们认为这样避免了中间拷贝过程，所以代码会更快。对于现代编译器来说，这种想法不再是正确的了，这里编译器并没有刻意避免拷贝过程，而是优化了这个过程。(其实拷贝过程还是存在的)。</p>
<blockquote>
<p>Note:</p>
<p>与C的语法特征不同，将复杂结构体作为返回值传回会耗费大量的时间，因为对象需要在返回函数中进行初始化，之后将这个对象拷贝到相应容器中返回给调用端。现代编译器支持**<a href="https://zh.wikipedia.org/wiki/%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96">返回值优化</a>**(RVO, <em>return value optimization</em>)技术，这项技术可以省略中间副本的拷贝。</p>
</blockquote>
</div></div><div id="ebook-heading-x5c06x53d8x91cfx4f5cx7528x57dfx9650x5236x5728ifx548cswitchx533ax57dfx5185" ebook-toc-level-2="" heading="将变量作用域限制在if和switch区域内"><div><h1 class="mume-header" id="%E5%B0%86%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%99%90%E5%88%B6%E5%9C%A8if%E5%92%8Cswitch%E5%8C%BA%E5%9F%9F%E5%86%85">将变量作用域限制在if和switch区域内</h1>

<p>将变量的生命周期尽可能的限制在指定区域内，是一种非常好的代码风格。有时我们需要在满足某些条件时获得某个值，然后对这个值进行操作。</p>
<p>为了让这个过程更简单，C++17中为if和switch配备了初始化区域。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>这个案例中，我们使用初始化语句，来了解下其使用方式：</p>
<ul>
<li><code>if</code>：假设我们要在一个字母表中查找一个字母，我们<code>std::map</code>的成员<code>find</code>完成这个操作：</li>
</ul>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token function">itr</span> <span class="token punctuation">(</span>character_map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> itr <span class="token operator">!=</span> character_map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// *itr is valid. Do something with it.</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// itr is the end-iterator. Don't dereference.</span>
<span class="token punctuation">}</span>
<span class="token comment">// itr is not available here at all</span>
</pre><ul>
<li><code>switch</code>：这个例子看起来像是从玩家输入的字母决定某个游戏中的行为。通过使用<code>switch</code>查找字母相对应的操作：</li>
</ul>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-switch">switch</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-case">case</span> <span class="token string">'a'</span><span class="token operator">:</span> <span class="token function">move_left</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-case">case</span> <span class="token string">'s'</span><span class="token operator">:</span> <span class="token function">move_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-case">case</span> <span class="token string">'w'</span><span class="token operator">:</span> <span class="token function">move_fwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-case">case</span> <span class="token string">'d'</span><span class="token operator">:</span> <span class="token function">move_right</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-case">case</span> <span class="token string">'q'</span><span class="token operator">:</span> <span class="token function">quit_game</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-case">case</span> <span class="token string">'0'</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.'9'</span><span class="token operator">:</span> <span class="token function">select_tool</span><span class="token punctuation">(</span><span class="token string">'0'</span> <span class="token operator">-</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-default">default</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"invalid input: "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>带有初始化的<code>if</code>和<code>switch</code>相当于语法糖一样。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token comment">// if: before C++17</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">var</span><span class="token punctuation">(</span>init_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// branch A. var is accessible</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// branch B. var is accessible</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// var is still accessible</span>
<span class="token punctuation">}</span>
</pre><pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token comment">// if: since C++17</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token function">var</span> <span class="token punctuation">(</span>init_value<span class="token punctuation">)</span><span class="token punctuation">;</span> condition<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// branch A. var is accessible</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// branch B. var is accessible</span>
<span class="token punctuation">}</span>
<span class="token comment">// var is not accessible any longer</span>
</pre><pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token comment">// switch: before C++17</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">var</span> <span class="token punctuation">(</span>init_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-switch">switch</span> <span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword keyword-case">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      <span class="token keyword keyword-case">case</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// var is still accessible</span>
<span class="token punctuation">}</span>
</pre><pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token comment">// switch: since C++17</span>
<span class="token keyword keyword-switch">switch</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token function">var</span> <span class="token punctuation">(</span>init_value<span class="token punctuation">)</span><span class="token punctuation">;</span> var<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-case">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword keyword-case">case</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token comment">// var is not accessible any longer</span>
</pre><p>这些有用的特性保证了代码的简洁性。C++17之前只能使用外部括号将代码包围，就像上面的例子中展示的那样。减短变量的生命周期，能帮助我们保持代码的整洁性，并且更加易于重构。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>另一个有趣的例子是临界区限定变量生命周期。</p>
<p>先来看个栗子：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lg <span class="token punctuation">{</span>my_mutex<span class="token punctuation">}</span><span class="token punctuation">;</span> some_condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Do something</span>
<span class="token punctuation">}</span>
</pre><p>首先，创建一个<code>std::lock_guard</code>。这个类接收一个互斥量和作为其构造函数的参数。这个类在其构造函数中对互斥量上锁，之后当代码运行完这段区域后，其会在析构函数中对互斥量进行解锁。这种方式避免了忘记解锁互斥量而导致的错误。C++17之前，为了确定解锁的范围，需要一对额外的括号对。</p>
<p>另一个例子中对弱指针进行区域限制：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token function">shared_pointer</span> <span class="token punctuation">(</span>weak_pointer<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> shared_pointer <span class="token operator">!=</span> <span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Yes, the shared object does still exist</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// shared_pointer var is accessible, but a null pointer</span>
<span class="token punctuation">}</span>
<span class="token comment">// shared_pointer is not accessible any longer</span>
</pre><p>这个例子中有一个临时的<code>shared_pointer</code>变量，虽然<code>if</code>条件块或外部括号会让其保持一个无用的状态，但是这个变量确实会“泄漏”到当前范围内。</p>
<p>当要使用传统API的输出参数时，<code>if</code>初始化段就很有用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>DWORD exit_code<span class="token punctuation">;</span> <span class="token function">GetExitCodeProcess</span><span class="token punctuation">(</span>process_handle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>exit_code<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Exit code of process was: "</span> <span class="token operator">&lt;&lt;</span> exit_code <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// No useless exit_code variable outside the if-conditional</span>
</pre><p><code>GetExitCodeProcess</code>函数是Windows操作系统的内核API函数。其通过返回码来判断给定的进程是否合法的处理完成。当离开条件域，变量就没用了，也就可以销毁这个变量了。</p>
<p>具有初始化段的<code>if</code>代码块在很多情况下都特别有用，尤其是在使用传统API的输出参数进行初始化时。</p>
<blockquote>
<p>Note:</p>
<p>使用带有初始化段的<code>if</code>和<code>switch</code>能保证代码的紧凑性。这使您的代码紧凑，更易于阅读，在重构过程中，会更容易改动。</p>
</blockquote>
</div></div><div id="ebook-heading-x65b0x7684x62ecx53f7x521dx59cbx5316x89c4x5219" ebook-toc-level-2="" heading="新的括号初始化规则"><div><h1 class="mume-header" id="%E6%96%B0%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99">新的括号初始化规则</h1>

<p>C++11引入了新的括号初始化语法<code>{}</code>。其不仅允许集合式初始化，而且还是对常规构造函数的调用。遗憾的是，当与<code>auto</code>类型变量结合时，这种方式就很容易出现错误。C++17将会增强这一系列初始化规则。本节中，我们将了解到如何使用C++17语法正确的初始化变量。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>一步初始化所有变量。使用初始化语法时，注意两种不同的情况：</p>
<ul>
<li>不使用auto声明的括号初始化：</li>
</ul>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token comment">// Three identical ways to initialize an int:</span>
<span class="token keyword keyword-int">int</span> x1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> x2<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> <span class="token function">x3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v1<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Vector with three ints</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// same here</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token function">v3</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Vector with 10 ints, each have value 20</span>
</pre><ul>
<li>使用auto声明的括号初始化：</li>
</ul>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> v <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// v is int</span>
<span class="token keyword keyword-auto">auto</span> w <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// error: only single elements in direct</span>
              <span class="token comment">// auto initialization allowed! (this is new)</span>
<span class="token keyword keyword-auto">auto</span> x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// x is std::initializer_list&lt;int&gt;</span>
<span class="token keyword keyword-auto">auto</span> y <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// y is std::initializer_list&lt;int&gt;</span>
<span class="token keyword keyword-auto">auto</span> z <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// error: Cannot deduce element type</span>
</pre><h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>无<code>auto</code>类型声明时，<code>{}</code>的操作没什么可大惊小怪的。当在初始化STL容器时，例如<code>std::vector</code>，<code>std::list</code>等等，括号初始化就会去匹配<code>std::initializer_list</code>(初始化列表)的构造函数，从而初始化容器。其构造函数会使用一种“贪婪”的方式，这种方式就意味着不可能匹配非聚合构造函数(与接受初始化列表的构造函数相比，非聚合构造函数是常用构造函数)。</p>
<p><code>std::vector</code>就提供了一个特定的非聚合构造函数，其会使用任意个相同的数值填充<code>vector</code>容器：<code>std::vector&lt;int&gt; v(N, value)</code>。当写成<code>std::vector&lt;int&gt; v{N, value}</code>时，就选择使用<code>initializer_list</code>的构造函数进行初始化，其会将<code>vector</code>初始化成只有N和value两个元素的变量。这个“陷阱”大家应该都知道。</p>
<p><code>{}</code>与<code>()</code>调用构造函数初始化的方式，不同点在于<code>{}</code>没有类型的隐式转换，比如<code>int x(1.2);</code>和<code>int x = 1.2;</code>通过静默的对浮点值进行向下取整，然后将其转换为整型，从而将x的值初始化为1。相反的，<code>int x{1.2};</code>将会遇到编译错误，初始化列表中的初始值，需要与变量声明的类型完全匹配。</p>
<blockquote>
<p>Note:</p>
<p>哪种方式是最好的初始化方式，目前业界是有争议的。括号初始化的粉丝们提出，使用括号的方式非常直观，直接可以调用构造函数对变量进行初始化，并且代码行不会做多于的事情。另外，使用{}括号将会是匹配构造函数的唯一选择，这是因为使用()进行初始化时，会尝试匹配最符合条件的构造函数，并且还会对初始值进行类型转换，然后进行匹配(这就会有处理构造函数二义性的麻烦)。</p>
</blockquote>
<p>C++17添加的条件也适用于auto(推断类型)——C++11引入，用于正确的推导匹配变量的类型。<code>auto x{123};</code>中<code>std::initializer_list&lt;int&gt;</code>中只有 一个元素，这并不是我们想要的结果。C++17将会生成一个对应的整型值。</p>
<p>经验法则：</p>
<ul>
<li><code>auto var_name {one_element};</code>将会推导出var_name的类型——与one_element一样。</li>
<li><code>auto var_name {element1, element2, ...};</code>是非法的，并且无法通过编译。</li>
<li><code>auto var_name = {element1, element2, ...};</code>将会使用<code>std::initializer_list&lt;T&gt;</code>进行初始化，列表中elementN变量的类型均为T。</li>
</ul>
<p>C++17加强了初始化列表的鲁棒性。</p>
<blockquote>
<p>Note:</p>
<p>使用C++11/C++14模式的编译器解决这个问题时，有些编译器会将<code>auto x{123};</code>的类型推导成整型，而另外一些则会推导成 <code>std::initializer_list&lt;int&gt;</code>。所以，这里需要特别注意，编写这样的代码，可能会导致有关可移植性的问题！</p>
</blockquote>
</div></div><div id="ebook-heading-x6784x9020x51fdx6570x81eax52a8x63a8x5bfcx6a21x677fx7684x7c7bx578b" ebook-toc-level-2="" heading="构造函数自动推导模板的类型"><div><h1 class="mume-header" id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%B1%BB%E5%9E%8B">构造函数自动推导模板的类型</h1>

<p>C++中很多类都需要指定类型，其实这个类型可以从用户所调用的构造函数中推导出来。不过，在C++17之前，这是一个未标准化的特性。C++17能让编译器自动的从所调用的构造函数，推导出模板类型。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>使用最简单的方法创建<code>std::pair</code>和<code>std::tuple</code>实例。其可以实现一步创建。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>pair <span class="token function">my_pair</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// std::pair&lt;int, const char*&gt;</span>
std<span class="token double-colon punctuation">::</span>tuple <span class="token function">my_tuple</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">12.3</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// std::tuple&lt;int, double, const char*&gt;</span>
</pre><h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>让我们定义一个类，了解自动化的对模板类型进行推断的价值。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">T2</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">T3</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">my_wrapper</span> <span class="token punctuation">{</span>
  T1 t1<span class="token punctuation">;</span>
  T2 t2<span class="token punctuation">;</span>
  T3 t3<span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
  <span class="token keyword keyword-explicit">explicit</span> <span class="token function">my_wrapper</span><span class="token punctuation">(</span>T1 t1_<span class="token punctuation">,</span> T2 t2_<span class="token punctuation">,</span> T3 t3_<span class="token punctuation">)</span>
  <span class="token operator">:</span> t1<span class="token punctuation">{</span>t1_<span class="token punctuation">}</span><span class="token punctuation">,</span> t2<span class="token punctuation">{</span>t2_<span class="token punctuation">}</span><span class="token punctuation">,</span> t3<span class="token punctuation">{</span>t3_<span class="token punctuation">}</span>
  <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>好！我们定义了一个模板类。C++17之前，我们为了创建该类的实例：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">my_wrapper<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">&gt;</span> wrapper <span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">1.23</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>我们省略模板特化的部分：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">my_wrapper wrapper <span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">1.23</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>C++17之前，我们可能会通过以下的方式实现一个工厂函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">my_wrapper<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> T3<span class="token operator">&gt;</span> <span class="token function">make_wrapper</span><span class="token punctuation">(</span>T1 t1<span class="token punctuation">,</span> T2 t2<span class="token punctuation">,</span> T3 t3<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>使用工厂函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">wrapper</span> <span class="token punctuation">(</span><span class="token function">make_wrapper</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">1.23</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><blockquote>
<p>Note:</p>
<p>STL中有很多工厂函数，比如<code>std::make_shared</code>、<code>std::make_unique</code>、<code>std::make_tuple</code>等等。C++17中，这些工厂函数就过时了。当然，考虑到兼容性，这些工厂函数在之后还会保留。</p>
</blockquote>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>我们已经了解过<em>隐式模板类型推导</em>。但一些例子中，不能依赖类型推导。如下面的例子：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token comment">// example class</span>
<span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">sum</span><span class="token punctuation">{</span>
    T value<span class="token punctuation">;</span>
    
    <span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
    <span class="token function">sum</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span> <span class="token operator">:</span> value<span class="token punctuation">{</span><span class="token punctuation">(</span>values <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>结构体中，<code>sum</code>能接受任意数量的参数，并使用折叠表达式将它们添加到一起(本章稍后的一节中，我们将讨论折叠表达式，以便了解折叠表达式的更多细节)。加法操作后得到的结果保存在<code>value</code>变量中。现在的问题是，<code>T</code>的类型是什么？如果我们不显式的进行指定，那就需要通过传递给构造函数的变量类型进行推导。当我们提供了多个字符串实例，其类型为<code>std::string</code>。当我们提供多个整型时，其类型就为<code>int</code>。当我们提供多个整型、浮点和双浮点时，编译器会确定哪种类型适合所有的值，而不丢失信息。为了实现以上的推导，我们提供了<em>指导性显式推导</em>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token function">sum</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ts<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> sum<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>common_type_t<span class="token operator">&lt;</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
</pre><p>指导性推导会告诉编译器使用<code>std::common_type_t</code>的特性，其能找到适合所有值的共同类型。来看下如何使用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">sum s <span class="token punctuation">{</span><span class="token number">1u</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4.0f</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
sum string_sum <span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">{</span><span class="token string">"abc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>value <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span>
          <span class="token operator">&lt;&lt;</span> string_sum<span class="token punctuation">.</span>value <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><p>第1行中，我们创建了一个<code>sum</code>对象，构造函数的参数类型为<code>unsigned</code>, <code>double</code>, <code>int</code>和<code>floa</code>t。<code>std::common_type_t</code>将返回<code>double</code>作为共同类型，所以我们获得的是一个<code>sun&lt;double&gt;</code>实例。第2行中，我们创建了一个<code>std::string</code>实例和一个C风格的字符串。在我们的指导下，编译器推导出这个实例的类型为<code>sum&lt;std::string&gt;</code>。</p>
<p>当我们运行这段代码时，屏幕上会打印出10和abcdef。其中10为数值<code>sum</code>的值，abcdef为字符串<code>sum</code>的值。</p>
</div></div><div id="ebook-heading-x4f7fx7528constexpr-ifx7b80x5316x7f16x8bd1" ebook-toc-level-2="" heading="使用constexpr-if简化编译"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8constexpr-if%E7%AE%80%E5%8C%96%E7%BC%96%E8%AF%91">使用constexpr-if简化编译</h1>

<p>模板化编程中，通常要以不同的方式做某些事情，比如特化模板类型。C++17带了<code>constexpr-if</code>表达式，可以在很多情况下简化代码。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们会实现一个很小的辅助模板类。它能处理不同模板类型的特化，因为它可以在完全不同的代码中，选取相应的片段，依据这些片段的类型对模板进行特化：</p>
<ol>
<li>
<p>完成代码中的通用部分。在我们的例子中，它是一个简单的类，它的成员函数<code>add</code>，支持对<code>U</code>类型值与<code>T</code>类型值的加法:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">addable</span>
<span class="token punctuation">{</span>
  T val<span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
  <span class="token function">addable</span><span class="token punctuation">(</span>T v<span class="token punctuation">)</span> <span class="token operator">:</span> val<span class="token punctuation">{</span>v<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
  T <span class="token function">add</span><span class="token punctuation">(</span>U x<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> val <span class="token operator">+</span> x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>假设类型<code>T</code>是<code>std::vector&lt;something&gt;</code>，而类型<code>U</code>是<code>int</code>。这里就有问题了，为整个<code>vector</code>添加整数是为了什么呢？其应该是对<code>vector</code>中的每个元素加上一个整型数。实现这个功能就需要在循环中进行：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
T <span class="token function">add</span><span class="token punctuation">(</span>U x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword keyword-auto">auto</span> <span class="token function">copy</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Get a copy of the vector member</span>
  <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>n <span class="token operator">:</span> copy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    n <span class="token operator">+=</span> x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword keyword-return">return</span> copy<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>下一步也是最后一步，将两种方式结合在一起。如果<code>T</code>类型是一个<code>vector</code>，其每个元素都是<code>U</code>类型，择进行循环。如果不是，则进行普通的加法：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
T <span class="token function">add</span><span class="token punctuation">(</span>U x<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token keyword keyword-constexpr">constexpr</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>U<span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">copy</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>n <span class="token operator">:</span> copy<span class="token punctuation">)</span><span class="token punctuation">{</span>
            n <span class="token operator">+=</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-return">return</span> copy<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> val <span class="token operator">+</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在就可以使用这个类了。让我们来看下其对不同类型处理的是多么完美，下面的例子中有<code>int</code>,<code>float</code>, <code>std::vector&lt;int&gt;</code>和<code>std::vector&lt;string&gt;</code>:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">addable<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// is 3</span>
addable<span class="token operator">&lt;</span><span class="token keyword keyword-float">float</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token number">1.f</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// is 3.0</span>
addable<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token string">"aa"</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"bb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// is "aabb"</span>

std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
addable<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>v<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// is std::vector&lt;int&gt; {11, 12, 13}</span>

std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> sv<span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
addable<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>sv<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">{</span><span class="token string">"z"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// is {"az", "bz", "cz"}</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>新特性<code>constexpr-if</code>的工作机制与传统的<code>if-else</code>类似。不同点就在于前者在编译时进行判断，后者在运行时进行判断。所以，使用<code>constexpr-if</code>的代码在编译完成后，程序的这一部分其实就不会有分支存在。有种方式类似于<code>constexpr-if</code>，那就是<code>#if-#else</code>的预编译方式进行宏替换，不过这种方式在代码的构成方面不是那么优雅。组成<code>constexpr-if</code>的所有分支结构都是优雅地，没有使用分支在语义上不要求合法。</p>
<p>为了区分是向<code>vector</code>的每个元素加上x，还是普通加法，我们使用<code>std::is_same</code>来进行判断。表达式<code>std::is_same&lt;A, B&gt;::value</code>会返回一个布尔值，当A和B为同样类型时，返回true，反之返回false。我们的例子中就写为<code>std::is_same&lt;T, std::vector&lt;U&gt;&gt;::value()</code>(<code>is_same_v = is_same&lt;T, U&gt;::value;</code>)，当返回为true时，且用户指定的T为<code>std::vector&lt;X&gt;</code>，之后试图调用add，其参数类型<code>U = X</code>。</p>
<p>当然，在一个<code>constexpr-if-else</code>代码块中，可以有多个条件(注意：a和b也可以依赖于模板参数，并不需要其为编译时常量)：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-if">if</span> <span class="token keyword keyword-constexpr">constexpr</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// do something</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token keyword keyword-constexpr">constexpr</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// do something else</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// do something completely different</span>
<span class="token punctuation">}</span>
</pre><p>C++17中，很多元编程的情况更容易表达和阅读。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>这里对比一下C++17之前的实现和添加<code>constexpr-if</code>后的实现，从而体现出这个特性的加入会给C++带来多大的提升：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">addable</span><span class="token punctuation">{</span>
    T val<span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">addable</span><span class="token punctuation">(</span>T v<span class="token punctuation">)</span><span class="token operator">:</span>val<span class="token punctuation">{</span>v<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
    std<span class="token double-colon punctuation">::</span>enable_if_t<span class="token operator">&lt;</span><span class="token operator">!</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>U<span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> T<span class="token operator">&gt;</span> 
    <span class="token function">add</span><span class="token punctuation">(</span>U x<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> val <span class="token operator">+</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
    std<span class="token double-colon punctuation">::</span>enable_if_t<span class="token operator">&lt;</span><span class="token operator">!</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>U<span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>U<span class="token operator">&gt;&gt;</span>
    <span class="token function">add</span> <span class="token punctuation">(</span>U x<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">copy</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>n<span class="token operator">:</span> copy<span class="token punctuation">)</span><span class="token punctuation">{</span>
            n <span class="token operator">+=</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-return">return</span> copy<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>在没有了<code>constexpr-if</code>的帮助下，这个类看起特别复杂，不像我们所期望的那样。怎么使用这个类呢？</p>
<p>简单来看，这里重载实现了两个完全不同的<code>add</code>函数。其返回值的类型声明，让这两个函数看起里很复杂；这里有一个简化的技巧——表达式，例如<code>std::enable_if_t&lt;condition, type&gt;</code>，如果条件为真，那么就为<code>type</code>类型，反之<code>std::enable_if_t</code>表达式不会做任何事。这通常被认为是一个错误，不过我们能解释为什么什么都没做。</p>
<p>对于第二个<code>add</code>函数，相同的判断条件，但是为反向。这样，在两个实现不能同时为真。</p>
<p>当编译器看到具有相同名称的不同模板函数并不得不选择其中一个时，一个重要的原则就起作用了：替换失败不是错误(<a href="http://zh.cppreference.com/w/cpp/language/sfinae">SFINAE</a>, <strong>Substitution Failure is not An  Error</strong>)。这个例子中，就意味着如果函数的返回值来源一个错误的模板表示，无法推断得出，这时编译器不会将这种情况视为错误(和<code>std::enable_if</code>中的条件为false时的状态一样)。这样编译器就会去找函数的另外的实现。</p>
<p>很麻烦是吧，C++17中实现起来就变得简单多了。</p>
</div></div><div id="ebook-heading-x53eax6709x5934x6587x4ef6x7684x5e93x4e2dx542fx7528x5185x8054x53d8x91cf" ebook-toc-level-2="" heading="只有头文件的库中启用内联变量"><div><h1 class="mume-header" id="%E5%8F%AA%E6%9C%89%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%BA%93%E4%B8%AD%E5%90%AF%E7%94%A8%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F">只有头文件的库中启用内联变量</h1>

<p>这种库在声明函数时，始终是内联的，C++17中允许声明内联变量。C++17之前只能使用其他变通的方法实现内联变量，新标准的支持让实现只有头文件的库更加的容易。</p>
<h2 class="mume-header" id="how--its-done">How  it's done...</h2>

<p>本节中，我们创建一个类，可以作为典型头文件库的成员。其目的就是给定一个静态成员，然后使用<code>inline</code>关键字对其进行修饰，使得其实例在全局范围内都能访问到，在C++17之前这样做是不可能的。</p>
<ol>
<li>
<p><code>process_monitor</code>类必须包含一个静态成员，并且能全局访问。当该单元被重复包含时，会产生符号重定义的问题。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token comment">// foo_lib.hpp</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">process_monitor</span> <span class="token punctuation">{</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>string standard_string<span class="token punctuation">{</span>
    <span class="token string">"some static globally available string"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
process_monitor global_process_monitor<span class="token punctuation">;</span>
</pre></li>
<li>
<p>多个<code>.cpp</code>文件中包含这个头文件时，链接阶段会出错。为了修复这个问题，添加了<code>inline</code>关键字：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token comment">// foo_lib.hpp</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">process_monitor</span> <span class="token punctuation">{</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-inline">inline</span> std<span class="token double-colon punctuation">::</span>string standard_string<span class="token punctuation">{</span>
    <span class="token string">"some static globally available string"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-inline">inline</span> process_monitor global_process_monitor<span class="token punctuation">;</span>
</pre></li>
</ol>
<p>瞧，就是这样！</p>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>C++程序通常都有多个C++源文件组成(其以<code>.cpp</code>或<code>.cc</code>结尾)。这些文件会单独编译成模块/二进制文件(通常以<code>.o</code>结尾)。链接所有模块/二进制文件形成一个单独的可执行文件，或是动态库/静态库则是编译的最后一步。</p>
<p>当链接器发现一个特定的符号，被定义了多次时就会报错。举个栗子，现在我们有一个函数声明<code>int foo();</code>，当我们在两个模块中定义了同一个函数，那么哪一个才是正确的呢？链接器自己不能做主。这样没错，但是这也可能不是开发者想看到的。</p>
<p>为了能提供全局可以使用的方法，通常会在头文件中定义函数，这可以让C++的所有模块都调用头文件中函数的实现(C++中，头文件中实现的函数，编译器会隐式的使用inline来进行修饰，从而避免符号重复定义的问题)。这样就可以将函数的定义单独的放入模块中。之后，就可以安全的将这些模块文件链接在一起了。这种方式也被称为<a href="http://zh.cppreference.com/w/cpp/language/definition"><strong>定义与单一定义规则</strong></a>(ODR，One Definition Rule)。看了下图或许能更好的理解这个规则：</p>
<p><img src="./C++17 STL Cook book_files/1-6-1.png" alt=""></p>
<p>如果这是唯一的方法，就不需要只有头文件的库了。只有头文件的库非常方便，因为只需要使用<code>#include</code>语句将对应的头文件包含入C++源文件/头文件中后，就可以使用这个库了。当提供普通库时，开发者需要编写相应的编译脚本，以便连接器将库模块链接在一起，形成对应的可执行文件。这种方式对于很小的库来说是不必要的。</p>
<p>对于这样例子，<code>inline</code>关键字就能解决不同的模块中使用同一符号采用不同实现的方式。当连接器找到多个具有相同签名的符号时，这些函数定义使用<code>inline</code>进行声明，链接器就会选择首先找到的那个实现，然后认为其他符号使用的是相同的定义。所有使用<code>inline</code>定义的符号都是完全相同的，对于开发者来说这应该是常识。</p>
<p>我们的例子中，连接器将会在每个模块中找到<code>process_monitor::standard_string</code>符号，因为这些模块包含了<code>foo_lib.hpp</code>。如果没有了<code>inline</code>关键字，连接器将不知道选择哪个实现，所以其会将编译过程中断并报错。同样的原理也适用于<code>global_process_monitor</code>符号。</p>
<p>使用<code>inline</code>声明所有符号之后，连接器只会接受其找到的第一个符号，而将后续该符号的不同实现丢弃。</p>
<p>C++17之前，解决的方法是通过额外的C++模块文件提供相应的符号，这将迫使我们的库用户强制在链接阶段包含该文件。</p>
<p>传统的<code>inline</code>关键字还有另外一种功能。其会告诉编译器，可以通过实现直接放在调用它的地方来消除函数调用的过程。这样的话，代码中的函数调用会减少，这样我们会认为程序会运行的更快。如果函数非常短，那么生成的程序段也会很短(假设函数调用也需要若干个指令，保护现场等操作，其耗时会高于实际工作的代码)。当内联函数非常长，那么二进制文件的大小就会变得很大，有时并无法让代码运行的更快。因此，编译器会将<code>inline</code>关键字作为一个提示，可能会对内联函数消除函数调用。当然，编译器也会将一些函数进行内联，尽管开发者没有使用<code>inline</code>进行提示。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>C++17之前的解决方法就是将对应函数声明为静态函数，这个函数会返回某个静态对象的引用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">foo</span><span class="token punctuation">{</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-static">static</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> <span class="token function">standard_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-static">static</span> std<span class="token double-colon punctuation">::</span>string s<span class="token punctuation">{</span><span class="token string">"some standard string"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> s<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>通过这种方式，将头文件包含在多个模块中是完全合法的，但仍然可以访问相同的实例。不过，对象并没有在程序开始时立即构造，而是在第一次调用这个获取函数时才进行构造。对于一些特定的情况来说，这也个问题。假设我们想要在程序开始时就构造静态和全局函数，从而完成一些比较重要的事情(就和我们的例程库一样)，不过当程序运行后，在调用时去构造这些对象，就会带来比较大的性能开销。</p>
<p>另一个解决方法是将非模板类看做一个模板类，因此非模板类也适用于这项规则。</p>
<p>不过，以上的两种策略在C++17中不太适用了，C++17已经使用新的<code>inline</code>完美解决。</p>
</div></div><div id="ebook-heading-x4f7fx7528x6298x53e0x8868x8fbex5f0fx5b9ex73b0x8f85x52a9x51fdx6570" ebook-toc-level-2="" heading="使用折叠表达式实现辅助函数"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">使用折叠表达式实现辅助函数</h1>

<p>自C++11起，加入了变长模板参数包，能让函数结构任意数量的参数。有时，这些参数都组合成一个表达式，从中得出函数结果。C++17中使用折叠表达式，可以让这项任务变得更加简单。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>首先，实现一个函数，用于将所有参数进行累加：</p>
<ol>
<li>
<p>声明该函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span>Ts <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ts<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>那么现在我们拥有一个参数包<code>ts</code>，并且函数必须将参数包展开，然后使用表达式进行求和。如果我们对这些参数进行某个操作(比如：加法)，那么为了将这个操作应用于该参数包，就需要使用括号将表达式包围：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span>Ts <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ts<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>ts <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在我们可以调用这个函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> the_sum <span class="token punctuation">{</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// value: 15</span>
</pre></li>
<li>
<p>这个操作不仅对<code>int</code>类型起作用，我们能对任何支持加号的类型使用这个函数，比如<code>std::string</code>:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>string a<span class="token punctuation">{</span><span class="token string">"Hello "</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string b<span class="token punctuation">{</span><span class="token string">"World"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token comment">// output: Hello World</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>这里只是简单的对参数集进行简单的递归，然后应用二元操作符<code>+</code>将每个参数加在一起。这称为折叠操作。C++17中添加了<strong>折叠表达式</strong>，其能用更少的代码量，达到相同的结果。</p>
<p>其中有种称为<strong>一元折叠</strong>的表达式。C++17中的折叠参数包支持如下二元操作符：<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>^</code> <code>&amp;</code> <code>|</code> <code>=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>^=</code> <code>&amp;=</code> <code>|=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>==</code> <code>!=</code> <code>&lt;=</code> <code>&gt;=</code> <code>&amp;&amp;</code> <code>||</code> <code>,</code> <code>.*</code> <code>-&gt;*</code>。</p>
<p>这样的话，在我们的例子中表达式<code>(ts+...)</code>和<code>(...+ts)</code>等价。不过，对于某些其他的例子，这就所有不同了——当<code>...</code>在操作符右侧时，称为有“右折叠”；当<code>...</code>在操作符左侧时，称为”左折叠“。</p>
<p>我们sum例子中，一元左折叠的扩展表达式为<code>1+(2+(3+(4+5)))</code>，一元右折叠的扩展表达式为<code>(((1+2)+3)+4)+5</code>。根据操作符的使用，我们就能看出差别。当用来进行整数相加，那么就没有区别。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>如果在调用sum函数的时候没有传入参数，那么可变参数包中就没有可以被折叠的参数。对于大多数操作来说，这将导致错误(对于一些例子来说，可能会是另外一种情况，我们后面就能看到)。这时我们就需要决定，这时一个错误，还是返回一个特定的值。如果是特定值，显而易见应该是0。</p>
<p>如何返回一个特定值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span>typenme <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">sume</span><span class="token punctuation">(</span>Ts <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ts<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>ts <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p><code>sum()</code>会返回0，<code>sum(1, 2, 3)</code>返回<code>(1+(2+(3+0)))</code>。这样具有初始值的折叠表达式称为<strong>二元折叠</strong>。</p>
<p>当我们写成<code>(ts + ... + 0)</code>或<code>(0 + ... + ts)</code>时，不同的写法就会让二元折叠表达式处于不同的位置(二元右折叠或二元左折叠)。下图可能更有助于理解左右二元折叠：</p>
<p><img src="./C++17 STL Cook book_files/1-7-1.png" alt=""></p>
<p>为了应对无参数传入的情况，我们使用二元折叠表达式，这里标识元素这个概念很重要——本例中，将0加到其他数字上不会有任何改变，那么0就一个标识元素。因为有这个属性，对于加减操作来说，可以将0添加入任何一个折叠表达式，当参数包中没有任何参数时，我们将返回0。从数学的角度来看，这没问题。但从工程的角度，我们需要根据我们需求，定义什么是正确的。</p>
<p>同样的原理也适用于乘法。这里，标识元素为1：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">product</span><span class="token punctuation">(</span>Ts <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ts<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>ts <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p><code>product(2, 3)</code>的结果是6，<code>product()</code>的结果是1。</p>
<p>逻辑操作符<code>and(&amp;&amp;)</code>和<code>or(||)</code>具有内置的标识元素。<code>&amp;&amp;</code>操作符为true，<code>||</code>操作符为false。</p>
<p>对于逗号表达式来说，其标识元素为<code>void()</code>。</p>
<p>为了更好的理解这特性，让我们可以使用这个特性来实现的辅助函数。</p>
<p><strong>匹配范围内的单个元素</strong></p>
<p>如何告诉函数在一定范围内，我们提供的可变参数至少包含一个值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> R<span class="token operator">&amp;</span> range<span class="token punctuation">,</span> Ts <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ts<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">count</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>range<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">end</span><span class="token punctuation">(</span>range<span class="token punctuation">)</span><span class="token punctuation">,</span> ts<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>辅助函数中使用STL中的<code>std::count</code>函数。这个函数需要三个参数：前两个参数定义了迭代器所要遍历的范围，第三个参数则用于与范围内的元素进行比较。<code>std::count</code>函数会返回范围内与第三个参数相同元素的个数。</p>
<p>在我们的折叠表达式中，我们也会将开始和结束迭代器作为确定范围的参数传入<code>std::count</code>函数。不过，对于第三个参数，我们将会每次从参数包中放入一个不同参数。最后，函数会将结果相加返回给调用者。</p>
<p>可以这样使用:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">matches</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// return 2</span>
<span class="token function">matches</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// return 0</span>
<span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// return 0</span>
<span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// return 3</span>
</pre><p>如我们所见，<code>matches</code>辅助函数十分灵活——可以直接传入<code>vector</code>或<code>string</code>直接调用。其对于初始化列表也同样适用，也适用于<code>std::list</code>，<code>std::array</code>，<code>std::set</code>等STL容器的实例。</p>
<p><strong>检查集合中的多个插入操作是否成功</strong></p>
<p>我们完成了一个辅助函数，用于将任意数量参数插入<code>std::set</code>实例中，并且返回是否所有插入操作都成功完成：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-bool">bool</span> <span class="token function">insert_all</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>set<span class="token punctuation">,</span> Ts <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ts<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span><span class="token punctuation">.</span>second <span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>那么这个函数如何工作呢？<code>std::set</code>的<code>insert</code>成员函数声明如下：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> value_type<span class="token operator">&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>手册上所述，当我们使用<code>insert</code>函数插入一个元素时，该函数会使用一个包含一个迭代器和一个布尔值的组对作为返回值。当该操作成功，那么迭代器指向的就是新元素在<code>set</code>实例中的位置。否则，迭代器指向某个已经存在的元素，这个元素与插入项有冲突。</p>
<p>我们的辅助函数在完成插入后，会访问<code>.second</code>区域，这里的布尔值反映了插入操作成功与否。如果所有插入操作都为true，那么都是成功的。折叠标识使用逻辑操作符<code>&amp;&amp;</code>链接所有插入结果的状态，并且返回计算之后的结果。</p>
<p>可以这样使用它：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>set<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> my_set<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">insert_all</span><span class="token punctuation">(</span>my_set<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Returns true</span>
<span class="token function">insert_all</span><span class="token punctuation">(</span>my_set<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Returns false, because the 2 collides</span>
</pre><p>需要注意的是，当在插入3个元素时，第2个元素没有插入成功，那么<code>&amp;&amp;</code>会根据短路特性，终止插入剩余元素：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>set<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> my_set<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">insert_all</span><span class="token punctuation">(</span>my_set<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Returns flase</span>
<span class="token comment">// set contains {1, 2, 3, 4} now, without the 5!</span>
</pre><p><strong>检查所有参数是否在范围内</strong></p>
<p>当要检查多个变量是否在某个范围内时，可以多次使用查找单个变量是否在某个范围的方式。这里我们可以使用折叠表达式进行表示：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-bool">bool</span> <span class="token function">within</span><span class="token punctuation">(</span>T min<span class="token punctuation">,</span> T max<span class="token punctuation">,</span> Ts <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ts<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>min <span class="token operator">&lt;=</span> ts <span class="token operator">&amp;&amp;</span> ts <span class="token operator">&lt;=</span> max<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>表达式<code>(min &lt;= ts &amp;&amp; ts &lt;= max)</code>将会告诉调用者参数包中的每一个元素是否在这个范围内。我们使用<code>&amp;&amp;</code>操作符对每次的结果进行处理，从而返回最终的结果。</p>
<p>如何使用这个辅助函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token function">within</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// --&gt; false</span>
<span class="token function">within</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// --&gt; true</span>
<span class="token function">within</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token number">5.1</span><span class="token punctuation">,</span> <span class="token number">5.2</span><span class="token punctuation">,</span> <span class="token number">5.3</span><span class="token punctuation">)</span> <span class="token comment">// --&gt; true</span>
</pre><p>这个函数也是很灵活的，其只需要传入的参数类型可以进行比较，且支持<code>&lt;=</code>操作符即可。并且该规则对于<code>std::string</code>都是适用的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>string aaa <span class="token punctuation">{</span><span class="token string">"aaa"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string bcd <span class="token punctuation">{</span><span class="token string">"bcd"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string def <span class="token punctuation">{</span><span class="token string">"def"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string zzz <span class="token punctuation">{</span><span class="token string">"zzz"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">within</span><span class="token punctuation">(</span>aaa<span class="token punctuation">,</span> zzz<span class="token punctuation">,</span> bcd<span class="token punctuation">,</span> def<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// --&gt; true</span>
<span class="token function">within</span><span class="token punctuation">(</span>aaa<span class="token punctuation">,</span> def<span class="token punctuation">,</span> bcd<span class="token punctuation">,</span> zzz<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// --&gt; false</span>
</pre><p><strong>将多个元素推入vector中</strong></p>
<p>可以编写一个辅助函数，不会减少任何结果，又能同时处理同一类的多个操作。比如向<code>std::vector</code>传入元素:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">insert_all</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>vec<span class="token punctuation">,</span> Ts <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ts<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token function">insert_all</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>需要注意的是，使用了逗号操作符将参数包展开，然后推入vector中。该函数也不惧空参数包，因为逗号表达式具有隐式标识元素，<code>void()</code>可以翻译为<em>什么都没做</em>。</p>
</div></div><div id="ebook-heading-x7b2c2x7ae0-stlx5bb9x5668" ebook-toc-level-1="" heading="第2章 STL容器"><div><h1 class="mume-header" id="%E7%AC%AC2%E7%AB%A0-stl%E5%AE%B9%E5%99%A8">第2章 STL容器</h1>

<p>C++标准库中有大量的标准容器。容器通常包含一组数据或对象的集合。容器的厉害之处在于几乎可以和任何类型的对象一起使用，所以我们只需要为程序选择合适的容器即可。STL带给我们栈、自动增长的vector、map等等。这样我们就可以集中精力于我们的应用，而不用重复制作轮子。了解所有容器，对于C++开发者来说至关重要。</p>
<p>STL容器的分类如下，会在各节中进行详细描述：</p>
<ul>
<li>连续存储</li>
<li>列表存储</li>
<li>搜索树</li>
<li>哈希表</li>
<li>容器适配器</li>
</ul>
<h2 class="mume-header" id="%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8">连续存储</h2>

<p>想要存储一组对象最简单的方式，就是将其一个接一个的存在一块比较大的内存当中。内存可以使用随机访问的方式进行，其时间复杂度为O(1)。</p>
<p>最简单的方式就是使用<code>std::array</code>，其就是对C风格数组的一种包装。不过，<code>std::array</code>要比C风格数组要先进的多，因为其没有运行时开销，而且进行元素添加时，也会十分舒适和安全。还有一点和C风格数组一样，一旦创建，其长度就是固定的，创建过后无法改变长度。</p>
<p><code>std::vector</code>和<code>std::array</code>很类似，不过<code>std::vector</code>的长度可变。其会使用堆上的内存来存储对象。当新元素添加到<code>vector</code>中后，当前长度超过了原始的长度，那么<code>std::vector</code>会自动新分配一段更大的内存，用来放置包括新插入元素的所有元素，并且释放之前所占用的内存。此外，当新元素需要插入到两个旧元素之间时，<code>std::vector</code>会移动当前已有的元素。当要删除<code>vector</code>中间的一个已存在元素，那么<code>vector</code>类会自动地移动其他对象，将删除后的缝隙填补起来。</p>
<p>如果有大量元素在<code>std::vector</code>的头部或尾部进行插入或删除，那么为了填补空隙和移动已有元素，将会耗费很多时间。如遇到这样的情况，建议你考虑使用<code>std::deque</code>。对象集合会存储在多段固定长度的连续内存中，这些内存段是相互独立的。这就使得双向队列变得很简单，并且增长也很容易，因为不同的内存段相对独立，只需要将新分配的内存段加入就可以了，无需对其他已存在的内存段进行移动。减少的场景也是一样的。</p>
<h2 class="mume-header" id="%E5%88%97%E8%A1%A8%E5%AD%98%E5%82%A8">列表存储</h2>

<p><code>std::list</code>是一个典型的双向链表。如果是单向列表，那就需要进行遍历，所以<code>std::forward_list</code>的优势在维护的复杂性上，因为其指针方向只有一个方向。列表遍历的时间复杂度是线性的O(n)。其在特定位置上插入和删除元素的时间复杂度为O(1)。</p>
<h2 class="mume-header" id="%E6%90%9C%E7%B4%A2%E6%A0%91">搜索树</h2>

<p>当对象集具有可进行排序的自然属性时，可以使用小于的关系将这些元素进行排序，我们就可以使用搜索树来保存这个排序关系。从名字就可以看出，搜索树可以帮助我们很容易的通过一个关键字查找到对应元素，其搜索的时间复杂度为O(log(n))。</p>
<p>STL提供了不同种类的树，<code>std::set</code>是其中最简单的一种，保存元素不重复，存储的元素是可排序的(用一种树的结构)。</p>
<p><code>std::map</code>使用的是另一种方式，将存储的数据使用组对进行存储。一个组对有一个key值和一个对应值构成。搜索树会对key值部分进行排序，使组对能作为<code>std::map</code>的一种关联容器。<code>std::map</code>的key值和<code>std::set</code>的值一样，在整个树中只能存在一个。</p>
<p><code>std::multiset</code>和<code>std::multimap</code>是被特化的，key对象可以是重复的。</p>
<h2 class="mume-header" id="%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</h2>

<p>讨论关联容器时，搜索树并不是唯一的方式。使用哈希表查找元素的时间复杂度只有O(1)，不过这就会忽略其自然序，所以不能简单的使用排序的方式进行遍历。哈希表大小可由用户控制，并且可以单独选择哈希函数，这是一项很重要的特性，因为其性能与空间复杂度依赖于此。</p>
<p><code>std::unordered_set</code>和<code>std::unordered_map</code>具有很多接口与<code>std::set</code>和<code>std::map</code>一样，它们之间几乎可以相互替换。</p>
<p>搜索树的实现中，容器都具有多个变种： <code>std::unordered_multiset</code>和<code>std::unordered_multimap</code>，这两种方法都取消了对象/键的唯一性，因此我们可以用相同的键存储多个元素。</p>
<h2 class="mume-header" id="%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8">容器适配器</h2>

<p>数组、列表、树和哈希表并不是存储和访问数据的唯一方式，这里还有栈、队列等其他的方式也可以存储和访问数据。类似的，越复杂的结构可以使用越原始的方式实现，并且STL使用以下形式的容器适配器进行操作：<code>std::stack</code>、<code>std::queue</code>和<code>std::priotity_queue</code>。</p>
<p>最牛X的是当我们需要这样的数据结构时，我们可以选择一种适配器。然后，当我们觉得到它们性能较差时，就可以改变一个模板参数，以便让适配器使用不同的容器实现。实践中，这也就意味着我们可以将<code>std::stack</code>实例中的元素类型从<code>std::vector</code>切换成<code>std::deque</code>。</p>
</div></div><div id="ebook-heading-x64e6x9664x79fbx9664stdvectorx5143x7d20" ebook-toc-level-2="" heading="擦除/移除std::vector元素"><div><h1 class="mume-header" id="%E6%93%A6%E9%99%A4%E7%A7%BB%E9%99%A4stdvector%E5%85%83%E7%B4%A0">擦除/移除std::vector元素</h1>

<p>由于<code>std::vector</code>能自动增长，并且使用方式简单，很受C++开发新手的喜爱。可以通过查阅手册，来了解这个容器该如何使用，比如删除元素。这样使用STL容器，只是了解容器的皮毛，容器应该帮助我们写出更简洁、维护性好和更快的代码。</p>
<p>本节的全部内容都是在一个<code>vector</code>实例中删除元素。当<code>vector</code>中部的一个元素消失了，那么位于消失元素右边的所有元素都要往左移(这种操作的时间复杂度为O(n)。新手们会用循环来做这件事，因为循环的确好用。不过，循环会降低代码的优化空间。最后，比起STL的方法，循环是既不快，也不美，</p>
<h2>How to do it...</h2>
<p>首先，我们使用整数来填充一个<code>std::vector</code>实例，之后剔除一些特定元素。我们演示的从<code>vector</code>实例中删除元素正确的方法。</p>
<ol>
<li>
<p>包含文件是首要任务。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
</pre></li>
<li>
<p>声明我们所要使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们来创建一个<code>vector</code>实例，并用整数填满它。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后移除一些元素。需要我们移除哪些呢？2出现的太多次了，就选择2吧。让我们移除它们吧。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">new_end</span><span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>已经完成了两步中的一步。<code>vector</code>在删除这些元素之后，长度并没有发生变化。那么下一步就让这个<code>vector</code>变得短一些。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>new_end<span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们在这里暂停一下，输出一下当前<code>vector</code>实例中所包含的元素。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，让我们来移除一组指定的数据。为了完成这项工作，我们先定义了一个谓词函数，其可接受一个数作为参数，当这个数是奇数时，返回true。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">odd</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>这里我们使用<code>remove_if</code>函数，使用上面定义的谓词函数，来删除特定的元素。这里我们将上面删除元素的步骤合二为一。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove_if</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> odd<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>所有的奇数都被删除，不过<code>vector</code>实例的容量依旧是10。最后一步中，我们将其容量修改为正确的大小。需要注意的是，这个操作会让<code>vector</code>重新分配一段内存，以匹配相应元素长度，<code>vector</code>中已存的元素会移动到新的内存块中。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	v<span class="token punctuation">.</span><span class="token function">shrink_to_fit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>打印一下现在<code>vector</code>实例中的元素。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译完成后，运行程序，就可以了看到两次删除元素后<code>vector</code>实例中所存在的元素。</p>
<pre data-role="codeBlock" data-info="txt" class="language-txt">$ ./main
1, 3, 5, 6, 4, 8,
6, 4, 8,
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>我们可以清楚的看到，要从一个<code>vector</code>实例中移除一个元素，首先要进行删除，然后进行擦除，这样才算真正的移除。这会让人感到困惑，那就让我们近距离观察一下这些步骤是如何工作的。</p>
<p>从<code>vector</code>中移除2的代码如下所示：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">new_end</span> <span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>new_end<span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p><code>std::begin</code>和<code>std::end</code>函数都以一个<code>vector</code>实例作为参数，并且返回其迭代器，迭代器分别指向第一个元素和最后一个元素，就如下图所示。</p>
<p><img src="./C++17 STL Cook book_files/2-1-1.png" alt=""></p>
<p><code>std::remove</code>在删除2的时候，会先将非2元素进行移动，然后修改end迭代器的指向。该算法将严格保留所有非2个值的顺序。</p>
<p>在2步中，2的值仍然存在，并且<code>vector</code>应该变短。并且4和8在现有的<code>vector</code>中重复了。这是怎么回事？</p>
<p>让我们再来看一下所有的元素，目前<code>vector</code>的范围并不是原来那样了，其是从<code>begin</code>迭代器，到<code>new_end</code>迭代器。<code>new_end</code>之后的值其实就不属于<code>vector</code>实例了。我们会注意到，在这个范围内的数值，就是我们想要的正确结果，也就是所有的2都被移除了。</p>
<p>最后，也就是为什么要调用<code>erase</code>函数：我们需要告诉<code>vector</code>实例，<code>new_end</code>到<code>end</code>之间的元素我们不需要了。我们仅需要保留<code>begin</code>到<code>new_end</code>间的元素就好了。<code>erase</code>函数会将<code>end</code>指向<code>new_end</code>。这里需要注意的是<code>std::remove</code>会直接返回<code>new_end</code>迭代器，所以我们可以直接使用它。</p>
<blockquote>
<p>Note:</p>
<p><code>vector</code>在这里不仅仅移动了内部指针。如果<code>vector</code>中元素比较复杂，那么在移除的时候，会使用其析构函数来销毁相应的对象。</p>
</blockquote>
<p>最后，这个向量就如步骤3所示：的确变短了。那些旧的元素已经不在<code>vector</code>的访问范围内了，不过其仍存储在内存中。</p>
<p>为了不让<code>vector</code>浪费太多的内存，我们在最后调用了<code>shrink_to_fit</code>。该函数会为元素分配足够的空间，将剩余的元素移到该空间内，并且删除之前那个比较大的内存空间。</p>
<p>在上面的第8步中，我们定义了一个谓词函数，并在<code>std::remove_if</code>中使用了它。因为不论删除函数返回怎么样的迭代器，在对<code>vector</code>实例使用擦除函数都是安全的。如果<code>vector</code>中全是偶数，那么<code>std::remove_if</code>不会做任何事情，并且返回<code>end</code>迭代器。之后的调用就为<code>v.erase(end, end);</code>，同样没有做任何事情。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p><code>std::remove</code>函数对其他容器同样有效。当使用<code>std::array</code>时，其不支持<code>erase</code>操作，因为其内存空间固定，无法进行自动化处理。因为<code>std::remove</code>只是将要删除的元素移动到容器末尾，而不是将其真正删除，所以这个函数也可以用于不支持空间大小变化的数据类型。当然也有其他类似的方法，例如字符串中，可以用哨兵值<code>\0</code>来覆盖原始的<code>end</code>迭代所指向的值。</p>
</div></div><div id="ebook-heading-x4ee5o1x7684x65f6x95f4x590dx6742x5ea6x5220x9664x672ax6392x5e8fstdvectorx4e2dx7684x5143x7d20" ebook-toc-level-2="" heading="以O(1)的时间复杂度删除未排序std::vector中的元素"><div><h1 class="mume-header" id="%E4%BB%A5o1%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%A0%E9%99%A4%E6%9C%AA%E6%8E%92%E5%BA%8Fstdvector%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0">以O(1)的时间复杂度删除未排序std::vector中的元素</h1>

<p>因为其他元素要填补删除元素所留下来的空隙，从而需要进行移动，所以从<code>std::vector</code>中删除元素的时间复杂度为O(n)。</p>
<p>移动其他元素也与此类似，当很多很大或很复杂的元素需要移动，那么就会花费很长的时间。当无法保证顺序时，我们需要对其进行优化，这就是本节的内容。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们继续使用一些数字来填充<code>std::vector</code>实例，并且实现一个快速删除函数，以O(1)的时间复杂度删除vector中的元素。</p>
<ol>
<li>
<p>首先，包含必要的头文件：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
</pre></li>
<li>
<p>定义主函数，并定义一个<code>vector</code>实例：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">456</span><span class="token punctuation">,</span> <span class="token number">789</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>下一步就要删除索引为2的元素(789)。我们所要用的来删除元素的函数在后面进行实现，我们先假设已经实现好了。执行完成后，来看下<code>vector</code>中的内容。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">quick_remove_at</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，我们将删除另外一个元素。我们想删除123，但是要假装不知道其索引。因此，我们要使用<code>std::find</code>函数在vector的合法范围内查找这个值，并返回其位置信息。得到索引信息后，我们就可以用<code>quick_remove_at</code>将对应元素删除了，这里所使用到的是一个重载版本，能接受迭代器作为输入参数。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">quick_remove_at</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">find</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们实现了两种<code>quick_remove_at</code>函数。具体实现代码中，需要注意与<code>main</code>函数的前后关系。两个函数都能接收一个<code>vector</code>实例的引用，所以这里允许用户使用各种类型的变量作为元素。对于我们来说，其类型就是<code>T</code>。第一个 <code>quick_remove_at</code>函数用来接收索引值，是一个具体的数，所以其接口如下所示：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">quick_remove_at</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>v<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t idx<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p>现在来展示一下本节的重点——如何在不移动其他元素的情况下，快速删除某个元素？首先，将<code>vector</code>中最后一个元素进行重写。第二，删除<code>vector</code>中最后一个元素。就这两步。我们的代码会对输入进行检查。如果输入的索引值超出了范围，函数不会做任何事情。另外，该函数会在传入空<code>vector</code>的时候崩溃。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        v<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        v<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>另一个<code>quick_remove_at</code>实现也很类似。用<code>std::vector&lt;T&gt;</code>的迭代器替换了具体的索引数值。因为泛型容器已经定义了这样的类型，所以获取它的类型并不复杂。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">quick_remove_at</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>v<span class="token punctuation">,</span>
				    <span class="token keyword keyword-typename">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p>现在我们来访问这些迭代器所指向的值。和另一个函数一样，我们会将最后一个元素进行重写。因为这次处理的是迭代器，所以我们要对迭代器指向的位置进行检查。如果其指向了一个错误的位置，我们就会阻止其解引用。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span><span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</pre></li>
<li>
<p>在该代码块中，我们会做和之前一样的事情——我们要覆盖最后一个位置上的值——然后将最后一个元素从<code>vector</code>中剪掉。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        <span class="token operator">*</span>it <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        v<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>这就完事了。让我们来编译程序，并运行：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="txt" class="language-txt">$ ./main
123, 456, 200, 100,
100, 456, 200,
</pre><h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>quick_remove_at</code>函数移除元素非常快，而且不需要动其他元素。这个函数使用了更加具有创造性的做法：这是一种与实际元素交换的方式，然后将最后一个元素从<code>vector</code>中删除。虽然，最后一个元素与选中的元素没有实际的关联，但是它在这个特别的位置上，而且删除最后一个元素的成本最低！<code>vector</code>的长度在删除完成后，也就减少1，这就是这个函数所要做的。并且无需移动任何元素。看一下下面的图，可能有助于你理解这个函数的原理。</p>
<p><img src="./C++17 STL Cook book_files/2-2-1.png" alt=""></p>
<p>完成这两步的代码如下：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">v<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>迭代器版本实现几乎一模一样：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token operator">*</span>it <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>逻辑上，我们将选定元素与最后一个元素进行交换。不过，在代码中元素并没有进行交换，代码直接使用最后一个值覆盖了选定元素的值。为什么要这样？当我们交换元素时，就需要将选定的元素存储在一个临时变量中，并在最后将这个临时变量中的值放在<code>vector</code>的最后。这个临时变量是多余的，而且要删除的值对于我们来说是没有意义的，所以这里选择了直接覆盖的方式，更加高效的实现了删除。</p>
<p>好了，交换是无意义的，覆盖是一种更好的方式。让我们来看下这个，当我们要获取<code>vector</code>最后元素的迭代器时，只需要简单的执行<code>*it = v.back();</code>就行了，对吧？完全正确，不过试想我们存储了一些非常长的字符串在<code>vector</code>中，或存储了另一个<code>vector</code>或<code>map</code>——这种情况下，简单的赋值将对这些值进行拷贝，那么就会带来非常大的开销。这里使用<code>std::move</code>可将这部分开销优化掉：比如字符串，指向堆内存上存储的一个大字符串。我们无需拷贝它。只需要移动这个字符串即可，就是将目标指针指向这块地址即可。移动源保持不变，不过出于无用的状态，这样做可以类似的让目标指针指向源指针所在的位置，然后将原始位置的元素删除，这样做即完成了元素移动，又免去了移动消耗。</p>
</div></div><div id="ebook-heading-x5febx901fx6216x5b89x5168x7684x8bbfx95eestdvectorx5b9ex4f8bx7684x65b9x6cd5" ebook-toc-level-2="" heading="快速或安全的访问std::vector实例的方法"><div><h1 class="mume-header" id="%E5%BF%AB%E9%80%9F%E6%88%96%E5%AE%89%E5%85%A8%E7%9A%84%E8%AE%BF%E9%97%AEstdvector%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95">快速或安全的访问std::vector实例的方法</h1>

<p><code>std::vector</code>可能是STL容器中适用范围最广的，因为其存储数据的方式和数组一样，并且还有相对完善的配套设施。不过，非法访问一个<code>vector</code>实例还是十分危险的。如果一个<code>vector</code>实例具有100个元素，那当我们想要访问索引为123的元素时，程序就会崩溃掉。如果不崩溃，那么你就麻烦了，未定义的行为会导致一系列奇奇怪怪的错误，查都不好查。经验丰富的开发者会在访问前，对索引进行检查。这样的检查其实比较多余，因为很多人不知道<code>std::vector</code>有内置的检查机制。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节我们将使用两种不同的方式访问一个<code>std::vector</code>实例，并且利用其特性编写更加安全的代码。</p>
<ol>
<li>
<p>先包含相应的头文件，并且用1000个123填满一个vector实例：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> size_t container_size<span class="token punctuation">{</span><span class="token number">1000</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span>container_size<span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们通过<code>[]</code>操作符访问范围之外的元素：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Out of range element value: "</span>
         <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span>container_size <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>之后我们使用<code>at</code>函数访问范围之外的元素：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Out of range element value: "</span>
         <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>container_size <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>让我们运行程序，看下会发生什么。下面的错误信息是由GCC给出。其他编译器也会通过不同方式给出类似的错误提示。第一种方式得到的结果比较奇怪。超出范围的访问方式并没有让程序崩溃，但是访问到了与123相差很大的数字。第二种方式中，我们看不到打印出来的结果，因为在打印之前程序已经崩溃了。当越界访问发生的时候，我们可以通过异常的方式更早的得知！</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">Out of range element value<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">726629391</span>
terminate called after throwing an instance of <span class="token string">'std::out_of_range'</span>
<span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> array<span class="token double-colon punctuation">::</span>at<span class="token operator">:</span> <span class="token function">__n</span> <span class="token punctuation">(</span>which is <span class="token number">1010</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token function">_Nm</span> <span class="token punctuation">(</span>which is <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token function">Aborted</span> <span class="token punctuation">(</span>core dumped<span class="token punctuation">)</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>std::vector</code>提供了<code>[]</code>操作符和<code>at</code>函数，它们的作用几乎是一样的。<code>at</code>函数会检查给定的索引值是否越界，如果越界则返回一个异常。这对于很多情景都十分适用，不过因为检查越界要花费一些时间，所以<code>at</code>函数会让程序慢一些。</p>
<p>当需要非常快的索引成员时，并能保证索引不越界，我们会使用<code>[]</code>快速访问<code>vector</code>实例。很多情况下，<code>at</code>函数在牺牲一点性能的基础上，有助于发现程序内在的bug。</p>
<blockquote>
<p>Note：</p>
<p>默认使用<code>at</code>函数是一个好习惯。当代码的性能很差，但没有bug存在时，可以使用性能更高的操作符来替代<code>at</code>函数。</p>
</blockquote>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>当然，我们需要处理越界访问，避免整个程序崩溃。为了对越界访问进行处理，我们可以使用截获异常的方式。可以用<code>try</code>代码块将调用at函数的部分包围，并且定义错误处理的<code>catch</code>代码段。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Out of range element value: "</span>
        	  <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>container_size <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>out_of_range <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Ooops, out of range access detected: "</span>
              <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><blockquote>
<p>Note:</p>
<p>顺带一提，<code>std::array</code>也提供了<code>at</code>函数。</p>
</blockquote>
</div></div><div id="ebook-heading-x4fddx6301x5bf9stdvectorx5b9ex4f8bx7684x6392x5e8f" ebook-toc-level-2="" heading="保持对std::vector实例的排序"><div><h1 class="mume-header" id="%E4%BF%9D%E6%8C%81%E5%AF%B9stdvector%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%8E%92%E5%BA%8F">保持对std::vector实例的排序</h1>

<p><code>array</code>和<code>vector</code>不会对他们所承载的对象进行排序。有时我们去需要排序，但这不代表着我们总是要去切换数据结构，需要排序能够自动完成。在我们的例子有如有一个<code>std::vector</code>实例，将添加元素后的实例依旧保持排序，会是一项十分有用的功能。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中我们使用随机单词对<code>std::vector</code>进行填充，然后对它进行排序。并在插入更多的单词的同时，保证<code>vector</code>实例中单词的整体排序。</p>
<ol>
<li>
<p>先包含必要的头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span>
</pre></li>
<li>
<p>声明所要使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>完成主函数，使用一些随机单词填充<code>vector</code>实例。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token string">"some"</span><span class="token punctuation">,</span> <span class="token string">"random"</span><span class="token punctuation">,</span> <span class="token string">"words"</span><span class="token punctuation">,</span>
                      <span class="token string">"without"</span><span class="token punctuation">,</span> <span class="token string">"order"</span><span class="token punctuation">,</span> <span class="token string">"aaa"</span><span class="token punctuation">,</span>
                      <span class="token string">"yyy"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>对vector实例进行排序。我们使用一些断言语句和STL中自带的<code>is_sorted</code>函数对是否排序进行检查。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span> <span class="token operator">==</span> <span class="token function">is_sorted</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">==</span> <span class="token function">is_sorted</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>这里我们使用<code>insert_sorted</code>函数添加随机单词到已排序的<code>vector</code>中，这个函数我们会在后面实现。这些新插入的单词应该在正确的位置上，并且<code>vector</code>实例需要保持已排序的状态。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">insert_sorted</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token string">"foobar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insert_sorted</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token string">"zzz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，我们来实现<code>insert_sorted</code>函数。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">insert_sorted</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>v<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>word<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">insert_pos</span> <span class="token punctuation">(</span><span class="token function">lower_bound</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>insert_pos<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>回到主函数中，我们将<code>vector</code>实例中的元素进行打印。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>w <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> w <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>	
</pre></li>
<li>
<p>编译并运行后，我们得到如下已排序的输出。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">aaa foobar order random some without words yyy zzz
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>程序整个过程都是围绕<code>insert_sorted</code>展开，这也就是本节所要说明的：对于任意的新字符串，通过计算其所在位置，然后进行插入，从而保证<code>vector</code>整体的排序性。不过，这里我们假设的情况是，在插入之前，<code>vector</code>已经排序。否则，这种方法无法工作。</p>
<p>这里我们使用STL中的<code>lower_bound</code>对新单词进行定位，其可接收三个参数。头两个参数是容器开始和结尾的迭代器。这确定了我们单词<code>vector</code>的范围。第三个参数是一个单词，也就是要被插入的那个。函数将会找到大于或等于第三个参数的首个位置，然后返回指向这个位置的迭代器。</p>
<p>获取了正确的位置，那就使用<code>vector</code>的成员函数<code>insert</code>将对应的单词插入到正确的位置上。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p><code>insert_sorted</code>函数很通用。如果需要其适应不同类型的参数，这样改函数就能处理其他容器所承载的类型，甚至是容器的类似，比如<code>std::set</code>、<code>std::deque</code>、<code>std::list</code>等等。(这里需要注意的是成员函数<code>lower_bound</code>与 <code>std::lower_bound</code>等价，不过成员函数的方式会更加高效，因为其只用于对应的数据集合)</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">C</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">insert_sorted</span><span class="token punctuation">(</span>C <span class="token operator">&amp;</span>v<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> T <span class="token operator">&amp;</span>item<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">insert_pos</span> <span class="token punctuation">(</span><span class="token function">lower_bound</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>insert_pos<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>当我们要将<code>std::vector</code>类型转换为其他类型时，需要注意的是并不是所有容器都支持<code>std::sort</code>。该函数所对应的算法需要容器为可随机访问容器，例如<code>std::list</code>就无法进行排序。</p>
</div></div><div id="ebook-heading-x5411stdmapx5b9ex4f8bx4e2dx9ad8x6548x5e76x6709x6761x4ef6x7684x63d2x5165x5143x7d20" ebook-toc-level-2="" heading="向std::map实例中高效并有条件的插入元素"><div><h1 class="mume-header" id="%E5%90%91stdmap%E5%AE%9E%E4%BE%8B%E4%B8%AD%E9%AB%98%E6%95%88%E5%B9%B6%E6%9C%89%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0">向std::map实例中高效并有条件的插入元素</h1>

<p>我们需要用键值对填充一个<code>map</code>实例时，会碰到两种不同的情况：</p>
<ol>
<li>键不存在。创建一个全新的键值对。</li>
<li>键已存在。修改键所对应的值。</li>
</ol>
<p>我通常会使用<code>insert</code>或<code>emplace</code>函数对<code>map</code>插入新元素，如果插入不成功，那么就是第二种情况，就需要去修改现有的元素。<code>insert</code>和<code>emplace</code>都会创建一个新元素尝试插入到<code>map</code>实例中，不过在第二种情况下，这个新生成的元素会被扔掉。两种情况下，我们都会多余调用一次构造函数。</p>
<p>C++17中，添加了<code>try_emplace</code>函数，其只有在满足条件的情况下，才能插入新元素。让我们实现一个程序，建立一张表，列出各国亿万富翁的数量。我们例子中不会使用很大开销进行元素创建，不过我们的例子来源于生活，其能让你明白如何使用<code>try_emplace</code>。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将实现一个应用，其能创建一张百万富翁的列表。这个列表中按国家区分，里面记录了各国富人的数量。</p>
<ol>
<li>
<p>包含头文件和声明命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>定义一个结构器，代表对应的富翁。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">billionaire</span> <span class="token punctuation">{</span>
    string name<span class="token punctuation">;</span>
    <span class="token keyword keyword-double">double</span> dollars<span class="token punctuation">;</span>
    string country<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>主函数中，我们定义了一个百万富翁的列表。世界上有很多百万富翁，所以我们创建一个有限列表来存储这些富翁的信息。这个列表是已排序的。2017年福布斯富豪名单，世界百万富翁排行榜可以在  <a href="https://www.forbes.com/billionaires/list">https://www.forbes.com/billionaires/list</a> 查到。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    list<span class="token operator">&lt;</span>billionaire<span class="token operator">&gt;</span> billionaires <span class="token punctuation">{</span>
        <span class="token punctuation">{</span><span class="token string">"Bill Gates"</span><span class="token punctuation">,</span> <span class="token number">86.0</span><span class="token punctuation">,</span> <span class="token string">"USA"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"Warren Buffet"</span><span class="token punctuation">,</span> <span class="token number">75.6</span><span class="token punctuation">,</span> <span class="token string">"USA"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"Jeff Bezos"</span><span class="token punctuation">,</span> <span class="token number">72.8</span><span class="token punctuation">,</span> <span class="token string">"USA"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"Amancio Ortega"</span><span class="token punctuation">,</span> <span class="token number">71.3</span><span class="token punctuation">,</span> <span class="token string">"Spain"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"Mark Zuckerberg"</span><span class="token punctuation">,</span> <span class="token number">56.0</span><span class="token punctuation">,</span> <span class="token string">"USA"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"Carlos Slim"</span><span class="token punctuation">,</span> <span class="token number">54.5</span><span class="token punctuation">,</span> <span class="token string">"Mexico"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">// ...</span>
        <span class="token punctuation">{</span><span class="token string">"Bernard Arnault"</span><span class="token punctuation">,</span> <span class="token number">41.5</span><span class="token punctuation">,</span> <span class="token string">"France"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">// ...</span>
        <span class="token punctuation">{</span><span class="token string">"Liliane Bettencourt"</span><span class="token punctuation">,</span> <span class="token number">39.5</span><span class="token punctuation">,</span> <span class="token string">"France"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">// ...</span>
        <span class="token punctuation">{</span><span class="token string">"Wang Jianlin"</span><span class="token punctuation">,</span> <span class="token number">31.3</span><span class="token punctuation">,</span> <span class="token string">"China"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"Li Ka-shing"</span><span class="token punctuation">,</span> <span class="token number">31.2</span><span class="token punctuation">,</span> <span class="token string">"Hong Kong"</span><span class="token punctuation">}</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在让我们定义一个表。这个表由表示国家名的字符串和一个组对构成。组对中会具有上面列表的一个(const)副本。这也就是每个国家最富有的人。组对中另一个变量是一个计数器，其会统计某国的富豪人数。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> pair<span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> billionaire<span class="token punctuation">,</span> size_t<span class="token operator">&gt;&gt;</span> m<span class="token punctuation">;</span>	
</pre></li>
<li>
<p>现在，让我们将列表中的数据尝试插入到组对中。每个组对中都包含了对应国家的百万富翁，并将计数器的值置成1。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>b <span class="token operator">:</span> billionaires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword keyword-auto">auto</span> <span class="token punctuation">[</span>iterator<span class="token punctuation">,</span> success<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">try_emplace</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>country<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>如果这一步成功，那就不用再做其他事了。我们使用b和1创建的组对已经插入到表中。如果因为键已存在而插入失败，那么组对就不会构建。当我们百万富翁结构体非常大时，我们需要将运行时拷贝的时间节省下来。不过，在不成功的情况下，我们还是要对计数器进行增加1的操作。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        iterator<span class="token operator">-&gt;</span>second<span class="token punctuation">.</span>second <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在，我们来打印一下每个国家百万富翁的数量，以及各个国家中最富有的人。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>b<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>country <span class="token operator">&lt;&lt;</span> <span class="token string">" : "</span> <span class="token operator">&lt;&lt;</span> count
       	     <span class="token operator">&lt;&lt;</span> <span class="token string">" billionaires. Richest is "</span>
             <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">" with "</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>dollars
             <span class="token operator">&lt;&lt;</span> <span class="token string">" B$\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就会得到下面的输出(这里的输出是不完整的，因为列表比较长)。</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>$ ./efficient_insert_or_modify
China : 1 billionaires. Richest is Wang Jianlin with 31.3 B$
France : 2 billionaires. Richest is Bernard Arnault with 41.5 B$
Hong Kong : 1 billionaires. Richest is Li Ka-shing with 31.2 B$
Mexico : 1 billionaires. Richest is Carlos Slim with 54.5 B$
Spain : 1 billionaires. Richest is Amancio Ortega with 71.3 B$
USA : 4 billionaires. Richest is Bill Gates with 86 B$
</code></pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节围绕着<code>std::map</code>中的<code>try_emplace</code>函数展开，这个函数是C++17添加的。下面是其函数声明之一：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span> <span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> <span class="token function">try_emplace</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> key_type<span class="token operator">&amp;</span> k<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>其函数第一个参数<code>k</code>是插入的键，<code>args</code>表示这个键对应的值。如果我们成功的插入了元素，那么函数就会返回一个迭代器，其指向新节点在表中的位置，组对中布尔变量的值被置为true。当插入不成功，组对中的布尔变量值会置为false，并且迭代器指向与新元素冲突的位置。</p>
<p>这个特性在我们的例子中非常有用——可以完美处理第一次访问到，和之后访问到的情况。</p>
<blockquote>
<p>Note：</p>
<p><code>std::map</code>中<code>insert</code>和<code>emplace</code>方法完全相同。<code>try_emplace</code>与它们不同的地方在于，在遇到已经存在的键时，不会去构造组对。当相应对象的类型需要很大开销进行构造时，这对于程序性能是帮助的。</p>
</blockquote>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>如果我们将表的类型从<code>std::map</code>换成<code>std::unordered_map</code>，程序照样能工作。这样的话，当不同类型的表具有较好的性能特性时，我们就可以快速的进行切换。例子中，唯一可观察到的区别是，亿万富翁表不再按字母顺序打印，因为哈希表和搜索树不同，其不会对对象进行排序。</p>
</div></div><div id="ebook-heading-x4e86x89e3stdmapinsertx65b0x7684x63d2x5165x63d0x793ax8bedx4e49" ebook-toc-level-2="" heading="了解std::map::insert新的插入提示语义"><div><h1 class="mume-header" id="%E4%BA%86%E8%A7%A3stdmapinsert%E6%96%B0%E7%9A%84%E6%8F%92%E5%85%A5%E6%8F%90%E7%A4%BA%E8%AF%AD%E4%B9%89">了解std::map::insert新的插入提示语义</h1>

<p><code>std::map</code>中查找元素的时间复杂度为O<span style="color: #ee7f49; font-weight: 500;">ParseError: KaTeX parse error: Can't use function '\(' in math mode at position 4: log\̲(̲n</span>)，与插入元素的时间复杂相同，因为要在对应位置上插入元素，那么就先要找到这个位置。通常，插入M个新元素的时间复杂度为O<span style="color: #ee7f49; font-weight: 500;">ParseError: KaTeX parse error: Undefined control sequence: \* at position 2: M\̲*̲log\(n</span>)。</p>
<p>为了让插入更加高效，<code>std::map</code>插入函数接受一个迭代器参数<code>hint</code>。自C++11起，该参数为指向将插入新元素到其前的位置的迭代器。如果这个迭代器给定正确，那么插入的时间复杂度就为O<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节会是用传入迭代器的方式向<code>std::map</code>实例中插入多个新元素，从而减少耗时：</p>
<ol>
<li>
<p>包含必要的头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
</pre></li>
<li>
<p>创建一个<code>map</code>实例，并填充一些内容。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> m <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"d"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将插入多个元素，对于每次插入，我们都会传入一个hint迭代器。第一次插入我们不指定其开始位置，只将插入位置指向<code>map</code>的<code>end</code>迭代器之前。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">insert_it</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">end</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将以字母表的反序进行元素的插入，然后使用hint迭代器，然后使用<code>insert</code>函数的返回值重新初始化迭代器的值。下一个元素将在<code>hint</code>迭代器前插入。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>s <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token string">"z"</span><span class="token punctuation">,</span> <span class="token string">"y"</span><span class="token punctuation">,</span> <span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        insert_it <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>insert_it<span class="token punctuation">,</span> <span class="token punctuation">{</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>为了展示在什么情况下<code>insert</code>函数不工作，我们将要插入最左侧位置的元素插入到最右侧。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">end</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>最后我们打印当前的<code>map</code>。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\""</span> <span class="token operator">&lt;&lt;</span> key <span class="token operator">&lt;&lt;</span> <span class="token string">"\": "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行程序，错误的插入并没有对结果又什么影响，<code>map</code>实例中对象的顺序仍然是对的。</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>"a": 1, "b": 1, "c": 2, "d": 3, "w": 1, "x": 1, "y": 1, "z": 1,
</code></pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本例与常用的方式不同，多了一个迭代器。并且我们提到了这个迭代器的正确与否。</p>
<p>正确的迭代器将会指向一个已存在的元素，其值要比要插入元素的键大，所以新元素会插在这个迭代器之前。如果用户提供的迭代器位置有误，那么插入函数会退化成未优化的版本，其时间复杂度恢复O<span style="color: #ee7f49; font-weight: 500;">ParseError: KaTeX parse error: Can't use function '\(' in math mode at position 4: log\̲(̲n</span>)。</p>
<p>对于第一次插入，我们选择了<code>map</code>实例的<code>end</code>迭代器，因为没有其他更好的选择。在插入“z”之后，函数会返回相应的迭代器，这样我们就知道了要插入“y”的位置。“x”也同理，后面的元素依次类推。</p>
<blockquote>
<p>Note:</p>
<p>在C++11之前，hint迭代器只是建议作为搜索开始位置的迭代器。</p>
</blockquote>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>其中，比较有趣的事情是，在给定错误的迭代器，<code>map</code>实例依旧能保持其排序。那么他是如何工作的呢？还有插入的时间复杂度为O<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>意味着什么？</p>
<p><code>std::map</code>通常使用二叉搜索树实现。当在搜索树中插入一个新键时，该键要和其他键进行比较，从末端到顶端。如果键小于或大于其他节点的键，搜索树的左侧或右侧分支则会成为更深的节点。不过，搜索算法会阻止节点达到当前搜索树的底端。否则会打破搜索树的平衡，所以为了保证正确性，需要使用一个平衡算法用来管理节点。</p>
<p>当我们将元素插入到树中时，这些键值就会成为邻居<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>就如整数</mtext><mn>1</mn><mtext>和</mtext><mn>2</mn><mtext>互邻一样</mtext></mrow><annotation encoding="application/x-tex">就如整数1和2互邻一样</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">就如整数</span><span class="mord">1</span><span class="mord cjk_fallback">和</span><span class="mord">2</span><span class="mord cjk_fallback">互邻一样</span></span></span></span>。如果有<code>hint</code>传入，那么很容易检查键是否正确。如果这种情况出现，则可以省去搜索的时间。而后，平衡算法会可能还要运行。虽然优化并不是总能成功，不过平均下来，性能上还是会有提升。可以使用多次插入的方式，来统计运行的耗时，这被称之为<a href="http://programming.guide/amortized-time-complexity-analysis.html"><strong>摊销复杂度</strong></a>。</p>
<p><img src="./C++17 STL Cook book_files/2-6-1.png" alt=""></p>
<p>如果插入的<code>hint</code>是错的，那么插入函数会放弃使用<code>hint</code>，转而使用搜索算法进行查找。虽然程序不会出什么问题，但这样做会让程序变慢。</p>
</div></div><div id="ebook-heading-x9ad8x6548x7684x4feex6539stdmapx5143x7d20x7684x952ex503c" ebook-toc-level-2="" heading="高效的修改std::map元素的键值"><div><h1 class="mume-header" id="%E9%AB%98%E6%95%88%E7%9A%84%E4%BF%AE%E6%94%B9stdmap%E5%85%83%E7%B4%A0%E7%9A%84%E9%94%AE%E5%80%BC">高效的修改std::map元素的键值</h1>

<p>在<code>std::map</code>数据结构中，键-值通常都对应存在，而且键通常是唯一并排序过的，而且键值一旦设定那么就不允许用户再进行修改。为了阻止用户修改键，键的类型声明使用了<code>const</code>。</p>
<p>这种限制是非常明智的，其可以保证用户很难在使用<code>std::map</code>的时候出错。不过，如果我们真的需要修改<code>map</code>的键值该怎么办呢？</p>
<p>C++17之前，因为对应的键已经存在，我们不得不将整个键-值对从树中移除，然后再插入。这种方法的确定很明显，其需要分配出一些不必要的内存，感觉上也会对性能有一定的影响。</p>
<p>从C++17起，我们无需重新分配内存，就可以删除和重新插入map键值对。下面的内容中将会展示如何操作。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们使用<code>std::map</code>类型一个实现应用，用于确定车手在虚拟比赛中的排位。当车手在比赛中完成超越，那么我们将使用C++17的新方法改变其键值。</p>
<ol>
<li>
<p>包含必要的头文件和声明使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们会在修改map的时候打印之前和之后结果，所以这里先实现了一个辅助函数。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">M</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> M <span class="token operator">&amp;</span>m<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Race placement:\n"</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>placement<span class="token punctuation">,</span> driver<span class="token punctuation">]</span> <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   		cout <span class="token operator">&lt;&lt;</span> placement <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> driver <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们实例化并初始化一个<code>map</code>，其键为整型，表示是当前的排位；值为字符型，表示驾驶员的姓名。我们在这里先打印一下这个<code>map</code>，因为我们会在下一步对其进行修改。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    map<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span> race_placement <span class="token punctuation">{</span>
        <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Mario"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Luigi"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Bowser"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"Peach"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"Yoshi"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">"Koopa"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">"Toad"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">"Donkey Kong Jr."</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>race_placement<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>让我来看下排位赛的某一圈的情况，Bowser因为赛车事故排在最后，Donkey Kong Jr. 从最后一名超到第三位。例子中首先要从<code>map</code>中提取节点，因为这是唯一能修改键值的方法。<code>extract</code>函数是C++17新加的特性。其可以从<code>map</code>中删除元素，并没有内存重分配的副作用。看下这里是怎么用的吧。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">a</span><span class="token punctuation">(</span>race_placement<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">b</span><span class="token punctuation">(</span>race_placement<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>现在我们要交换Bowser和Donkey Kong Jr.的键。键通常都是无法修改的，不过我们可以通过<code>extract</code>方法来修改元素的键。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>std::map</code>的<code>insert</code>函数在C++17中有一个新的重载版本，其接受已经提取出来的节点，就是为了在插入他们时，不会分配不必要的内存。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    race_placement<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    race_placement<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>最后，我们打印一下目前的排位。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">print</span><span class="token punctuation">(</span>race_placement<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行可以得到如下输出。我们可以看到初始的排位和最后的排位。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>mapnode_key_modification
Race placement<span class="token operator">:</span>
<span class="token number">1</span><span class="token operator">:</span> Mario
<span class="token number">2</span><span class="token operator">:</span> Luigi
<span class="token number">3</span><span class="token operator">:</span> Bowser
<span class="token number">4</span><span class="token operator">:</span> Peach
<span class="token number">5</span><span class="token operator">:</span> Yoshi
<span class="token number">6</span><span class="token operator">:</span> Koopa
<span class="token number">7</span><span class="token operator">:</span> Toad
<span class="token number">8</span><span class="token operator">:</span> Donkey Kong Jr<span class="token punctuation">.</span>
Race placement<span class="token operator">:</span>
<span class="token number">1</span><span class="token operator">:</span> Mario
<span class="token number">2</span><span class="token operator">:</span> Luigi
<span class="token number">3</span><span class="token operator">:</span> Donkey Kong Jr<span class="token punctuation">.</span>
<span class="token number">4</span><span class="token operator">:</span> Peach
<span class="token number">5</span><span class="token operator">:</span> Yoshi
<span class="token number">6</span><span class="token operator">:</span> Koopa
<span class="token number">7</span><span class="token operator">:</span> Toad
<span class="token number">8</span><span class="token operator">:</span> Bowser
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>在C++17中，<code>std::map</code>有一个新成员函数<code>extract</code>。其有两种形式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">node_type <span class="token function">extract</span><span class="token punctuation">(</span>const_iterator position<span class="token punctuation">)</span><span class="token punctuation">;</span>
node_type <span class="token function">extract</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> key_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
</pre><p>在例子中，我们使用了第二个，能接受一个键值，然后找到这个键值，并提取对应的<code>map</code>节点。第一个函数接受一个迭代器，提取的速度会更快，应为给定了迭代器就不需要在查找。</p>
<p>当使用第二种方式去提取一个不存在的节点时，会返回一个空<code>node_type</code>实例。<code>empty()</code>成员函数会返回一个布尔值，用来表明<code>node_type</code>实例是否为空。以任何方式访问一个空的实例都会产生未定义行为。</p>
<p>提取节点之后，我们要使用<code>key()</code>函数获取要修改的键，这个函数会返回一个非常量的键。</p>
<p>需要注意的是，要将节点重新插会到<code>map</code>时，我们需要在<code>insert</code>中移动他们。因为<code>extract</code>可避免不必要的拷贝和内存分配。还有一点就是，移动一个<code>node_type</code>时，其不会让容器的任何值发生移动。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>使用<code>extract</code>方法提取的<code>map</code>节点实际上非常通用。我们可以从一个<code>map</code>实例中提取出来节点，然后插入到另一个<code>map</code>中，甚至可以插入到<code>multimap</code>实例中。这种方式在<code>unordered_map</code>和<code>unordered_multimap</code>实例中也适用。同样在<code>set/multiset</code>和<code>unordered_set/unordered_multiset</code>也适用。</p>
<p>为了在不同<code>map</code>或<code>set</code>结构中移动元素，键、值和分配器的类型都必须相同。需要注意的是，不能将<code>map</code>中的节点移动到<code>unordered_map</code>中，或是将<code>set</code>中的元素移动到<code>unordered_set</code>中。</p>
</div></div><div id="ebook-heading-stdunordered_mapx4e2dx4f7fx7528x81eax5b9ax4e49x7c7bx578b" ebook-toc-level-2="" heading="std::unordered_map中使用自定义类型"><div><h1 class="mume-header" id="stdunordered_map%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">std::unordered_map中使用自定义类型</h1>

<p>当我们使用<code>std::unordered_map</code>代替<code>std::map</code>时，对于键的选择要从另一个角度出发。<code>std::map</code>要求键的类型可以排序。因此，元素可以进行排序。不过，当我们使用数学中的向量作为键呢？这样一来就没有判断哪个向量大于另一个向量，比如向量(0, 1)和(1, 0)无法相比较，因为它们指向的方向不同。在<code>std::unordered_map</code>中这都不是问题，因为不需要对键的哈希值进行排序。对于我们来说只要为类型实现一个哈希函数和等同<code>==</code>操作符的实现，等同操作符的是实现是为了判断两个对象是否完全相同。本节中，我们就来实验一下这个例子。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们要定义一个简单的<code>coord</code>数据结构，其没有默认哈希函数，所以我们必须要自行定义一个。然后我们会使用<code>coord</code>对象来对应一些值。</p>
<ol>
<li>
<p>包含使用<code>std::unordered_map</code>所必须的头文件</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map&gt;</span> </span>
</pre></li>
<li>
<p>自定义数据结构，这是一个简单的数据结构，还不具备对应的哈希函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">coord</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-int">int</span> x<span class="token punctuation">;</span>
	<span class="token keyword keyword-int">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>实现哈希函数是为了能让类型作为键存在，这里先实现比较操作函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-bool">bool</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> coord <span class="token operator">&amp;</span>l<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> coord <span class="token operator">&amp;</span>r<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> l<span class="token punctuation">.</span>x <span class="token operator">==</span> r<span class="token punctuation">.</span>x <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">.</span>y <span class="token operator">==</span> r<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>为了使用STL哈希的能力，我们打开了std命名空间，并且创建了一个特化的<code>std::hash</code>模板。其使用<code>using</code>将特化类型进行别名。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-namespace">namespace</span> std
<span class="token punctuation">{</span>
<span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">hash</span><span class="token operator">&lt;</span>coord<span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-using">using</span> argument_type <span class="token operator">=</span> coord<span class="token punctuation">;</span>
    <span class="token keyword keyword-using">using</span> result_type <span class="token operator">=</span> size_t<span class="token punctuation">;</span>
</pre></li>
<li>
<p>下面要重载该类型的括号表达式。我们只是为<code>coord</code>结构体添加数字，这是一个不太理想的哈希方式，不过这里只是展示如何去实现这个函数。一个好的散列函数会尽可能的将值均匀的分布在整个取值范围内，以减少哈希碰撞。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    result_type <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> argument_type <span class="token operator">&amp;</span>c<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>result_type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
       		   <span class="token operator">+</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>result_type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们现在可以创建一个新的<code>std::unordered_map</code>实例，其能结构<code>coord</code>结构体作为键，并且对应任意值。例子中对<code>std::unordered_map</code>使用自定义的类型来说，已经很不错了。让我们基于哈希进行实例化，并填充自定义类型的<code>map</code>表，并打印这个<code>map</code>表：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>coord<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> m <span class="token punctuation">{</span> 
        <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
        <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"{("</span> <span class="token operator">&lt;&lt;</span> key<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> key<span class="token punctuation">.</span>y
    			 <span class="token operator">&lt;&lt;</span> <span class="token string">"): "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">"} "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行这个例子，就能看到如下的打印信息：</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>$ ./custom_type_unordered_map
{(2, 1): 3} {(0, 1): 2} {(0, 0): 1}
</code></pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>通常实例化一个基于哈希的map表(比如: <code>std::unordered_map</code>)时，我们会这样写：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>key_type<span class="token punctuation">,</span> value_type<span class="token operator">&gt;</span> my_unordered_map<span class="token punctuation">;</span>
</pre><p>编译器为我们创建特化的<code>std::unordered_map</code>时，这句话背后隐藏了大量的操作。所以，让我们来看一下其完整的模板类型声明：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span>
    <span class="token keyword keyword-class">class</span> <span class="token class-name">Key</span><span class="token punctuation">,</span>
    <span class="token keyword keyword-class">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    <span class="token keyword keyword-class">class</span> <span class="token class-name">Hash</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>hash<span class="token operator">&lt;</span>Key<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token keyword keyword-class">class</span> <span class="token class-name">KeyEqual</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>equal_to<span class="token operator">&lt;</span>Key<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token keyword keyword-class">class</span> <span class="token class-name">Allocator</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> Key<span class="token punctuation">,</span> T<span class="token operator">&gt;</span> <span class="token operator">&gt;</span>
<span class="token operator">&gt;</span> <span class="token keyword keyword-class">class</span> <span class="token class-name">unordered_map</span><span class="token punctuation">;</span>
</pre><p>这里第一个和第二个模板类型，我么填写的是<code>coord</code>和<code>int</code>。另外的三个模板类型是选填的，其会使用已有的标准模板类。这里前两个参数需要我们给定对应的类型。</p>
<p>对于这个例子，<code>class Hash</code>模板参数是最有趣的一个：当我们不显式定义任何东西时，其就指向<code>std::hash&lt;key_type&gt;</code>。STL已经具有<code>std::hash</code>的多种特化类型，比如<code>std::hash&lt;std::string&gt;</code>、<code>std::hash&lt;int&gt;</code>、<code>std::hash&lt;unique_ptr&gt;</code>等等。这些类型中可以选择最优的一种类型类解决对应的问题。</p>
<p>不过，STL不知道如何计算我们自定义类型<code>coord</code>的哈希值。所以我们要使用我们定义的类型对哈希模板进行特化。编译器会从<code>std::hash</code>特化列表中，找到我们所实现的类型，也就是将自定义类型作为键的类型。</p>
<p>如果新特化一个<code>std::hash&lt;coord&gt;</code>类型，并且将其命名成my_hash_type，我们可以使用下面的语句来实例化这个类型：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>coord<span class="token punctuation">,</span> value_type<span class="token punctuation">,</span> my_hash_type<span class="token operator">&gt;</span> my_unordered_map<span class="token punctuation">;</span>
</pre><p>这样命名就很直观，可读性好，而且编译器也能从哈希实现列表中找到与之对应的正确的类型。</p>
</div></div><div id="ebook-heading-x8fc7x6ee4x7528x6237x7684x91cdx590dx8f93x5165xff0cx5e76x4ee5x5b57x6bcdx5e8fx5c06x91cdx590dx4fe1x606fx6253x5370x51fax2014x2014stdset" ebook-toc-level-2="" heading="过滤用户的重复输入，并以字母序将重复信息打印出——std::set"><div><h1 class="mume-header" id="%E8%BF%87%E6%BB%A4%E7%94%A8%E6%88%B7%E7%9A%84%E9%87%8D%E5%A4%8D%E8%BE%93%E5%85%A5%E5%B9%B6%E4%BB%A5%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%B0%86%E9%87%8D%E5%A4%8D%E4%BF%A1%E6%81%AF%E6%89%93%E5%8D%B0%E5%87%BAstdset">过滤用户的重复输入，并以字母序将重复信息打印出——std::set</h1>

<p><code>std::set</code>是一个奇怪的容器：工作原理和<code>std::map</code>很像，不过<code>std::set</code>将键作为值，没有键值对。所以没做办法与其他类型的数据进行映射。表面上看，<code>std::set</code>因为没有太多的例子，导致很多开发者几乎不知道有这样的容器。想要使用类似<code>std::set</code>的功能时，只有自己去实现一遍。</p>
<p>本节展示如何使用<code>std::set</code>收集很多不同的元素，过滤这些元素，最后只输出一个元素。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>从标准输入流中读取单词，所有不重复的单词将放到一个<code>std::set</code>实例中。之后，枚举出所有输入流中不重复的单词。</p>
<ol>
<li>
<p>包含必要的头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;set&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
</pre></li>
<li>
<p>为了分析我们的输入，会使用到<code>std</code>命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在来实现主函数，先来实例化一个<code>std::set</code>。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> s<span class="token punctuation">;</span>
</pre></li>
<li>
<p>下一件事情就是获取用户的输入。我们只从标准输入中读取，这样我们就要用到<code>istream_iterator</code>。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> it <span class="token punctuation">{</span>cin<span class="token punctuation">}</span><span class="token punctuation">;</span>
    istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> end<span class="token punctuation">;</span>
</pre></li>
<li>
<p>这样就得到了一对<code>begin</code>和<code>end</code>迭代器，可以用来表示用户的输入，我们可以使用<code>std::inserter</code>来填满<code>set</code>实例。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">copy</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> end<span class="token punctuation">,</span> <span class="token function">inserter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>这样就完成了填充。为了看到从标准输入获得的不重复单词，我们可以打印当前的<code>set</code>实例。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> word <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>最后，让我们编译并运行这个程序。从之前的输入中，重复的单词都会去除，获得不重复的单词，然后以字母序排序输出。</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>$ echo "a a a b c foo bar foobar foo bar bar" | ./program
a, b, bar, c, foo, foobar,
</code></pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>程序中有两个有趣的部分。第一个是使用了<code>std::istream_iterator</code>来访问用户输入，另一个是将<code>std::set</code>实例使用<code>std::inserter</code>用包装后，在使用<code>std::copy</code>填充。这看起来像是变魔术一样，只需要一行代码，我们就能完成使用输入流填充实例，去除重复的单词和以字母序进行排序。</p>
<p><strong>std::istream_iterator</strong></p>
<p>这个例子的有趣之处在于一次性可以处理流中大量相同类型的数据：我们对整个输入进行逐字的分析，并以<code>std::string</code>实例的方式插入<code>set</code>。</p>
<p><code>std::istream_iterator</code>只传入了一个模板参数。也就我们输入数据的类型。我们选择<code>std::string</code>是因为我们假设是文本输入，不过这里也可以是<code>float</code>型的输入。基本上任何类型都可以使用<code>cin &gt;&gt; var;</code>完成。构造函数接受一个<code>istream</code>实例。标准输入使用全局输入流<code>std::cin</code>表示，例子中其为<code>istream</code>的参数。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> it <span class="token punctuation">{</span>cin<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>输入流迭代器<code>it</code>就已经实例化完毕了，其可以做两件事情：当对其解引用(<code>*it</code>)时，会得到当前输入的符号。我们通过输入迭代器构造<code>std::string</code>实例，每个字符串容器中都包含一个单词；当进行自加<code>++it</code>时，其会跳转到下一个单词，然后再解引用访问下一个单词。</p>
<p>不过，每次自加后的解引用时都须谨慎。当标准输入为空，迭代器就不能再解引用。另外，我们需要终止使用解引用获取单词的循环。终止的条件就是通过和<code>end</code>迭代器进行比较，知道何时迭代器无法解引用。如果<code>it==end</code>成立，那么说明输入流已经读取完毕。</p>
<p>我们在创建<code>it</code>的同时，也创建了一个<code>std::istream_iterator</code>的<code>end</code>迭代器。其目的是于<code>it</code>进行比较，在每次迭代中作为中止条件。</p>
<p>当<code>std::cin</code>结束时，<code>it</code>迭代器将会与<code>end</code>进行比较，并返回true。</p>
<p><strong>std::inserter</strong></p>
<p>调用<code>std::copy</code>时，我们使用<code>it</code>和<code>end</code>作为输入迭代器。第三个参数必须是一个输出迭代器。因此，不能使用<code>s.begin()</code>或<code>s.end()</code>。一个空的<code>set</code>中，这二者是一致的，所以不能对<code>set</code>的迭代器进行解引用(无论是读取或赋值)。</p>
<p>这就使<code>std::inserter</code>有了用武之地。其为一个函数，返回一个<code>std::insert_iterator</code>，返回值的行为类似一个迭代器，不过会完成普通迭代器无法完成的事。当对其使用加法时，其不会做任何事。当我们对其解引用，并赋值给它时，它会连接相关容器，并且将赋值作为一个新元素插入容器中。</p>
<p>当通过<code>std::inserter</code>实例化<code>std::insert_iterator</code>时，我们需要两个参数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> insert_it <span class="token operator">=</span> <span class="token function">inserter</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>其中s是我们的<code>set</code>，<code>s.end()</code>是指向新元素插入点的迭代器。对于一个空<code>set</code>来说，从哪里开始和从哪里结束一样重要。当使用其他数据结构时，比如<code>vector</code>和<code>list</code>，第二个参数对于定义插入新项的位置来说至关重要。</p>
<p><strong>将二者结合</strong></p>
<p>最后，所有的工作都在<code>std::copy</code>的调用中完成：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token function">copy</span><span class="token punctuation">(</span>input_iterator_begin<span class="token punctuation">,</span> input_iterator_end<span class="token punctuation">,</span> insert_iterator<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>这个调用从<code>std::cin</code>中获取输入迭代器，并将其推入<code>std::set</code>中。之后，其会让迭代器自增，并且确定输入迭代器是否达到末尾。如果不是，那么可以继续从标准输入中获取单词。</p>
<p>重复的单词会自动去除。当<code>set</code>已经拥有了一个单词，再重复将这个单词添加入<code>set</code>时，不会产生任何效果。与<code>std::multiset</code>的表现不同，<code>std::multiset</code>会接受重复项。</p>
</div></div><div id="ebook-heading-x5b9ex73b0x7b80x5355x7684x9006x6ce2x5170x8868x793ax6cd5x8ba1x7b97x5668x2014x2014stdstack" ebook-toc-level-2="" heading="实现简单的逆波兰表示法计算器——std::stack"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95%E8%AE%A1%E7%AE%97%E5%99%A8stdstack">实现简单的逆波兰表示法计算器——std::stack</h1>

<p><code>std::stack</code>是一个适配类，其能让用户使用自己定义的类型作为栈中的元素。本节中，我们会使用<code>std::stack</code>构造一个逆波兰(RPN，reverse polish notation)计算器，为了展示如何使用<code>std::stack</code>。</p>
<p>RPN是一种记号法，可以用一种非常简单的解析方式来表达数学表达式。在RPN中，<code>1+2</code>解析为<code>1 2 +</code>。操作数优先，然后是操作符。另一个例子：<code>(1+2)*3</code>表示为<code>1 2 + 3 *</code>。这两个例子已经展示了RPN可以很容易的进行解析，并且不需要小括号来定义子表达式。</p>
<p><img src="./C++17 STL Cook book_files/2-10-1.png" alt=""></p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将从标准输入中读取一个RPN表达式，然后根据表达式解析出正确的计算顺序，并得到结果。最后，我们将输出得到的结果。</p>
<ol>
<li>
<p>包含必要的头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stack&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span>
</pre></li>
<li>
<p>声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后，就来实现我们的RPN解析器。其能接受一对迭代器，两个迭代器分别指定了数学表达式的开始和结尾。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">IT</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-double">double</span> <span class="token function">evaluate_rpn</span><span class="token punctuation">(</span>IT it<span class="token punctuation">,</span> IT end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p>在遍历输入时，需要记住所经过的所有操作数，直到我们看到一个操作符为止。这也就是使用栈的原因。所有数字将会被解析出来，然后以双精度浮点类型进行保存，所以保存到栈中的数据类型为<code>double</code>。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	stack<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> val_stack<span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了能更方便的访问栈中的元素，我们实现了一个辅助函数。其会修改栈中内容，弹出最顶端的元素，并返回这个元素。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">pop_stack</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">r</span> <span class="token punctuation">(</span>val_stack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        val_stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>另一项准备工作，就是定义所支持的数学操作符。我们使用<code>map</code>保存相关数学操作符的作用。每个操作符的实现我们使用Lambda函数实现。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> ops <span class="token punctuation">{</span>
        <span class="token punctuation">{</span><span class="token string">"+"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"^"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">pow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"%"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">fmod</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在就可以对输入进行遍历了。假设我们的输入是字符串，我们使用全新的<code>std::stringstream</code>获取每个单词，这样就可以将操作数解析为数字了。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	stringstream ss <span class="token punctuation">{</span><span class="token operator">*</span>it<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们获得的每个操作数，都要转换成<code>double</code>类型。如果当前解析的字符是操作数，那么我们将转换类型后，推入栈中。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token keyword keyword-double">double</span> val<span class="token punctuation">;</span> ss <span class="token operator">&gt;&gt;</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	val_stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</pre></li>
<li>
<p>如果不是操作数，那么就必定为一个操作符。我们支持的操作符都是二元的，所以当遇到操作符时，我们需要从栈中弹出两个操作数。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> r <span class="token punctuation">{</span><span class="token function">pop_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> l <span class="token punctuation">{</span><span class="token function">pop_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们可以从解引用迭代器<code>it</code>获取操作数。通过查询ops<code>map</code>表，我们可以获得参与Lambda计算的l和r值。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">            <span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span>
                <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span> <span class="token function">op</span> <span class="token punctuation">(</span>ops<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-double">double</span> result <span class="token punctuation">{</span><span class="token function">op</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
                val_stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们使用<code>try</code>代码块将计算代码包围，因为我们的计算可能会出错。在调用<code>map</code>的成员函数<code>at</code>时，可能会抛出一个<code>out_of_range</code>异常，由于用户具体会输入什么样的表达式，并不是我们能控制的。所以，我们将会重新抛出一个不同的异常，我们称之为<code>invalid argument</code>异常，并且携带着程序未知的操作符。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">            <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> out_of_range <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword keyword-throw">throw</span> <span class="token function">invalid_argument</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
</pre></li>
<li>
<p>这就是遍历循环的全部，我们会将栈中的操作数用完，然后得到对应的结果，并将结果保存在栈顶。所以我们要返回栈顶的元素。(我们对栈的大小进行断言，如果大小不是1，那么就有缺失的操作符)</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword keyword-return">return</span> val_stack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在我们可以使用这个RPN解析器了。为了使用这个解析器，我们需要将标准输入包装成一个<code>std::istream_iterator</code>迭代器对，并且传入RPN解析器函数。最后，我们将输出结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">evaluate_rpn</span><span class="token punctuation">(</span>istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>cin<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        	 <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>这里我们再次使用了<code>try</code>代码块，因为用户输入的表达式可能会存在错误，所以当解析器抛出异常时，需要在这里获取。我们需要获取对应的异常，并且打印出一条错误信息：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> invalid_argument <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Invalid operator: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>	
</pre></li>
<li>
<p>完成编译步骤后，我们就可以使用这个解析器了。输入<code>3 1 2 + * 2 /</code>，其为<code>(3*(1+2))/2</code>数学表达式的RPN表达式，然后我们获得相应的结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ echo <span class="token string">"3 1 2 + * 2 /"</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>rpn_calculator
<span class="token number">4.5</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>整个例子通过解析我们的输入，持续向栈中压入操作数的方式完成相应的数学计算。本例中，我们会从栈中弹出最后两个操作数，然后使用操作符对这两个操作数进行计算，然后将其结果保存在栈中。为了理解本节中的所有代码，最重要的就是要理解，我们如何区分了输入中的操作数和操作符，如何管理我们的栈，以及如何选择正确的计算操作符。</p>
<p><strong>栈管理</strong></p>
<p>我们使用<code>std::stack</code>中的成员函数<code>push</code>将元素推入栈中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">val_stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>出站元素的获取看起来有些复杂，因为我们使用了一个Lambda表达式完成这项操作，其能够引用<code>val_stack</code>对象。这里我们为代码添加了一些注释，可能会更好理解一些：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">pop_stack</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">r</span> <span class="token punctuation">(</span>val_stack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取栈顶元素副本</span>
    val_stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从栈中移除顶部元素</span>
    <span class="token keyword keyword-return">return</span> r<span class="token punctuation">;</span> <span class="token comment">// 返回顶部元素副本</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>这个Lambda表达式能够一键式获取栈顶元素，并且能删除顶部元素。在<code>std::stack</code>的设计当中，无法使用一步完成这些操作。不过，定义一个Lambda函数也是十分快捷和简介，所以我们可以使用这种方式获取值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-double">double</span> top_value <span class="token punctuation">{</span><span class="token function">pop_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p><strong>从输入中区别操作数和操作符</strong></p>
<p>主循环中执行<code>evaluate_rpn</code>时，我们会根据迭代器遍历标准输入，然后判断字符是一个操作数，还是一个操作符。如果字符可以被解析成<code>double</code>变量，那这就是一个数，也就是操作数。我们需要考虑有些比较难以解析的数值(比如，+1和-1)，这种数值可能会被解析成操作符(尤其是+1这种)。</p>
<p>用于区分操作数和操作符的代码如下所示：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">stringstream ss <span class="token punctuation">{</span><span class="token operator">*</span>it<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token keyword keyword-double">double</span> val<span class="token punctuation">;</span> ss <span class="token operator">&gt;&gt;</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// It's a number!</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
	<span class="token comment">// It's something else than a number - an operation!</span>
<span class="token punctuation">}</span>
</pre><p>如果字符是一个数字，流操作符<code>&gt;&gt;</code>会告诉我们。首先，我们将字符串包装成一个<code>std::stringstream</code>。然后使用<code>stringstream</code>对象的能力，将流中<code>std::string</code>类型解析并转换成一个<code>double</code>变量。解析失败时也能知道是为什么，因为只解析器需要解析数字出来；否则，需要解析的就不是一个数字。</p>
<p><strong>选择和应用正确的数学操作符</strong></p>
<p>判断完当前用户的输入是否为一个数后，我们先假设输入了一个操作符，比如<code>+</code>或<code>*</code>。然后，查询<code>map</code>表ops，找到对应的操作，并返回相应的函数，其函数可以接受两个操作数，然后返回对应操作后的结果。</p>
<p><code>map</code>表本身的类型看起来会相对复杂：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> ops <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>其将<code>string</code>映射到<code>double (*)(double, double)</code>。后者是什么意思呢？这个类型是一个函数指针的声明，说明这个函数接受两个double类型的变量作为输入，并且返回值也是<code>double</code>类型。可以将<code>(*)</code>部分理解成函数的名字，例如<code>double sum(double, double</code>，这样就好理解多了吧。这里的重点在于我们的Lambda函数<code>[](double, double) {return /* some double */ }</code>，其可转换为实际匹配指针声明的函数。这里Lambda不获取任何东西，所以可以转化为函数指针。</p>
<p>这样，我们就可以方便的在<code>map</code>表中查询操作符是否支持：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span> <span class="token function">op</span> <span class="token punctuation">(</span>ops<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-double">double</span> result <span class="token punctuation">{</span><span class="token function">op</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p><code>map</code>会为我们隐式的做另一件事：当我们执行<code>ops.at("foo")</code>时，如果<code>"foo"</code>是一个合法键(实际中我们不会用这个名字存任何操作)，那么在这个例子中，<code>map</code>表将会抛出一个异常，例子中可以捕获这个异常。当我们捕获这个异常时，我们会重新抛出一个不同的异常，为了描述我们遇到了什么样的错误。相较于<code>out of range</code>，用户也能更好的了解<code>invalid argument</code>异常的含义，因此我们在使用的时候，程序的<code>map</code>表到底支持哪些操作，我们是不知道的。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p><code>evaluate_rpn</code>函数可以传入迭代器，感觉这样传递的方式要比传入标准输入更加容易理解。这让程序更容易测试，或适应来自于用户的不同类型的输入。</p>
<p>使用字符串流或字符串数组的迭代器作为输入，例如下面的代码，<code>evaluate_rpn</code>不用做任何修改：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    stringstream s <span class="token punctuation">{</span><span class="token string">"3 2 1 + * 2 /"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">evaluate_rpn</span><span class="token punctuation">(</span>istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>s<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">evaluate_rpn</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><blockquote>
<p>Note:</p>
<p>在有意义的地方使用迭代器，会使得代码可重复利用度高，模块化好。</p>
</blockquote>
</div></div><div id="ebook-heading-x5b9ex73b0x8bcdx9891x8ba1x6570x5668x2014x2014stdmap" ebook-toc-level-2="" heading="实现词频计数器——std::map"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E8%AF%8D%E9%A2%91%E8%AE%A1%E6%95%B0%E5%99%A8stdmap">实现词频计数器——std::map</h1>

<p><code>std::map</code>在收集和统计数据方面非常有用，通过建立键值关系，将可修改的对象映射到对应键上，可以很容易的实现一个词频计数器。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将从标准输入中获取用户的输入，或是从记录一部小说的文本文件。我们会去标记输入单词，并统计一共有多少个单词。</p>
<ol>
<li>
<p>包含必要的头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
</pre></li>
<li>
<p>声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将使用一个辅助函数，对输入中的符号进行处理。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">string <span class="token function">filter_punctuation</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>forbidden <span class="token punctuation">{</span><span class="token string">".,:; "</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">idx_start</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_first_not_of</span><span class="token punctuation">(</span>forbidden<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">idx_end</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_last_not_of</span><span class="token punctuation">(</span>forbidden<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>idx_start<span class="token punctuation">,</span> idx_end <span class="token operator">-</span> idx_start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在，我们来实现真正要工作的部分。使用<code>map</code>表对输入的每个单词进行统计。另外，使用一个变量来保存目前为止看到的最长单词的长度。程序的最后，我们将打印这个<code>map</code>表。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> words<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> max_word_len <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>将标准输入导入<code>std::string</code>变量中，标准输入由空格隔开。通过如下方法获取输入单词。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    string s<span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</pre></li>
<li>
<p>我们获得的单词可能包含标点符号，因为这些符号可能紧跟在单词后面。使用辅助函数将标点符号去除。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">		<span class="token keyword keyword-auto">auto</span> <span class="token function">filtered</span> <span class="token punctuation">(</span><span class="token function">filter_punctuation</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>如果当前处理的单词是目前处理最长的单词，我们会更新<code>max_word_len</code>变量。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">		max_word_len <span class="token operator">=</span> <span class="token generic-function"><span class="token function">max</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>max_word_len<span class="token punctuation">,</span> filtered<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后，我们将增加该词在<code>words map</code>中的频率。如果是首次处理该单词，那么将会隐式创建一个键值对，然后插入<code>map</code>，之后再进行自加操作。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    	<span class="token operator">++</span>words<span class="token punctuation">[</span>filtered<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>	
</pre></li>
<li>
<p>当循环结束时，<code>words map</code>会保存所有输入单词的频率。<code>map</code>中单词作为键，并且键以字母序排列。我们想要以频率多少进行排序，词频最高的排第一位。为了达到这样的效果，首先实现一个<code>vector</code>，将所有键值对放入这个<code>vector</code>中。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">&gt;&gt;</span> word_counts<span class="token punctuation">;</span>
    word_counts<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">move</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>word_counts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后，<code>vector</code>中将将具有<code>words map</code>中的所有元素。然后，我们来进行排序，把词频最高的单词排在最开始，最低的放在最后。</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">sort</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>word_counts<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>word_counts<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> a<span class="token punctuation">.</span>second <span class="token operator">&gt;</span> b<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><ol start="11">
<li>
<p>现在所有元素如我们想要的顺序排列，之后将这些数据打印在用户的终端上。使用<code>std::setw</code>流控制器，可以格式化输出相应的内容。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"# "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span>max_word_len<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"&lt;WORD&gt;"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" #&lt;COUNT&gt;\n"</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span> <span class="token punctuation">[</span>word<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">:</span> word_counts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span>max_word_len <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> <span class="token string">" #"</span>
        	 <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译后运行，我们就会得到一个词频表：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ cat lorem_ipsum<span class="token punctuation">.</span>txt <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>word_frequency_counter
# <span class="token operator">&lt;</span>WORD<span class="token operator">&gt;</span> #<span class="token operator">&lt;</span>COUNT<span class="token operator">&gt;</span>
et #<span class="token number">574</span>
dolor #<span class="token number">302</span>
sed #<span class="token number">273</span>
diam #<span class="token number">273</span>
sit #<span class="token number">259</span>
ipsum #<span class="token number">259</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节中，我们使用<code>std::map</code>实例进行单词统计，然后将<code>map</code>中的所有元素放入<code>vector</code>中，然后进行排序，再打印输出。为什么要这么做？</p>
<p>先看一个例子。当我们要从<code>a a b c b b b d c c</code>字符串中统计词频时，我们的<code>map</code>内容如下：</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>a -&gt; 2
b -&gt; 4
c -&gt; 3
d -&gt; 1
</code></pre><p>不过，这是未排序的，这不是我们想要给用户展示的排序。我们的程序要首先输出b的频率，因为b的频率最高。然后是c，a，d。不幸的是，我们无法要求<code>map</code>使用键所对应的值进行排序。</p>
<p>这就需要<code>vector</code>帮忙了，将<code>map</code>中的键值对放入<code>vector</code>中。这个方法明确的将这些元素从<code>map</code>中删除了。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> size_t<span class="token operator">&gt;&gt;</span> word_counts<span class="token punctuation">;</span>
</pre><p>然后，我们使用<code>std::move</code>函数将词-频对应关系填充整个<code>vector</code>。这样的好处是让单词不会重复，不过这样会将元素从<code>map</code>中完全删除。使用<code>move</code>方法，减少了很多不必要的拷贝。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token function">move</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>word_counts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><blockquote>
<p>Note</p>
<p>一些STL的实现使用短字符优化——当所要处理的字符串过长，这种方法将无需再在堆上分配内存，并且可以将字符串直接进行存储。在这个例子中，移动虽然不是最快的方式，但也不会慢多少。</p>
</blockquote>
<p>接下来比较有趣的就是排序操作，其使用了一个Lambda表达式作为自定义比较谓词：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token function">sort</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>word_counts<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>word_counts<span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> a<span class="token punctuation">.</span>second <span class="token operator">&gt;</span> b<span class="token punctuation">.</span>second<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>排序算法将会成对的处理元素，比较两个元素。通过提供的Lambda函数，<code>sort</code>方法将不会再使用默认比较谓词，其会将<code>a.second</code>和<code>b.second</code>进行比较。这里的键值对中，第二个值为词频数，所以可以使用<code>.second</code>得到对应词频数。通过这种方式，将移动所有高频率的词到<code>vector</code>的开始，并且将低频率词放在末尾。</p>
</div></div><div id="ebook-heading-x5b9ex73b0x5199x4f5cx98cex683cx52a9x624bx7528x6765x67e5x627ex6587x672cx4e2dx5f88x957fx7684x53e5x5b50x2014x2014stdmultimap" ebook-toc-level-2="" heading="实现写作风格助手用来查找文本中很长的句子——std::multimap"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E5%86%99%E4%BD%9C%E9%A3%8E%E6%A0%BC%E5%8A%A9%E6%89%8B%E7%94%A8%E6%9D%A5%E6%9F%A5%E6%89%BE%E6%96%87%E6%9C%AC%E4%B8%AD%E5%BE%88%E9%95%BF%E7%9A%84%E5%8F%A5%E5%AD%90stdmultimap">实现写作风格助手用来查找文本中很长的句子——std::multimap</h1>

<p>当有超级多的元素需要排序时，某些键值描述可能会出现多次，那么使用<code>std::multimap</code>完成这项工作无疑是个不错的选择。</p>
<p>先找个应用场景：当使用德文写作时，使用很长的句子是没有问题的。不过，使用英文时，就不行了。我们将实现一个辅助工具来帮助德国作家们分析他们的英文作品，着重于所有句子的长度。为了帮助这些作家改善其写作的文本风格，工具会按句子的长度对每个句子进行分组。这样作家们就能挑出比较长的句子，然后截断这些句子。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将从标准输入中获取用户输入，用户会输入所有的句子，而非单词。然后，我们将这些句子和其长度收集在<code>std::multimap</code>中。之后，我们将对所有句子的长度进行排序，打印给用户看。</p>
<ol>
<li>
<p>包含必要的头文件。<code>std::multimap</code>和<code>std::map</code>在同一个头文件中声明。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
</pre></li>
<li>
<p>声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们使用句号将输入字符串分成若干个句子，句子中的每个单词以空格隔开。句子中的一些对于句子长度无意义的符号，也会计算到长度中，所以，这里要使用辅助函数将这些符号过滤掉。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">string <span class="token function">filter_ws</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>ws <span class="token punctuation">{</span><span class="token string">" \r\n\t"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">a</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_first_not_of</span><span class="token punctuation">(</span>ws<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">b</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_last_not_of</span><span class="token punctuation">(</span>ws<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>计算句子长度函数需要接收一个包含相应内容的字符串，并且返回一个<code>std::multimap</code>实例，其映射了排序后的句子长度和相应的句子。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">multimap<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> string<span class="token operator">&gt;</span> <span class="token function">get_sentence_stats</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>content<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p>这里声明一个<code>multimap</code>结构，以及一些迭代器。在计算长度的循环中，我们需要<code>end</code>迭代器。然后，我们使用两个迭代器指向文本的开始和结尾。所有句子都在这个文本当中。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    multimap<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> string<span class="token operator">&gt;</span> ret<span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">end_it</span> <span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">it1</span> <span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">it2</span> <span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>it1<span class="token punctuation">,</span> end_it<span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>it2</code>总是指向句号，而<code>it1</code>指向句子的开头。只要<code>it1</code>没有到达文本的末尾就好。第二个条件就是要检查<code>it2</code>是否指向字符。如果不满足这些条件，那么就意味着这两个迭代器中没有任何字符了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>it1 <span class="token operator">!=</span> end_it <span class="token operator">&amp;&amp;</span> <span class="token function">distance</span><span class="token punctuation">(</span>it1<span class="token punctuation">,</span> it2<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	
</pre></li>
<li>
<p>我们使用两个迭代器间的字符创建一个字符串，并且过滤字符串中所有的空格，只是为了计算句子纯单词的长度。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">		string s <span class="token punctuation">{</span><span class="token function">filter_ws</span><span class="token punctuation">(</span><span class="token punctuation">{</span>it1<span class="token punctuation">,</span> it2<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>当句子中不包含任何字符，或只有空格时，我们就不统计这句。另外，我们要计算有多少单词在句子中。这很简单，每个单词间都有空格隔开，单词的数量很容易计算。然后，我们就将句子和其长度保存在<code>multimap</code>中。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">words</span> <span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ret<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> <span class="token function">move</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</pre></li>
<li>
<p>对于下一次循环迭代，我们将会让<code>it1</code>指向<code>it2</code>的后一个字符。然后将<code>it2</code>指向下一个句号。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        it1 <span class="token operator">=</span> <span class="token function">next</span><span class="token punctuation">(</span>it2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        it2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>it1<span class="token punctuation">,</span> end_it<span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
</pre></li>
<li>
<p>循环结束后，<code>multimap</code>包含所有句子以及他们的长度，这里我们将其返回。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-return">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在，我们来写主函数。首先，我们让<code>std::cin</code>不要跳过空格，因为我们需要句子中有空格。为了读取整个文件，我们使用<code>std::cin</code>包装的输入流迭代器初始化一个<code>std::string</code>实例。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cin<span class="token punctuation">.</span><span class="token function">unsetf</span><span class="token punctuation">(</span>ios<span class="token double-colon punctuation">::</span>skipws<span class="token punctuation">)</span><span class="token punctuation">;</span>
    string content <span class="token punctuation">{</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cin<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>只需要打印<code>multimap</code>的内容，在循环中调用<code>get_sentence_stats</code>，然后打印<code>multimap</code>中的内容。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span> <span class="token punctuation">[</span>word_count<span class="token punctuation">,</span> sentence<span class="token punctuation">]</span>
    		<span class="token operator">:</span> <span class="token function">get_sentence_stats</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   	 cout <span class="token operator">&lt;&lt;</span> word_count <span class="token operator">&lt;&lt;</span> <span class="token string">" words: "</span> <span class="token operator">&lt;&lt;</span> sentence <span class="token operator">&lt;&lt;</span> <span class="token string">".\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译完成后，我们可以使用一个文本文件做例子。由于长句子的输出量很长，所以先把最短的句子打印出来，最后打印最长的句子。这样，我们就能首先看到最长的句子。</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>$ cat lorem_ipsum.txt | ./sentence_length
...
10 words: Nam quam nunc, blandit vel, luctus pulvinar,
hendrerit id, lorem.
10 words: Sed consequat, leo eget bibendum sodales,
augue velit cursus nunc,.
12 words: Cum sociis natoque penatibus et magnis dis
parturient montes, nascetur ridiculus mus.
17 words: Maecenas tempus, tellus eget condimentum rhoncus,
sem quam semper libero, sit amet adipiscing sem neque sed ipsum.
</code></pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>整个例子中，我们将一个很长的字符串，分割成多个短句，从而评估每个句子的长度，并且在<code>multimap</code>中进行排序。因为<code>std::multimap</code>很容易使用，所以变成较为复杂的部分就在于循环，也就是使用迭代器获取每句话的内容。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">end_it</span> <span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// (1) Beginning of string</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">it1</span> <span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">// (1) First '.' dot</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">it2</span> <span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>it1<span class="token punctuation">,</span> end_it<span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>it1 <span class="token operator">!=</span> end_it <span class="token operator">&amp;&amp;</span> std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>it1<span class="token punctuation">,</span> it2<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    string sentence <span class="token punctuation">{</span>it1<span class="token punctuation">,</span> it2<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// Do something with the sentence string...</span>
    
    <span class="token comment">// One character past current '.' dot</span>
    it1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">next</span><span class="token punctuation">(</span>it2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    
    <span class="token comment">// Next dot, or end of string</span>
    it2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>it1<span class="token punctuation">,</span> end_it<span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</pre><p>将代码和下面的图结合起来可能会更好理解，这里使用具有三句话的字符串来举例。</p>
<p><img src="./C++17 STL Cook book_files/2-12-1.png" alt=""></p>
<p><code>it1</code>和<code>it2</code>总是随着字符串向前移动。通过指向句子的开头和结尾的方式，确定一个句子中的内容。<code>std::find</code>算法会帮助我们寻找下一个句号的位置。</p>
<blockquote>
<p>std::find的描述：</p>
<p>从当前位置开始，返回首先找到的目标字符迭代器。如果没有找到，返回结束迭代器。</p>
</blockquote>
<p>这样我们就获取了一个句子，然后通过构造对应字符串的方式，将句子的长度计算出来，并将长度和原始句子一起插入<code>multimap</code>中。我们使用句子的长度作为元素的键，原句作为值存储在<code>multimap</code>中。通常一个文本中，长度相同的句子有很多。这样使用<code>std::map</code>就会比较麻烦。不过<code>std::multimap</code>就没有重复键值的问题。这些键值也是排序好的，从而能得到用户们想要的输出。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>将整个文件读入一个大字符串中后，遍历字符串时需要为每个句子创建副本。这是没有必要的，这里可以使用<code>std::string_view</code>来完成这项工作，该类型我们将会放在后面来介绍。</p>
<p>另一种从两个句号中获取句子的方法就是使用<code>std::regex_iterator</code>(正则表达式)，我们将会在后面的章节中进行介绍。</p>
</div></div><div id="ebook-heading-x5b9ex73b0x4e2ax4ebax5f85x529ex4e8bx9879x5217x8868x2014x2014stdpriority_queue" ebook-toc-level-2="" heading="实现个人待办事项列表——std::priority_queue"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9%E5%88%97%E8%A1%A8stdpriority_queue">实现个人待办事项列表——std::priority_queue</h1>

<p><code>std::priority_queue</code>是另一种适配容器(类似于<code>std::stack</code>)。其实为另一种数据结构的包装器(默认的数据结构为<code>std::vector</code>)，并且提供类似队列的接口。同样也遵循队列的特性，先进先出。这与我们之前使用的<code>std::stack</code>完全不同。</p>
<p>这里仅仅是对<code>std::queue</code>的行为进行描述，本节将展示<code>std::priority_queue</code>是如何工作的。这个适配器比较特殊，其不仅有FIFO的特性，还混合着优先级。这就意味着，FIFO的原则会在某些条件下被打破，根据优先级的顺序形成子FIFO队列。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将创建一个待办事项的结构。为了程序的简明性就不从用户输入解析输入了。这次专注于<code>std::priority_queue</code>的使用。所以我们使用一些待办事项和优先级填充一个优先级序列，然后以FIFO的顺序读出这些元素(这些元素是通过优先级进行过分组)。</p>
<ol>
<li>
<p>包含必要的头文件。<code>std::priority_queue</code>在<code>&lt;queue&gt;</code>中声明。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tuple&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
</pre></li>
<li>
<p>我们怎么将待办事项存在优先级队列中呢？我们不能添加项目时，附加优先级。优先级队列将使用自然序对待队列中的所有元素。现在我们实现一个自定义的结构体<code>struct todo_item</code>，并赋予其优先级系数，和一个字符串描述待办事件，并且为了让该结构体具有可排序性，这里会实现比较操作符<code>&lt;</code>。另外，我们将会使用<code>std::pair</code>，其能帮助我们聚合两个类型为一个类型，并且能完成自动比较。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-using">using</span> item_type <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>那么现在我们有了一个新类型<code>item_type</code>，其由一个优先级数字和一个描述字符串构成。所以，我们可以使用这种类型实例化一个优先级队列。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	std<span class="token double-colon punctuation">::</span>priority_queue<span class="token operator">&lt;</span>item_type<span class="token operator">&gt;</span> q<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们现在来填充优先级队列。其目的就是为了提供一个非结构化列表，之后优先级队列将告诉我们以何种顺序做什么事。比如，你有漫画要看的同时，也有作业需要去做，那么你必须先去写作业。不过，<code>std::priority_queue</code>没有构造函数，其支持初始化列表，通过列表我们能够填充优先级队列(使用<code>vector</code>或<code>list</code>都可以对优先级队列进行初始化)。所以我们这里定义了一个列表，用于下一步的初始化。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>item_type<span class="token operator">&gt;</span> il <span class="token punctuation">{</span>
        <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"dishes"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"watch tv"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"do homework"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"read comics"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们可以很方便的遍历列表中的所有元素，然后通过<code>push</code>成员函数将元素插入优先级列表中。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>p <span class="token operator">:</span> il<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>这样所有的元素就都隐式的进行了排序，并且我们可以浏览列表中优先级最高的事件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行程序。结果如我们所料，作业是最优先的，看电视和看漫画排在最后。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>main
<span class="token number">2</span><span class="token operator">:</span> <span class="token keyword keyword-do">do</span> homework
<span class="token number">1</span><span class="token operator">:</span> dishes
<span class="token number">0</span><span class="token operator">:</span> watch tv
<span class="token number">0</span><span class="token operator">:</span> read comics
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>std::priority_queue</code>使用起来很简单。我们只是用了其三个成员函数。</p>
<ol>
<li><code>q.push(item)</code>将元素推入队列中。</li>
<li><code>q.top()</code>返回队首元素的引用。</li>
<li><code>q.pop()</code>移除队首元素。</li>
</ol>
<p>不过，如何做到排序的呢？我们将优先级数字和描述字符串放入一个<code>std::pair</code>中，然后就自然得到排序后的结果。这里有一个<code>std::pair&lt;int, std::string&gt;</code>的实例<code>p</code>，我们可通过<code>p.first</code>访问优先级整型数，使用<code>p.second</code>访问字符串。我们在循环中就是这样打印所有待办事件的。</p>
<p>如何让优先级队列意识到<code>{2, "do homework"}</code>要比<code>{0, "watch tv"}</code>重要呢？</p>
<p>比较操作符<code>&lt;</code>在这里处理了不同的元素。我们假设现在有<code>left &lt; right</code>，两个变量的类型都是pair。</p>
<ol>
<li><code>left.first != right.first</code>，然后返回<code>left.first &lt; right.first</code>。</li>
<li><code>left.first == right.first</code>，然后返回<code>left.second &lt; right.second</code>。</li>
</ol>
<p>以这种方式就能满足我们的要求。最重要的就是<code>pair</code>中第一个成员，然后是第二个成员。否则，<code>std::priority_queue</code>将会字母序将元素进行排序，而非使用数字优先级的顺序(这样的话，看电视将会成为首先要做的事情，而完成作业则是最后一件事。对于懒人来说，无疑是个完美的顺序)。</p>
</div></div><div id="ebook-heading-x7b2c3x7ae0-x8fedx4ee3x5668" ebook-toc-level-1="" heading="第3章 迭代器"><div><h1 class="mume-header" id="%E7%AC%AC3%E7%AB%A0-%E8%BF%AD%E4%BB%A3%E5%99%A8">第3章 迭代器</h1>

<p>迭代器是C++中非常重要的概念。STL旨在打造一组灵活和通用的工具集，迭代器是工具集中重要的一环。不过，有时候迭代器使用起来比较繁琐，所以很多编程人员还是喜欢用C的指针来完成相应的功能。一半的编程人员基本上会放弃使用STL中的迭代器。本章介绍了迭代器，并展示如何让它们很快的工作起来。快速地介绍是不能完全覆盖迭代器强大的功能，但是这种小例子能让你增加对迭代器的好感度。</p>
<p>大多数容器类(除了类似C风格的数组)，可包含一系列的数据项。许多日常任务会处理超大的数据量，这里先不关心如何获得这些数据。不过，如果我们考虑数组和链表，并且想要计算这两种结构所有项的和，那么将如下使用两种不同的算法：</p>
<ul>
<li>
<p>通过查询数组的大小，来进行加和计算：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> sum <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array_size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> sum <span class="token operator">+=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre></li>
<li>
<p>使用迭代器进行循环，直到数组的末尾：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> sum <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>list_node <span class="token operator">!=</span> <span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	sum <span class="token operator">+=</span> list_node<span class="token operator">-&gt;</span>value<span class="token punctuation">;</span> list_node <span class="token operator">=</span> list_node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
</ul>
<p>两种方法都能计算出所有项的加和，不过我们键入的代码，有多少用在实际加和任务中了呢？如果说要使用其他结构体来存储这些数据，例如<code>std::map</code>，难道我们还要在重新实现一个函数？使用迭代器是最佳的选择。</p>
<p>使用迭代器的代码才更加的通用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> sum <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">:</span> array_or_vector_or_map_or_list<span class="token punctuation">)</span> <span class="token punctuation">{</span> sum <span class="token operator">+=</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre><p>这段代码很简洁，只是使用C++11添加的for循环范围特性就完成了整体的叠加。其就像是个语法糖，将其扩展后类似如下代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;&amp;</span> __range <span class="token operator">=</span> array_or_vector_or_map_or_list <span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> __begin <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>__range<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> __end <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">end</span><span class="token punctuation">(</span>__range<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> __begin <span class="token operator">!=</span> __end<span class="token punctuation">;</span> <span class="token operator">++</span>__begin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token operator">*</span>__begin<span class="token punctuation">;</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre><p>这段代码对于使用迭代器的老手来说并没有什么，不过对于刚接触迭代器的新手来说就像是在变魔术。</p>
<p>假设我们的<code>vector</code>内容如下所示：</p>
<p><img src="./C++17 STL Cook book_files/3-0-1.png" alt=""></p>
<p><code>std::begin(vector)</code>和<code>vector.begin()</code>等价，并且返回<code>vector</code>中指向第一个元素的迭代器(指向1)。<code>std::end(vector)</code>与<code>vector.end()</code>等价，并返回指向<code>vector</code>末尾元素的迭代器(指向5的后方)。</p>
<p>每一次迭代，循环都会检查开始迭代器是否与末尾迭代器不同。如果是，那么可以对开始迭代器进行解引用，并获取其指向的值。然后，推动迭代器指向下一个元素，再与末尾迭代器进行比较，以此类推。这也能提升代码的可读性，这样的迭代器就类似于C风格的指针。实际上，C风格的指针也是一种迭代器。</p>
<h2 class="mume-header" id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B">迭代器的类型</h2>

<p>C++中很多迭代器类型，都有各自的局限性。不用去死记这些限制，只要记住一种类型的能力是从更强大的类型继承过来的即可。当知道算法是使用何种迭代器实现时，编译器就可以以更好的方式优化这个算法。所以，开发者只要表达清楚自己想要实现的算法，那么编译器将选择优化后的实现来完成对应的任务。</p>
<p>让我们来看下这些迭代器吧(从左往右)：</p>
<p><img src="./C++17 STL Cook book_files/3-0-2.png" alt=""></p>
<h3 class="mume-header" id="%E8%BE%93%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8">输入迭代器</h3>

<p>只能用来读取指向的值。当该迭代器自加时，之前指向的值就不可访问。也就是说，不能使用这个迭代器在一个范围内遍历多次。<code>std::istream_iterator</code>就是这样的迭代器。</p>
<h3 class="mume-header" id="%E5%89%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8">前向迭代器</h3>

<p>类似于输入迭代器，不过其可以在指示范围内迭代多次。<code>std::forward_list</code>就是这样的迭代器。就像一个单向链表一样，只能向前遍历，不能向后遍历，但可以反复迭代。</p>
<h3 class="mume-header" id="%E5%8F%8C%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8">双向迭代器</h3>

<p>从名字就能看出来，这个迭代器可以自增，也可以自减，迭代器可以向前或向后迭代。<code>std::list</code>，<code>std::set</code>和<code>std::map</code>都支持双向迭代器。</p>
<h3 class="mume-header" id="%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%BF%AD%E4%BB%A3%E5%99%A8">随机访问迭代器</h3>

<p>与其他迭代器不同，随机访问迭代器一次可以跳转到任何容器中的元素上，而非之前的迭代器，一次只能移动一格。<code>std::vector</code>和<code>std::deque</code>的迭代器就是这种类型。</p>
<h3 class="mume-header" id="%E8%BF%9E%E7%BB%AD%E8%BF%AD%E4%BB%A3%E5%99%A8">连续迭代器</h3>

<p>这种迭代器具有前述几种迭代器的所有特性，不过需要容器内容在内存上是连续的，类似一个数组或<code>std::vector</code>。</p>
<h3 class="mume-header" id="%E8%BE%93%E5%87%BA%E8%BF%AD%E4%BB%A3%E5%99%A8">输出迭代器</h3>

<p>该迭代器与其他迭代器不同。因为这是一个单纯用于写出的迭代器，其只能增加，并且将对应内容写入文件当中。如果要读取这个迭代中的数据，那么读取到的值就是未定义的。</p>
<h3 class="mume-header" id="%E5%8F%AF%E5%8F%98%E8%BF%AD%E4%BB%A3%E5%99%A8">可变迭代器</h3>

<p>如果一个迭代器既有输出迭代器的特性，又有其他迭代器的特性，那么这个迭代器就是可变迭代器。该迭代器可读可写。如果我们从一个非常量容器的实例中获取一个迭代器，那么这个迭代器通常都是可变迭代器。</p>
</div></div><div id="ebook-heading-x5efax7acbx53efx8fedx4ee3x533ax57df" ebook-toc-level-2="" heading="建立可迭代区域"><div><h1 class="mume-header" id="%E5%BB%BA%E7%AB%8B%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8C%BA%E5%9F%9F">建立可迭代区域</h1>

<p>我们已经认识了STL中提供的各种迭代器。我们只需实现一个迭代器，支持前缀加法<code>++</code>，解引用<code>*</code>和比较操作<code>==</code>，这样我们就能使用C++11基于范围的for循环对该迭代器进行遍历。</p>
<p>为了更好的了解迭代器，本节中将展示如何实现一个迭代器。迭代该迭代器时，只输出一组数字。实现的迭代器并不支持任何容器，以及类似的结构。这些数字是在迭代过程中临时生成的。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将实现一个迭代器类，并且对该迭代器进行迭代：</p>
<ol>
<li>
<p>包含必要的头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span> </span>
</pre></li>
<li>
<p>迭代器结构命名为<code>num_iterator</code>:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">num_iterator</span> <span class="token punctuation">{</span> 
</pre></li>
<li>
<p>其数据类型只能是整型，仅用是用来计数的，构造函数会初始化它们。显式声明构造函数是一个好习惯，这就能避免隐式类型转换。需要注意的是，我们会使用<code>position</code>值来初始化<code>i</code>。这就让<code>num_iterator</code>可以进行默认构造。虽然我们的整个例子中都没有使用默认构造函数，但默认构造函数对于STL的算法却是很重要的。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
	<span class="token keyword keyword-explicit">explicit</span> <span class="token function">num_iterator</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> i<span class="token punctuation">{</span>position<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre></li>
<li>
<p>当对迭代器解引用时*it`，将得到一个整数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-int">int</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre></li>
<li>
<p>前缀加法操作<code>++it</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    num_iterator<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>i<span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p><code>for</code>循环中需要迭代器之间进行比较。如果不相等，则继续迭代：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-bool">bool</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> num_iterator <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> i <span class="token operator">!=</span> other<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>迭代器类就实现完成了。我们仍需要一个中间对象对应于<code>for (int i : intermediate(a, b)) {...}</code>写法，其会从头到尾的遍历，其为一种从a到b遍历的预编程。我们称其为<code>num_range</code>:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">num_range</span> <span class="token punctuation">{</span>
</pre></li>
<li>
<p>其包含两个整数成员，一个表示从开始，另一个表示结束。如果我们要从0到9遍历，那么a为0，b为10(<code>[0, 10)</code>)：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-int">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> b<span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">num_range</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> from<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> to<span class="token punctuation">)</span>
    	<span class="token operator">:</span> a<span class="token punctuation">{</span>from<span class="token punctuation">}</span><span class="token punctuation">,</span> b<span class="token punctuation">{</span>to<span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre></li>
<li>
<p>该类也只有两个成员函数需要实现：<code>begin</code>和<code>end</code>函数。两个函数都返回指向对应数字的指针：一个指向开始，一个指向末尾。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    num_iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> num_iterator<span class="token punctuation">{</span>a<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    num_iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> num_iterator<span class="token punctuation">{</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>所有类都已经完成，让我们来使用一下。让我们在主函数中写一个例子，遍历100到109间的数字，并打印这些数值：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">:</span> num_range<span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">110</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><ol start="11">
<li>
<p>编译运行后，得到如下输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">102</span><span class="token punctuation">,</span> <span class="token number">103</span><span class="token punctuation">,</span> <span class="token number">104</span><span class="token punctuation">,</span> <span class="token number">105</span><span class="token punctuation">,</span> <span class="token number">106</span><span class="token punctuation">,</span> <span class="token number">107</span><span class="token punctuation">,</span> <span class="token number">108</span><span class="token punctuation">,</span> <span class="token number">109</span><span class="token punctuation">,</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>考虑一下如下的代码段：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> x <span class="token operator">:</span> range<span class="token punctuation">)</span> <span class="token punctuation">{</span> code_block<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre><p>这段代码将被编译器翻译为类似如下的代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> __begin <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>range<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> __end <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">end</span><span class="token punctuation">(</span>range<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> __begin <span class="token operator">!=</span> __end<span class="token punctuation">;</span> <span class="token operator">++</span>__begin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> x <span class="token operator">=</span> <span class="token operator">*</span>__begin<span class="token punctuation">;</span>
        code_block
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre><p>这样看起来就直观许多，也能清楚的了解我们的迭代器需要实现如下操作：</p>
<ul>
<li>operator!=</li>
<li>operatpr++</li>
<li>operator*</li>
</ul>
<p>也需要<code>begin</code>和<code>end</code>方法返回相应的迭代器，用来确定开始和结束的范围。</p>
<blockquote>
<p>Note:</p>
<p>本书中，我们使用<code>std::begin(x)</code>替代<code>x.begin()</code>。如果有<code>begin</code>成员函数，那么<code>std::begin(x)</code>会自动调用<code>x.begin()</code>。当<code>x</code>是一个数组，没有<code>begin()</code>方法是，<code>std::begin(x)</code>会找到其他方式来处理。同样的方式也适用于<code>std::end(x)</code>。当用户自定义的类型不提供<code>begin/end</code>成员函数时，<code>std::begin/std::end</code>就无法工作了。</p>
</blockquote>
<p>本例中的迭代器是一个前向迭代器。再来看一下使用<code>num_range</code>的循环，从另一个角度看是非常的简单。</p>
<blockquote>
<p>Note:</p>
<p>回头看下构造出迭代器的方法在<code>range</code>类中为<code>const</code>。这里不需要关注编译器是否会因为修饰符<code>const</code>而报错，因为迭代<code>const</code>的对象是很常见的事。</p>
</blockquote>
</div></div><div id="ebook-heading-x8ba9x81eax5df1x7684x8fedx4ee3x5668x4e0estlx7684x8fedx4ee3x5668x517cx5bb9" ebook-toc-level-2="" heading="让自己的迭代器与STL的迭代器兼容"><div><h1 class="mume-header" id="%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Estl%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%BC%E5%AE%B9">让自己的迭代器与STL的迭代器兼容</h1>

<p>上一节中，我们实现了自己的迭代器，不过为了融合STL提供的迭代器的优点，我们需要提供一些迭代器接口。后面我们会来学习如果实现这些接口，不过将我们自定义的迭代器与STL的标准迭代器放在一起时，有时会发现有编译不通过的问题。这是为什么呢？</p>
<p>STL算法尝试寻找更多有关于我们所使用迭代器的信息。不同迭代器的能力是不同的，不大可能用同样的算法实现不同的迭代器。例如，我们只是简单的从一个<code>std::vector</code>将其中的数字拷贝到另一个时，我们的实现中可以直接调用<code>memcpy</code>快速实现这个功能。如果容器是<code>std::list</code>的话，<code>memcpy</code>的方式就不好用了，只能一个个的单独拷贝。实现者将大量的自动优化思想注入STL算法实现当中。为了能更好的使用，我们也会为我们的迭代器装备这些思想。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将实现一个简单的计数迭代器(与STL算法一起使用)，一开始这个实现是无法编译通过的。我们需要做一些兼容性操作，使得程序通过编译。</p>
<ol>
<li>
<p>包含必要的头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
</pre></li>
<li>
<p>实现一个计数迭代器，作为基础版本。当我们使用其进行遍历时，我们只需要增加计数器即可。<code>num_range</code>用来处理<code>begin</code>和<code>end</code>迭代器。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">num_iterator</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-explicit">explicit</span> <span class="token function">num_iterator</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> i<span class="token punctuation">{</span>position<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword keyword-int">int</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    num_iterator<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>i<span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-bool">bool</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> num_iterator <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> i <span class="token operator">!=</span> other<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-bool">bool</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> num_iterator <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword keyword-this">this</span> <span class="token operator">!=</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-class">class</span> <span class="token class-name">num_range</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> b<span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>	
    <span class="token function">num_range</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> from<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> to<span class="token punctuation">)</span>
    	<span class="token operator">:</span> a<span class="token punctuation">{</span>from<span class="token punctuation">}</span><span class="token punctuation">,</span> b<span class="token punctuation">{</span>to<span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
    num_iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> num_iterator<span class="token punctuation">{</span>a<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    num_iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> num_iterator<span class="token punctuation">{</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在让我们来遍历100到109间的数字。这里需要注意的是，110这里是开区间，所以值无法遍历到110。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	num_range r <span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">110</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，我们使用一个STL算法<code>std::minmax_element</code>。这个算法会返回一个<code>std::pair</code>，其具有两个迭代器：一个指向最小值的迭代器和一个指向最大值的迭代器。在这个范围中100和109即为这两个迭代器所指向的位置。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">min_max</span><span class="token punctuation">(</span><span class="token function">minmax_element</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>min_max<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" - "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>min_max<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们在编译的时候遇倒如下的错误信息。这个错误与<code>std::iterator_traits</code>有关。这个错误可能在使用其他编译器时，错误信息的格式不同，或者就没有错误。这个错误在clang 5.0.0 (trunk 299766)版本出现。</p>
<p><img src="./C++17 STL Cook book_files/3-2-1.png" alt=""></p>
</li>
<li>
<p>为了修正这个错误，我们需要激活迭代器的迭代功能。之后定义一个<code>num_iterator</code>结构体，我们会对<code>std::iterator_traits</code>进行特化。这个特化就是告诉STL我们的<code>num_iterator</code>是一种前向迭代器，并且指向的对象是<code>int</code>类型的值。</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-namespace">namespace</span> std <span class="token punctuation">{</span>
<span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>num_iterator<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-using">using</span> iterator_category <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>forward_iterator_tag<span class="token punctuation">;</span>
    <span class="token keyword keyword-using">using</span> value_type <span class="token operator">=</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><ol start="8">
<li>
<p>让我们再对程序进行编译，之前的错误应该不存在了。输出了范围内的最大值和最小值:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token number">100</span> <span class="token operator">-</span> <span class="token number">109</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>一些STL算法需要知道其处理容器的迭代器类型，有些还需要知道迭代器所指向的类型。这就是要有不同实现的原因。</p>
<p>不过，所有STL算法将会通过<code>std::iterator_traits&lt;my_iterator&gt;</code>访问对应类型的迭代器(这里假设迭代器类型为my_iterator)。这个特性类需要包含五种不同类型的成员定义：</p>
<ul>
<li>difference_type: <code>it1- it2</code>结果的类型</li>
<li>value_type: 迭代器解引用的数据的类型(这里需要注意void类型)</li>
<li>pointer: 指向元素指针的类型</li>
<li>reference: 引用元素的类型</li>
<li>iterator_category: 迭代器属于哪种类型</li>
</ul>
<p>pointer、reference和difference_type并没有在num_iterator中定义，因为其实际的内存值不重复(我们只是返回int值，不想数组一样是连续的)。因此num_iterator并不需要定义这些类型，因为算法是依赖于解引用后指定内存上的值。如果我们的迭代器定义了这些类型，就可能会出现问题。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>C++17标准之前，C++都鼓励自定义迭代器继承于<code>std::iterator&lt;...&gt;</code>，这样所有主流的类型都会自动定义。C++17中这条建议仍然能工作，但是不再推荐从<code>std::iterator&lt;...&gt;</code>继承了。</p>
</div></div><div id="ebook-heading-x4f7fx7528x8fedx4ee3x9002x914dx5668x586bx5145x901ax7528x6570x636ex7ed3x6784" ebook-toc-level-2="" heading="使用迭代适配器填充通用数据结构"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E9%80%82%E9%85%8D%E5%99%A8%E5%A1%AB%E5%85%85%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">使用迭代适配器填充通用数据结构</h1>

<p>大多数情况下，我们想要用数据来填充任何容器，不过数据源和容器却没有通用的接口。这种情况下，我们就需要人工的去编写算法，将相应的数据推入容器中。不过，这会分散我们解决问题的注意力。</p>
<p>不同数据结构间的数据传递现在可以只通过一行代码就完成，这要感谢STL中的<strong>迭代适配器</strong>。本节会展示如何使用迭代适配器。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们使用一些迭代器包装器，展示如何使用包装器，并了解其如何在编程任务中给予我们帮助。</p>
<ol>
<li>
<p>包含必要的头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;deque&gt;</span></span>
</pre></li>
<li>
<p>声明使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>开始使用<code>std::istream_iterator</code>。这里我们特化为<code>int</code>类型。这样，迭代器就能将标准输入解析成整数。例如，当我们遍历这个迭代器，其就和<code>std::vector&lt;int&gt;</code>一样了。<code>end</code>迭代器的类型没有变化，但不需要构造参数:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    istream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> it_cin <span class="token punctuation">{</span>cin<span class="token punctuation">}</span><span class="token punctuation">;</span>
    istream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> end_cin<span class="token punctuation">;</span>
</pre></li>
<li>
<p>接下来，我们实例化一个<code>std::deque&lt;int&gt;</code>，并且将标准输入中的所有数字拷贝到队列中。队列本身不是一个迭代器，所以我们使用<code>std::back_inserter</code>辅助函数将队列包装入<code>std::back_insert_iterator</code>中。这样指定的迭代器就能执行<code>v.pack_back(item)</code>，将标准输入中的每个元素放入容器中。这样就能让队列自动增长。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    deque<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
    <span class="token function">copy</span><span class="token punctuation">(</span>it_cin<span class="token punctuation">,</span> end_cin<span class="token punctuation">,</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
</pre></li>
<li>
<p>接下来，我们使用<code>std::istringstream</code>将元素拷贝到队列中部。先使用字符串，来定义一个字符流的实例：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	istringstream sstr <span class="token punctuation">{</span><span class="token string">"123 456 789"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们需要选择列表的插入点。这个点必须在中间，我们使用队列的起始指针，然后使用<code>std::next</code>函数将其指向中间位置。函数第二个参数的意思就是让指针前进多少，这里选择<code>v.size() / 2</code>步，也就是队列的正中间位置(这里我们将<code>v.size()</code>强转为<code>int</code>类型，因为<code>std::next</code>第二个参数类型为<code>difference_type</code>，是和第一个迭代器参数间的距离。因此，该类型是个有符号类型。根据编译选项，如果我们不进行显式强制转化，编译器可能会报出警告)。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">deque_middle</span> <span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>
    	 <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，我们可以从输入流中一步步的拷贝整数到队列当中。另外，流的<code>end</code>包装迭代器为空的<code>std::istream_iterator&lt;int&gt;</code>。这个队列已经被包装到一个插入包装器中，也就是成为<code>std::insert_iterator</code>的一个实例，其指向队列中间位置的迭代器，我们用<code>deque_middle</code>表示:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">copy</span><span class="token punctuation">(</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>sstr<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">inserter</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> deque_middle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，让我们使用<code>std::front_insert_iterator</code>插入一些元素到队列中部：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> il2 <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>il2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>il2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">front_inserter</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>最后一步将队列中的全部内容打印出来。<code>std::ostream_iterator</code>作为输出迭代器，在我们的例子中其就是从<code>std::cout</code>拷贝打印出的信息，并将各个元素使用逗号隔开：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行，即有如下的输出。你能找到那些数字是由哪行的代码插入的吗？</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ echo <span class="token string">"1 2 3 4 5"</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>main
<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">456</span><span class="token punctuation">,</span> <span class="token number">789</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节我们使用了很多不同类型的迭代适配器。他们有一点是共同的，会将一个对象包装成迭代器。</p>
<p><strong>std::back_insert_iterator</strong></p>
<p><code>back_insert_iterator</code>可以包装<code>std::vector</code>、<code>std::deque</code>、<code>std::list</code>等容器。其会调用容器的<code>push_back</code>方法在容器最后插入相应的元素。如果容器实例不够长，那么容器的容量会自动增长。</p>
<p><strong>std::front_insert_iterator</strong></p>
<p><code>front_insert_iterator</code>和<code>back_insert_iterator</code>一样，不过<code>front_insert_iterator</code>调用的是容器的<code>push_front</code>函数，也就是在所有元素前插入元素。这里需要注意的是，当对类似于<code>std::vector</code>的容器进行插入时，其已经存在的所有元素都要后移，从而空出位置来放插入元素，这会对性能造成一定程度的影响。</p>
<p><strong>std::insert_iterator</strong></p>
<p>这个适配器与其他插入适配器类似，不过能在容器的中间位置插入新元素。使用<code>std::inserter</code>包装辅助函数需要两个参数。第一个参数是容器的实例，第二个参数是迭代器指向的位置，就是新元素插入的位置。</p>
<p><strong>std::istream_iterator</strong></p>
<p><code>istream_iterator</code>是另一种十分方便的适配器。其能对任何<code>std::istream</code>使用(文件流或标准输入流)，并且可以根据实例的具体特化类型，对流进行分析。本节中，我们使用了<code>std::istram_iterator&lt;int&gt;(std::cin)</code>，其会将整数从标准输入中拉出来。</p>
<p>通常，对于流来说，其长度我们是不知道的。这就存在一个问题，也就是<code>end</code>迭代器指向的位置在哪里？对于流迭代器来说，它就知道相应的<code>end</code>迭代器的位置。这样就使得迭代器的比较更加高效，不需要通过遍历来完成。这样就是为什么<code>end</code>流迭代器不需要传入任何参数的原因。</p>
<p><strong>std::ostream_iterator</strong></p>
<p><code>ostream_iterator</code>和<code>istream_iterator</code>类似，不过是用来进行输出的流迭代器。与<code>istream_iterator</code>不同在于，构造时需要传入两个参数，且第二个参数必须要是一个字符串，这个字符串将会在各个元素之后，推入输出流中。这样我们就能很容易的在元素中间插入逗号或者换行的符号，以便用户进行观察。</p>
</div></div><div id="ebook-heading-x4f7fx7528x8fedx4ee3x5668x5b9ex73b0x7b97x6cd5" ebook-toc-level-2="" heading="使用迭代器实现算法"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95">使用迭代器实现算法</h1>

<p>迭代器通常根据指向位置的移动，来遍历容器中的元素，但不需要迭代对应的数据类型。迭代器也会被用来实现算法，其可以通过<code>++it</code>指向下一个元素，并且通过<code>*it</code>解引用得到对应的值。</p>
<p>本节中，我们将用迭代器来实现斐波那契函数。斐波那契函数会有类似如下的迭代：<code>F(n) = F(n - 1) + F(n - 2)</code>。数列的初始值<code>F(0) = 0</code>和 <code>F(1) = 1</code>。这样下列序列就可以进行计算：</p>
<ul>
<li>F(0) = 0</li>
<li>F(1) = 1</li>
<li>F(2) = F(1) + F(0) = 1</li>
<li>F(3) = F(2) + F(1) = 2</li>
<li>F(4) = F(3) + F(2) = 3</li>
<li>F(5) = F(4) + F(3) = 5</li>
<li>F(6) = F(5) + F(4) = 8</li>
<li>...</li>
</ul>
<p>我们要实现一个函数，可以输出斐波那契第n个数的值。通常我们都会使用函数迭代，或者是循环来实现这个函数。这样的话，我们只能一个个的将相应的值算出来，然后才能计算出下一个值。这里我们有两个选择——递归调用斐波那契函数计算整个数列，这样很浪费计算时间，或者将最后两个斐波那契数作为临时变量，并用它们来计算下一个数。第二种方法我们需要重新实现斐波那契算法循环。这样我们就可以将斐波那契数列计算的代码和我们实际的代码放在一起：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">size_ta<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
size_tb<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span>size_ti<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> N<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
    constsize_told_b<span class="token punctuation">{</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span>
    b<span class="token operator">+=</span>a<span class="token punctuation">;</span>
    a<span class="token operator">=</span>old_b<span class="token punctuation">;</span>
    <span class="token comment">// do something with b, which is the current fibonacci number</span>
<span class="token punctuation">}</span>
</pre><p>使用迭代器实现斐波那契数列是一件很有意思的事情。如何将循环中的迭代，使用迭代器的前向自加操作来代替呢？其实很简单，让我们来看一下。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们主要关注如何用一个迭代器实现生成斐波那契数列。</p>
<ol>
<li>
<p>为了打印斐波那契数列在终端，我们需要包含标准输入输出流头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
</pre></li>
<li>
<p>我们调用斐波那契迭代器——<code>fibit</code>。其会指向一个值<code>i</code>，其保存的值为斐波那契数列对应的位置，<code>a</code>和<code>b</code>保存斐波那契数列中最后两个值。实例化迭代器时，需要将斐波那契迭代器初始化为<code>F(0)</code>的值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">fibit</span>
<span class="token punctuation">{</span>
    size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    size_t a <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    size_t b <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>下一步，定义标准构造函数和另一个构造函数用来初始化迭代器。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">fibit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-default">default</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-explicit">explicit</span> <span class="token function">fibit</span><span class="token punctuation">(</span>size_t i_<span class="token punctuation">)</span>
        <span class="token operator">:</span> i<span class="token punctuation">{</span>i_<span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre></li>
<li>
<p>当我们对迭代器解引用时，迭代器将返回对应位置的数值。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	size_t <span class="token keyword keyword-operator">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre></li>
<li>
<p>当移动迭代器<code>++</code>时，其会移动到下一个斐波那契数上。这里的实现与基于循环的实现几乎是一样的。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    fibit<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-const">const</span> size_t old_b <span class="token punctuation">{</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span>
        b <span class="token operator">+=</span> a<span class="token punctuation">;</span>
        a <span class="token operator">=</span> old_b<span class="token punctuation">;</span>
        <span class="token operator">++</span>i<span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
</pre></li>
<li>
<p>当使用循环时，增加后的迭代器将会和<code>end</code>迭代器进行比较，所以这里需要为迭代器实现不等于<code>!=</code>操作符。我们只比较当且迭代器所对应的步数，这比循环1000000次再结束迭代器简单许多，这样我们就不需要计算太多的斐波那契数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-bool">bool</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> fibit <span class="token operator">&amp;</span>o<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i <span class="token operator">!=</span> o<span class="token punctuation">.</span>i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了能让斐波那契迭代器适应<code>for</code>循环的范围写法，我们需要实现一个范围类。我们称这个类为<code>fib_range</code>，其构造函数只需要一个参数，这个参数能够告诉我们我们想要遍历的范围：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">fib_range</span>
<span class="token punctuation">{</span>
	size_t end_n<span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">fib_range</span><span class="token punctuation">(</span>size_t end_n_<span class="token punctuation">)</span>
    	<span class="token operator">:</span> end_n<span class="token punctuation">{</span>end_n_<span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre></li>
<li>
<p><code>begin</code>和<code>end</code>函数将会返回对应位置上的迭代器，也就是<code>F(0)</code>和<code>F(end_n)</code>对应的迭代器。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    fibit <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> fibit<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    fibit <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> fibit<span class="token punctuation">{</span>end_n<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>好了，其他与迭代器相关的代码我们就不管了。因为我们辅助类就能很好的帮助我们将这些细节的东西隐藏掉！让我们打印10个斐波那契数字：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">:</span> <span class="token function">fib_range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行后，我们会在终端上看到如下的打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span>
</pre></li>
</ol>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>为了兼容STL中的迭代器，这里实现的迭代器必须支持<code>std::iterator_traits</code>类。想要知道怎么做，要参考一下3.2节(让自己的迭代器与STL的迭代器兼容)，其对如何兼容进行了明确地说明。</p>
<blockquote>
<p>Note：</p>
<p>试着从迭代器的角度思考，这样的代码在很多情况下就显得十分优雅。不用担心性能，编译器会根据模板对迭代器相关的代码进行优化。</p>
</blockquote>
<p>为了保证例子的简洁性，我们并没有对其做任何事情，不过要是作为斐波那契迭代器的发布库的话，其可用性还是比较差的——<code>fibit</code>传入一个参数的构造函数，可以直接使用<code>end</code>迭代器替换，因为<code>fibit</code>并没有包含任何一个合法的斐波那契值，这里的库并不强制使用这种方式。</p>
<p>还有些方面需要进行修复：</p>
<ul>
<li>
<p>将<code>fibit(size_t i_)</code>声明为私有构造函数，并在<code>fibit</code>类中将<code>fib_range</code>类声明为一个友元类。这样用户就只能使用正确的方式进行迭代了。</p>
</li>
<li>
<p>可以使用迭代器哨兵，避免用户引用<code>end</code>迭代器。可以参考一下3.6节(使用哨兵终止迭代)中内容，以获得更多信息。</p>
</li>
</ul>
</div></div><div id="ebook-heading-x4f7fx7528x53cdx5411x8fedx4ee3x9002x914dx5668x8fdbx884cx8fedx4ee3" ebook-toc-level-2="" heading="使用反向迭代适配器进行迭代"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E9%80%82%E9%85%8D%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3">使用反向迭代适配器进行迭代</h1>

<p>有时我们需要反向迭代一个范围内的内容。基于范围的for循环中，STL迭代通常都使用前向累加的方式进行迭代，那么当需要反向时，就需要对其进行递减。当然，这里可以将迭代器进行包装，将调用累加操作改为递减的操作。听起来要写好多冗余的代码，来对反向迭代进行支持。</p>
<p>STL中提供了反向迭代适配器，其能帮助我们对迭代器进行包装。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将用另一种方式使用反向迭代器，只为了展示如何使用它们：</p>
<ol>
<li>
<p>包含必要的头文件：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
</pre></li>
<li>
<p>声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了有东西可以迭代，我们实例化一个整数列表：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> l <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，让我们来反向打印这些数字。为了完成反向打印，我们调用<code>std::list</code>的成员函数<code>rbegin</code>和<code>rend</code>获得反向迭代器，并且将数字推入输出流<code>ostream_iterator</code>适配器中:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">copy</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>如果容器不提供<code>rbegin</code>和<code>rend</code>函数的话，就需要使用双向迭代器来帮忙了，这里可以使用工厂函数<code>std::make_reverse_iterator</code>创建双向迭代器。其能接受普通迭代器，然后将其转换为反向迭代器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">make_reverse_iterator</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">make_reverse_iterator</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行该程序，就能得到如下的输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>为了将一个普通迭代器转换为一个反向迭代器，容器至少要支持双向迭代。这就需要双向类别或更高级的迭代器才能满足条件。</p>
<p>反向迭代器是普通迭代器的一种，并且连接口和普通迭代器都一样，不过其累加操作会被当做递减操作来进行。</p>
<p>下面就来聊一下<code>begin</code>和<code>end</code>迭代器的位置。先来看一下图，迭代器区域里面是一串标准的数字序列。</p>
<p><img src="./C++17 STL Cook book_files/3-5-1.png" alt=""></p>
<p>如果序列是从1到5，<code>begin</code>迭代器将指向元素1所在的位置，并且<code>end</code>迭代器将指向元素5后面的位置。当定义了反向迭代器，<code>rbegin</code>迭代器就指向了元素5，并且<code>rend</code>迭代器指向元素1之前的位置。可以将书反过来看，可以发现这两个中方式是镜像的。</p>
<p>当我们想让我们自定义的容器类支持反向迭代，我们不用将所有细节一一实现；我们只需使用<code>std::make_reverse_iterator</code>工厂函数，将普通的迭代器包装成反向迭代器即可，背后的操作STL会帮我们完成。</p>
</div></div><div id="ebook-heading-x4f7fx7528x54e8x5175x7ec8x6b62x8fedx4ee3" ebook-toc-level-2="" heading="使用哨兵终止迭代"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E5%93%A8%E5%85%B5%E7%BB%88%E6%AD%A2%E8%BF%AD%E4%BB%A3">使用哨兵终止迭代</h1>

<p>对于STL算法和基于范围的for循环来说，都会假设迭代的位置是提前知道的。在有些情况下，并不是这样，我们在迭代器到达末尾之前，我们是很难确定结束的位置在哪里。</p>
<p>这里使用C风格的字符串来举例，我们在编译时无法知道字符串的长度，只能在运行时使用某种方法进行判断。字符串遍历的代码如下所示：</p>
<pre data-role="codeBlock" data-info="c" class="language-c"><span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>c_ponter <span class="token operator">=</span> some_c_string<span class="token punctuation">;</span> <span class="token operator">*</span>c_pointer <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> <span class="token operator">++</span>c_pointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> c <span class="token operator">=</span> <span class="token operator">*</span>c_pointer<span class="token punctuation">;</span>
    <span class="token comment">// do something with c</span>
<span class="token punctuation">}</span>
</pre><p>对于基于范围的for循环来说，我们可以将这段字符串包装进一个<code>std::string</code>实例中，<code>std::string</code>提供<code>begin()</code>和<code>end()</code>函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> c <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span>some_c_string<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* do something with c */</span> <span class="token punctuation">}</span>
</pre><p>不过，<code>std::string</code>在构造的时候也需要对整个字符串进行遍历。C++17中加入了<code>std::string_view</code>，但在构造的时候也会对字符串进行一次遍历。对于比较短的字符串来说这是没有必要的，不过对于其他类型来说就很有必要。<code>std::istream_iterator</code>可以用来从<code>std::cin</code>捕获输入，当用户持续输入的时候，其<code>end</code>迭代器并不能指向输入字符串真实的末尾。</p>
<p>C++17添加了一项新的特性，其不需要<code>begin</code>迭代器和<code>end</code>迭代器是同一类型的迭代器。本节我们看看，这种小修改的大用途。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将在范围类中构造一个迭代器，其就不需要知道字符串的长度，也就不用提前找到字符串结束的位置。</p>
<ol>
<li>
<p>包含必要的头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span> </span>
</pre></li>
<li>
<p>迭代器哨兵是本节的核心内容。奇怪的是，它的定义完全是空的。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">cstring_iterator_sentinel</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们先来实现迭代器。其包含一个字符串指针，指针指向的容器就是我们要迭代的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">cstring_iterator</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s <span class="token punctuation">{</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>构造函数只是初始化内部字符串指针，对应的字符串是外部输入。显式声明构造函数是为了避免字符串隐式转换为字符串迭代器:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-explicit">explicit</span> <span class="token function">cstring_iterator</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
    	<span class="token operator">:</span> s<span class="token punctuation">{</span>str<span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre></li>
<li>
<p>当对迭代器进行解引用，其就会返回对应位置上的字符：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-char">char</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token operator">*</span>s<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre></li>
<li>
<p>累加迭代器只增加迭代器指向字符串的位置：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cstring_iterator<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>s<span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>这一步是最有趣的。我们为了比较，实现了<code>!=</code>操作符。不过，这次我们不会去实现迭代器的比较操作，这次迭代器要和哨兵进行比较。当我们比较两个迭代器时，在当他们指向的位置相同时，我们可以认为对应范围已经完成遍历。通过和空哨兵对象比较，当迭代器指向的字符为<code>\0</code>字符时，我们可以认为到达了字符串的末尾。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-bool">bool</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> cstring_iterator_sentinel<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> s <span class="token operator">!=</span> <span class="token keyword keyword-nullptr">nullptr</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>s <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了使用基于范围的<code>for</code>循环，我们需要一个范围类，用来指定<code>begin</code>和<code>end</code>迭代器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">cstring_range</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s <span class="token punctuation">{</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>实例化时用户只需要提供需要迭代的字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">cstring_range</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
    	<span class="token operator">:</span> s<span class="token punctuation">{</span>str<span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre></li>
<li>
<p><code>begin()</code>函数将返回一个<code>cstring_iterator</code>迭代器，其指向了字符串的起始位置。<code>end()</code>函数会返回一个哨兵类型。需要注意的是，如果不使用哨兵类型，这里将返回一个迭代器，这个迭代器要指向字符串的末尾，但是我们无法预知字符串的末尾在哪里。</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cstring_iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
   		<span class="token keyword keyword-return">return</span> cstring_iterator<span class="token punctuation">{</span>s<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cstring_iterator_sentinel <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><ol start="11">
<li>
<p>类型定义完，我们就来使用它们。例子中字符串是用户输入，我们无法预知其长度。为了让使用者给我们一些输入，我们的例子会判断是否有输入参数。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please provide one parameter.\n"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>当程序运行起来时，我们就知道<code>argv[1]</code>中包含的是使用者的字符串。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> c <span class="token operator">:</span> <span class="token function">cstring_range</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</pre></li>
<li>
<p>编译运行程序，就能得到如下的输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>main <span class="token string">"abcdef"</span>
abcdef
</pre></li>
</ol>
<p>循环会将所有的字符打印出来。这是一个很小的例子，只是为了展示如何使用哨兵确定迭代的范围。当在无法获得<code>end</code>迭代器的位置时，这是一种很有用的方法。当能够获得<code>end</code>迭代器时，就不需要使用哨兵了。</p>
</div></div><div id="ebook-heading-x4f7fx7528x68c0x67e5x8fc7x7684x8fedx4ee3x5668x81eax52a8x5316x68c0x67e5x8fedx4ee3x5668x4ee3x7801" ebook-toc-level-2="" heading="使用检查过的迭代器自动化检查迭代器代码"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E6%A3%80%E6%9F%A5%E8%BF%87%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A3%80%E6%9F%A5%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%A3%E7%A0%81">使用检查过的迭代器自动化检查迭代器代码</h1>

<p>迭代器很有用，能提供一般化的接口供用户使用。不过，迭代器经常被当做指针误用。当指针指向一个非法的内存位置时，不能进行解引用。这对迭代器也适用，不过有大量的条件来界定迭代器指向的位置是否合法。这些可以通过看一下STL文档就能了解到，但是还会写出很容易出现bug的代码。</p>
<p>最好的情况是，这些问题没有在客户的机器上出现，而是开发者测试这些程序时就能暴露出来。不过，通常即使是解引用了悬垂指针和错误的迭代器，代码也不会报错。这种情况是最糟的，因为这种未定义行为的代码，没法确定会发生什么。</p>
<p>幸运的是，有工具可以帮助我们。GUN STL有调试模式可选，GUN C++编译器和LLVM clang C++编译器都提供这样的库，其会为我们生成具有调试信息的二进制程序，可以让错误更容易暴露出来。这种库非常容易使用，并且特别有用，我们将在本节展示。Microsoft Visual C++标准库还提供了更多的检查项。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节我们将使用迭代器故意访问一个非法位置：</p>
<ol>
<li>
<p>包含头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
</pre></li>
<li>
<p>首先实例化一个整型类<code>vector</code>，并且让指针指向值1。我们使用<code>shrink_to_fit()</code>将<code>vector</code>的容积设置为3，多分配的内存是不必要的，小一点的存储空间会让迭代速度更快：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">shrink_to_fit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">it</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后解引用迭代器，打印相应的内容：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>接下来，让我们向<code>vector</code>中增加一个新数。这样<code>vector</code>的长度就不够再放下另外一个数，这里<code>vector</code>会自动增加其长度。通过分配一个新的更大的内存块来实现长度的增加，会将所有现存的项移到新的块，然后删除旧的内存块。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，让我们再次通过迭代器从1开始打印<code>vector</code>。这就坏了。为什么呢？因为在<code>vector</code>自增的过程中，会分配新的内存，删除旧的内存，但是迭代器却不知道这个改变。这就意味着，迭代器将会指向旧地址，并且我们不知道这样做会怎样。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token comment">// bad bad bad!</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译变这个程序并运行，我们不会看到任何错误，不过迭代器解引用所打印出来的数字看上去像是随机数。看上去没有问题，反而最有问题。如果不指出来，可能没人会发现问题。</p>
</li>
</ol>
<p><img src="./C++17 STL Cook book_files/3-7-1.png" alt=""></p>
<ol start="7">
<li>
<p>这时调试工具就派上了用场。GUN STL支持一种预处理宏<code>_GLIBCXX_DEBUG</code>，其会激活STL中对健壮性检查的代码。这会让程序变慢，不过更容易找到Bug。我们可以通过<code>-D_GLIBCXX_DEBUG</code>编译选项来启用这些代码，或者在代码的最开始加上这个宏。如你所见，其输出相关的错误信息，并关闭了应用的进程。Microsoft Visual C++ 编译器可以通过<code>/D_ITERATOR_DEBUG_LEVEL=1</code>启用检查。</p>
<p><img src="./C++17 STL Cook book_files/3-7-2.png" alt=""></p>
</li>
<li>
<p>LLVM/clang实现的STL也有调试标识，其目的是为了调试STL代码，而非用户的代码。对于用户的代码的调试，我们会使用不同的选项来调试。向clang编译器传入<code>-fsanitize=address -fsanitize=undefined</code>，可以看看会发生什么：</p>
</li>
</ol>
<p><img src="./C++17 STL Cook book_files/3-7-3.png" alt=""></p>
<p>WOW！clang编译器对于运行错误的描述非常详细。由于信息非常的多，这里只截取其中一部分。当然，这个选项并不是clang独有的特性，对于GCC同样适用。</p>
<blockquote>
<p>Note:</p>
<p>一些运行时的问题是因为一些库的丢失，编译器不会将libasan和libubsan( AddressSanitizer内存检测工具)自动添加到程序中，需要通过包管理器或类似的工具进行安装。</p>
</blockquote>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>如我们之前所见，我们不需要通过修改任何代码，只需要通过为编译器添加一些编译器特性就能容易的找到代码中的Bug。</p>
<p>这些特性由调试器实现。一个调试器通常由一个编译器模块和一个运行时库组成。当调试器被激活时，编译器将会添加额外的信息到我们的代码中，然后形成二进制可执行文件。在运行时，调试器库由二进制文件自己去链接，例如：对应库实现会代替<code>malloc</code>和<code>free</code>函数，来分析程序到底想要多少内存。</p>
<p>调试器可以检测不同类型的Bug。这里只列举出一些常用的类型：</p>
<ul>
<li><strong>越界访问</strong>: 当我们访问类似数组和<code>vector</code>类型的数据结构时，判别我们访问的位置是否在合法范围内。</li>
<li><strong>释放后使用</strong>: 当我们释放了堆上分配的指针后，再使用这个指针，则会出发这个Bug。</li>
<li><strong>整数溢出</strong>: 不同的机器上整数表达的范围可能是不同的，所以就会出现一些值使用整型无法进行表示。对于有符号整型，算法通常会出发一个未定义的行为。</li>
<li><strong>指针对齐</strong>: 一些架构中，需要指针以某种形式进行对齐，否则无法访问对应的地址。</li>
</ul>
<p>当然，我们还能检测到更多类型的Bug。</p>
<p>不过，激活所有的调试器不太可行，因为这样会导致程序运行的非常缓慢。不过，在单元测试和集成测试中，激活调试器是一个很好的方式。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>对于不同类型的Bug，调试器的种类也是多种多样，并且还有很多调试器还在开发中。我们可以上网了解更多的信息，以便我们自己去调试程序。GCC和LLVM网站首页就列举了很多调试器，可以从在线文档中了解其调试能力：</p>
<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html">https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html</a></li>
<li><a href="http://clang.llvm.org/docs/index.html">http://clang.llvm.org/docs/index.html</a> 可在目录中寻找调试器</li>
</ul>
<p>使用调试器对程序进行整体测试是每个开发者都应该具有的意识。不过，在大多数公司中，开发者并没有这样的意识，即便是我们知道所有恶意软件和计算机病毒最重要的入口就是程序的Bug。</p>
<p>当时是一个开发新手时，看一下你的团队中是否有使用调试器的可能。如果没有，那你上班的第一天就有机会修复那些重大的Bug，并发现隐藏的Bug。</p>
</div></div><div id="ebook-heading-x6784x5efazipx8fedx4ee3x9002x914dx5668" ebook-toc-level-2="" heading="构建zip迭代适配器"><div><h1 class="mume-header" id="%E6%9E%84%E5%BB%BAzip%E8%BF%AD%E4%BB%A3%E9%80%82%E9%85%8D%E5%99%A8">构建zip迭代适配器</h1>

<p>不同的编程语言引领了不同的编程方式。不同语言有各自的受众群体，因为表达方式的不同，所以对于优雅地定义也不同。</p>
<p>纯函数式编程算是编程风格中一种比较特别的方式。其与C和C++命令方式编程的风格大相径庭。虽然风格迥异，但是纯函数式编程却能在大多数情况下产生非常优雅地代码。</p>
<p>这里用向量点乘为例，使用函数式方法优雅地实现这个功能。给定两个向量，然后让对应位置上的两个数字相乘，然后将所有数字加在一起。也就是<code>(a, b, c) * (d, e, f)</code>的结果为<code>(a * e + b * e + c * f)</code>。我们在C和C++也能完成这样的操作。代码可能类似如下的方式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> a <span class="token punctuation">{</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> b <span class="token punctuation">{</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">,</span> <span class="token number">6.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-double">double</span> sum <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	sum <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// sum = 32.0</span>
</pre><p>如何使用其他语言让这段代码更优雅呢？</p>
<p>Haskell是一种纯函数式语言，其使用一行代码就能计算两个向量的点积：</p>
<p><img src="./C++17 STL Cook book_files/3-8-1.png" alt=""></p>
<p>Python虽然不是纯函数式编程语言，但是也会提供类似功能：</p>
<p><img src="./C++17 STL Cook book_files/3-8-2.png" alt=""></p>
<p>STL提供了相应的函数实现<code>std::inner_product</code>，也能在一行之内完成向量点积。不过，其他语言中在没有相应的库对某种操作进行支持的情况下，也能做到在一行之内完成。</p>
<p>不需要对两种语言的语法进行详细了解的情况下，大家都应该能看的出，两个例子中最重要的就是zip函数。这个函数做了什么？假设我们有两个向量a和b，变换后将两个向量混合在一起。例如：<code>[a1, a2, a3]</code>和<code>[b1, b2, b3]</code>，使用zip函数处理的结果为<code>[(a1, b1), (a2, b2), (a3, b3)]</code>。让我们仔细观察这个例子，就是将两个向量连接在了一起。</p>
<p>现在，关联的数字可以直接进行加法，然后累加在一起。在Haskell和Python的例子中我们看到，这个过程不需要任何循环或索引变量。[译者注：Python中是有循环的……]</p>
<p>这里没法让C++代码如同Haskell或Python那样优雅和通用，不过本节的内容就是为了实现一个类似的迭代器——zip迭代器——然后使用这个迭代器。向量点积有特定的库支持，至于是哪些库，以及这些库如何使用，并不在本书的描述范围内。不过，本节的内容将尝试展示一种基于迭代器的方式，来帮助你使用通用的模块另外完成编程。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们会实现一个类似Haskell和Python中的zip函数。为了不对迭代器的机制产生影响，<code>vector</code>中的变量这里写死为<code>double</code>：</p>
<ol>
<li>
<p>包含头文件</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span>
</pre></li>
<li>
<p>定义<code>zip_iterator</code>类。同时也要实现一个范围类<code>zip_iterator</code>，这样我们在每次迭代时就能获得两个值。这也意味着我们同时遍历两个迭代器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">zip_iterator</span> <span class="token punctuation">{</span>
</pre></li>
<li>
<p>zip迭代器的容器中需要保存两个迭代器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-using">using</span> it_type <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator<span class="token punctuation">;</span>

	it_type it1<span class="token punctuation">;</span>
	it_type it2<span class="token punctuation">;</span>
</pre></li>
<li>
<p>构造函数会将传入的两个容器的迭代器进行保存，以便进行迭代：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">zip_iterator</span><span class="token punctuation">(</span>it_type iterator1<span class="token punctuation">,</span> it_type iterator2<span class="token punctuation">)</span>
    	<span class="token operator">:</span> it1<span class="token punctuation">{</span>iterator1<span class="token punctuation">}</span><span class="token punctuation">,</span> it2<span class="token punctuation">{</span>iterator2<span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre></li>
<li>
<p>增加zip迭代器就意味着增加两个成员迭代器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    zip_iterator<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>it1<span class="token punctuation">;</span>
        <span class="token operator">++</span>it2<span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>如果zip中的两个迭代器来自不同的容器，那么他们一定不相等。通常，这里会用逻辑或(||)替换逻辑与(&amp;&amp;)，但是这里我们需要考虑两个容器长度不一样的情况。这样的话，我们需要在比较的时候同时匹配两个容器。这样，我们就能遍历完其中一个容器时，及时停下循环：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-bool">bool</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> zip_iterator<span class="token operator">&amp;</span> o<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> it1 <span class="token operator">!=</span> o<span class="token punctuation">.</span>it1 <span class="token operator">&amp;&amp;</span> it2 <span class="token operator">!=</span> o<span class="token punctuation">.</span>it2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>逻辑等操作符可以使用逻辑不等的操作符的实现，是需要将结果取反即可：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-bool">bool</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> zip_iterator<span class="token operator">&amp;</span> o<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token operator">!</span><span class="token keyword keyword-operator">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>解引用操作符用来访问两个迭代器指向的值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token operator">*</span>it1<span class="token punctuation">,</span> <span class="token operator">*</span>it2<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>迭代器算是实现完了。我们需要让迭代器兼容STL算法，所以我们对标准模板进行了特化。这里讲迭代器定义为一个前向迭代器，并且解引用后返回的是一对<code>double</code>值。虽然，本节我们没有使用<code>difference_type</code>，但是对于不同编译器实现的STL可能就需要这个类型：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-namespace">namespace</span> std <span class="token punctuation">{</span>
<span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span>zip_iterator<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-using">using</span> iterator_category <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>forward_iterator_tag<span class="token punctuation">;</span>
    <span class="token keyword keyword-using">using</span> value_type <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-using">using</span> difference_type <span class="token operator">=</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在来定义范围类，其<code>begin</code>和<code>end</code>函数返回<code>zip</code>迭代器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">zipper</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-using">using</span> vec_type <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    vec_type <span class="token operator">&amp;</span>vec1<span class="token punctuation">;</span>
    vec_type <span class="token operator">&amp;</span>vec2<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>这里需要从zip迭代器中解引用两个容器中的值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">zipper</span><span class="token punctuation">(</span>vec_type <span class="token operator">&amp;</span>va<span class="token punctuation">,</span> vec_type <span class="token operator">&amp;</span>vb<span class="token punctuation">)</span>
    	<span class="token operator">:</span> vec1<span class="token punctuation">{</span>va<span class="token punctuation">}</span><span class="token punctuation">,</span> vec2<span class="token punctuation">{</span>vb<span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre></li>
<li>
<p><code>begin</code>和<code>end</code>函数将返回指向两容器开始的位置和结束位置的迭代器对：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    zip_iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>vec1<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>vec2<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    zip_iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
   		<span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span><span class="token function">end</span><span class="token punctuation">(</span>vec1<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">end</span><span class="token punctuation">(</span>vec2<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>如Haskell和Python的例子一样，我们定义了两个<code>double</code>为内置类型的<code>vector</code>。这里我们也声明了所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> a <span class="token punctuation">{</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> b <span class="token punctuation">{</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">,</span> <span class="token number">6.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>可以直接使用两个<code>vector</code>对<code>zipper</code>类进行构造：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	zipper zipped <span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将使用<code>std::accumulate</code>将所有值累加在一起。这里我们不能直接对<code>std::pair&lt;double, double&gt;</code>实例的结果进行累加，因为这里没有定义<code>sum</code>变量。因此，我们需要定义一个辅助Lambda函数来对这个组对进行操作，将两个数相乘，然后进行累加。Lambda函数指针可以作为<code>std::accumulate</code>的一个参数传入：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">add_product</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span> sum<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> sum <span class="token operator">+</span> p<span class="token punctuation">.</span>first <span class="token operator">*</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，让我们来调用<code>std::accumulate</code>将所有点积的值累加起来：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">dot_product</span> <span class="token punctuation">(</span><span class="token function">accumulate</span><span class="token punctuation">(</span>
    	<span class="token function">begin</span><span class="token punctuation">(</span>zipped<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>zipped<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> add_product<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>最后，让我们来打印结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> dot_product <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行后，得到正确的结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token number">32</span>
</pre></li>
</ol>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>OK，这里使用了语法糖来完成了大量的工作，不过这和Haskell的例子也相差很远，还不够优雅。我们的设计中有个很大的缺陷，那就是只能处理<code>double</code>类型的数据。通过模板代码和特化类，<code>zipper</code>类会变得更通用。这样，我们就能将<code>list</code>和<code>vector</code>或<code>deque</code>和<code>map</code>这样不相关的容器合并起来。</p>
<p>为了让设计的类更加通用，其中设计的过程是不容忽视的。幸运的是，这样的库已经存在。Boost作为STL库的先锋，已经支持了<code>zip_iterator</code>。这个迭代器非常简单、通用。</p>
<p>顺便提一下，如果你想看到了使用C++实现的更优雅的点积，并且不关心<code>zip</code>迭代器相关的内容，那么你可以了解一下<code>std::valarray</code>。例子如下，自己看下：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;valarray&gt;</span></span>
<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>valarray<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> a <span class="token punctuation">{</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>valarray<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> b <span class="token punctuation">{</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">,</span> <span class="token number">6.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p><strong>范围库</strong></p>
<p>这是C++中非常有趣的一个库，其支持<code>zipper</code>和所有迭代适配器、滤波器等等。其受到Boost范围库的启发，并且某段时间内里，很有可能进入C++17标准。不幸的是，我们只能在下个标准中期待这个特性的加入。这种性能可以带来更多的便利，能让我们想表达的东西通过C++快速实现，并可以通过将通用和简单的模块进行组合，来表现比较复杂的表达式。</p>
<p>在文档中对其描述中，有个非常简单的例子：</p>
<ol>
<li>
<p>计算从1到10数值的平方：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>view<span class="token double-colon punctuation">::</span><span class="token function">ints</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
                        <span class="token operator">|</span> view<span class="token double-colon punctuation">::</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> i<span class="token operator">*</span>i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
                        <span class="token operator">|</span> view<span class="token double-colon punctuation">::</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>从数值<code>vector</code>中过滤出非偶数数字，并且将剩下的数字转换成字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-auto">auto</span> rng <span class="token operator">=</span> v <span class="token operator">|</span> view<span class="token double-colon punctuation">::</span><span class="token function">remove_if</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
		    <span class="token operator">|</span> view<span class="token double-colon punctuation">::</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// rng == {"2"s,"4"s,"6"s,"8"s,"10"s};</span>
</pre></li>
</ol>
<p>如果你等不及想要了解这些有趣的特性，可以看一下范围类的文档，<a href="https://ericniebler.github.io/range-v3">https://ericniebler.github.io/range-v3</a> 。</p>
</div></div><div id="ebook-heading-x7b2c4x7ae0-lambdax8868x8fbex5f0f" ebook-toc-level-1="" heading="第4章 Lambda表达式"><div><h1 class="mume-header" id="%E7%AC%AC4%E7%AB%A0-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">第4章 Lambda表达式</h1>

<p>Lambda表达式是C++11添加的非常重要的一个特性。C++14和C++17对Lambda进行补充，使得Lambda表达式如虎添翼。那就先了解一下，什么是Lambda表达式呢？</p>
<p>Lambda表达式或者Lambda函数为闭包结构。闭包是描述未命名对象的通用术语，也可以称为匿名函数。为了在C++中加入这个特性，就需要相应对象实现<code>()</code>括号操作符。C++11之前想要实现类似具有Lambda的对象，代码如下所示：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">name_greeter</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
        
        <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    name_greeter greet_john_doe <span class="token punctuation">{</span><span class="token string">"John Doe"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">greet_john_doe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>构造<code>name_greeter</code>对象需要传入一个字符串。这里需要注意的是，这个结构类型，Lambda可以使用一个没有名字的实例来表示。对于闭包结构来说，我们称之为捕获一个字符串。其就像我们在构造这个例子中的实例时传入的字符串一样，不过Lambda不需要参数，就能完成打印<code>Hello, John Doe</code>。</p>
<p>C++11之后，使用闭包的方式来实现会更加简单：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">greet_john_doe</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, John Doe\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">greet_john_doe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>这样就行了！不再需要<code>name_greeter</code>结构体，直接使用Lambda表达式替代。这看起来像魔术一样，本章的第一节中会对细节进行详细的描述。</p>
<p>Lambda表达式对于完成通用和简介类代码是非常有帮助的。其能对通用的数据结构进行处理，这样就不惧用户指定的特殊类型。闭包结构也会被用来将运行在线程上的数据进行打包。C++11标准推出后，越来越多的库支持了Lambda表达式，因为这对于C++来说已经是很自然的事情了。另一种使用方式是用于元编程，因为Lambda在编译时是可以进行预估的。不过，我们不会往元编程的方向去讲述，元编程的内容可能会撑爆这本书。</p>
<p>本章我们着重于函数式编程，对于那些对函数式编程不了解的开发者或初学者来说，这看起来非常的神奇。如果你在代码中看到Lambda表达式横飞，请先别沮丧。在这个函数式编程越来越流行的年代，需要拓展对于现代C++的了解。如果你看到的代码有点复杂，建议你多花点时间去分析它们。当你驯服了Lambda表达式，你就能驾驭它驰骋疆场，不再会为之困惑。</p>
</div></div><div id="ebook-heading-x4f7fx7528lambdax8868x8fbex5f0fx5b9ax4e49x51fdx6570" ebook-toc-level-2="" heading="使用Lambda表达式定义函数"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">使用Lambda表达式定义函数</h1>

<p>我们可以使用Lambda表达式来包装代码，为了在之后对其进行调用。我们可以像调用函数那样，给Lambda表达式传入不同的参数，从而得到不同的结果，这样我们就不需要在类中实现这个函数了。</p>
<p>C++11标准正式将Lambda语法加入C++，之后的C++14和C++17标准中对Lambda语法进行了升级。本节我们将看到如何使用Lambda表达式，以及其给我们带来的改变。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>现在我们就来使用Lambda表达式完成一个程序，在实践中体验Lambda表达式：</p>
<ol>
<li>
<p>Lambda表达式不需要任何库，不过我们需要将一些字符串打印在屏幕上，所以需要包含必要的的头文件：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
</pre></li>
<li>
<p>这次我们所有内容都会在主函数中完成。我们定义了两个没有参数的函数对象，并且返回整型常量1和2。需要注意的是，返回部分在大括号对<code>{}</code>中，就像普通的函数那样，而小括号<code>()</code>表示没有参数传入，当然也可以像普通函数那样定义函数签名，对于第二个Lambda表达式没有添加小括号对。不过两个表达式都有中括号对<code>[]</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">just_one</span> <span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">just_two</span> <span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>那么现在我们就来调用这两个函数，就像调用普通函数那样：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">just_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">just_two</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，来定义另一个函数对象，其名为plus，因为它要将两个参数进行加和：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">plus</span> <span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> l<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> l <span class="token operator">+</span> r<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>这个函数对象也不难用。使用<code>auto</code>类型定义两个参数，只要是作为参数的实参类型支持加法操作，那么就没有任何问题：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">plus</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>当然，我们可以不使用变量的方式对Lambda表达式进行保存。我们只需要在使用到的地方对其进行定义即可：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    std<span class="token double-colon punctuation">::</span>cout
        <span class="token operator">&lt;&lt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> l<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> l <span class="token operator">+</span> r<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>接下来，我们定义一个闭包，包里面装着一个计数器。当我们调用这个计数器时，其值就会自加，并且会将自加后的值返回。为了对计数变量进行初始化，我们(在中括号对中)对<code>count</code>进行了赋值。为了能让函数对获取的值进行修改，我们使用<code>mutable</code>关键字对函数进行修饰，否则在编译时会出问题：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">counter</span> <span class="token punctuation">(</span>
    	<span class="token punctuation">[</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-mutable">mutable</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token operator">++</span>count<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在让我们调用函数对象5次，并且打印其返回值，观察每次调用后计数器增加后的值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们也可以通过捕获已经存在的变量的引用，在闭包中进行修改。这样的话，捕获到的值会自加，并且在闭包外部也能访问到这个变量。为了完成这个任务，我们在中括号对中写入<code>&amp;a</code>，<code>&amp;</code>符号就意味着捕获的是对应变量的引用，而非副本：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-int">int</span> a <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">incrementer</span> <span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>a<span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token operator">++</span>a<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>如果这样能行，那我们就可以多次的调用这个函数对象，并且直接在外部对a变量的值进行观察：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
	std<span class="token double-colon punctuation">::</span>cout
        <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of 'a' after 3 incrementer() calls: "</span>
        <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><ol start="11">
<li>
<p>最后一个例子是一个多方位展示，这个例子中一个函数对象可以接受参数，并且将其传入另一个函数对象中进行保存。在这个<code>plus_ten</code>函数对象中，我们会调用<code>plus</code>函数对象：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">plus_ten</span> <span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">plus_ten</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</pre></li>
<li>
<p>编译并运行代码，我们将看到如下的内容打印在屏幕上。我们也可以自己计算一下，看看打印的结果是否正确：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span>
<span class="token number">3</span>
ab
<span class="token number">3</span>
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span>
Value of a after <span class="token number">3</span> <span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> calls<span class="token operator">:</span> <span class="token number">3</span>
<span class="token number">15</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>上面的例子并不复杂——添加了数字，并对调用进行计数，并打印计数的结果。甚至用一个函数对象来连接字符串，并用这个函数对象对对应字符串进行计数。不过，这些实现对于对Lambda表达式不太了解的人来说，看着就很困惑了。</p>
<p>所以，先让我们了解一下Lambda表达式的特点：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token punctuation">[</span>capture list<span class="token punctuation">]</span> <span class="token punctuation">(</span>parameters<span class="token punctuation">)</span>
	<span class="token keyword keyword-mutable">mutable</span>			<span class="token punctuation">(</span>optional<span class="token punctuation">)</span>
	<span class="token keyword keyword-constexpr">constexpr</span>		<span class="token punctuation">(</span>optional<span class="token punctuation">)</span>
	exception <span class="token function">attr</span>	<span class="token punctuation">(</span>optional<span class="token punctuation">)</span>
	<span class="token operator">-&gt;</span> <span class="token keyword keyword-return">return</span> <span class="token function">type</span>	<span class="token punctuation">(</span>optional<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	body
<span class="token punctuation">}</span>
</pre><p>Lambda表达式的最短方式可以写为<code>[]{}</code>。其没有参数，没有捕获任何东西，并且也不做实质性的执行。</p>
<p>那么其余的部分是什么意思呢？</p>
<p><strong>捕获列表 capture list</strong></p>
<p>指定我们需要捕获什么。其由很多种方式，我们展示两种比较“懒惰”的方式：</p>
<ul>
<li>将Lambda表达式写成<code>[=] () {...}</code>时，会捕获到外部所有变量的副本。</li>
<li>将Lambda表达式写成<code>[&amp;] () {...}</code>时，会捕获到外部所有变量的引用。</li>
</ul>
<p>当然，也可以在捕获列表中单独的去写需要捕获的变量。比如<code>[a, &amp;b] () {...}</code>，就是捕获<code>a</code>的副本和<code>b</code>的引用，这样捕获列表就不会去捕获那些不需要捕获的变量。</p>
<p>本节中，我们定义了一个Lambda表达式：<code>[count=0] () {...}</code>，这样我们就不会捕获外部的任何变量。我们定义了一个新的<code>count</code>变量，其类型通过初始化的值的类型进行推断，由于初始化为0，所以其类型为<code>int</code>。</p>
<p>所以，可以通过捕获列表捕获变量的副本和/或引用：</p>
<ul>
<li><code>[a, &amp;b] () {...}</code>：捕获<code>a</code>的副本和<code>b</code>的引用。</li>
<li><code>[&amp;, a] () {...}</code>：除了捕获<code>a</code>为副本外，其余捕获的变量皆为引用。</li>
<li><code>[=, &amp;b, i{22}, this] () {...}</code>：捕获<code>b</code>的引用，<code>this</code>的副本，并将新变量<code>i</code>初始化成22，并且其余捕获的变量都为其副本。</li>
</ul>
<blockquote>
<p>Note:</p>
<p>当你需要捕获一个对象的成员变量时，不能直接去捕获成员变量。需要先去捕获对象的<code>this</code>指针或引用。</p>
</blockquote>
<p><strong>mutable (optional)</strong></p>
<p>当函数对象需要去修改通过副本传入的变量时，表达式必须用<code>mutable</code>修饰。这就相当于对捕获的对象使用非常量函数。</p>
<p><strong>constexpr (optional)</strong></p>
<p>如果我们显式的将Lambda表达式修饰为<code>constexpr</code>，编译器将不会通过编译，因为其不满足<code>constexpr</code>函数的标准。<code>constexpr</code>函数有很多条件，编译器会在编译时对Lambda表达式进行评估，看其在编译时是否为一个常量参数，这样就会让程序的二进制文件体积减少很多。</p>
<p>当我们不显式的将Lambda表达式声明为<code>constexpr</code>时，编译器就会自己进行判断，如果满足条件那么会将Lambda表达式隐式的声明为<code>constexpr</code>。当我们需要一个Lambda表达式为<code>constexpr</code>时，我们最好显式的对Lambda的表达式进行声明，当编译不通过时，编译器会告诉我们哪里做错了。</p>
<p><strong>exception attr (optional)</strong></p>
<p>这里指定在运行错误时，是否抛出异常。</p>
<p><strong>return type (optional)</strong></p>
<p>当想完全控制返回类型时，我们不会让编译器来做类型推导。我们可以写成这样<code>[] () -&gt; Foo {}</code>，这样就告诉编译器，这个Lambda表达式总是返回<code>Foo</code>类型的结果。</p>
</div></div><div id="ebook-heading-x4f7fx7528lambdax4e3astdfunctionx6dfbx52a0x591ax6001x6027" ebook-toc-level-2="" heading="使用Lambda为std::function添加多态性"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8lambda%E4%B8%BAstdfunction%E6%B7%BB%E5%8A%A0%E5%A4%9A%E6%80%81%E6%80%A7">使用Lambda为std::function添加多态性</h1>

<p>我们现在想编写一些观察函数，用来观察一些变量的变化，当相应变量的数值发生改变时会进行提示，比如气压仪或是股票软件这类的东西。当有些值发生变化时，对应的观察对象就会被调用，之后以对应的方式进行反应。</p>
<p>为了实现这个观察器，我们存储了一些相关的函数对象在一个<code>vector</code>中，这些函数都接受以<code>int</code>变量作为参数，这个参数就是观察到的值。 我们不清楚这些函数对于传入值会做什么特殊的处理，不过我们也没有必要知道。</p>
<p>那么<code>vector</code>中的函数对象类型是什么呢？<code>std::vector&lt;void (*)(int)&gt;</code>，只要函数声明成<code>void f(int)</code>就符合这个这个函数指针类型的定义。这对于Lambda表达式同样有效，不过Lambda表达就是不能捕获任何值了——<code>[](int x) {...}</code>。对于捕获列表来说，Lambda表达式确实和普通的函数指针不同，因为其就不是一个函数指针，是一个函数对象，也就是将很多数据耦合到一个函数当中！想想在C++11时代之前，C++中没有Lambda表达式，类和结构体通常会将数据和函数耦合在一起，并且当你修改一个类中的数据成员时，你得到的是一个完全不同类型的数据。</p>
<p>这样<code>vector</code>中就无法将使用同样类型名字的不同类别的对象存储在一起。不能捕获已存在的变量，这个限制对于用户来说非常的不友好，也限制了代码的使用范围。用户该如何保存不同类型的函数对象呢？对接口进行约束，采用特定的传参方式传入已经观察到的值？</p>
<p>本节中，我们将展示使用<code>std::function</code>来解决这个问题，其将扮演一个“Lambda表达式多态包装器”的角色，捕获列表是不是空的都没有关系。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节我们将创建很多Lambda表达式，其捕获类型是完全不同的，但是其函数签名的类型是相同的。然后，使用<code>std::function</code>将这些函数对象存入一个<code>vector</code>：</p>
<ol>
<li>
<p>包含必要的头文件：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;deque&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
</pre></li>
<li>
<p>我们先实现一个简单的函数，其返回值是一个Lambda表达式。其需要传入一个容器，并且返回一个函数对象，这个函数对象会以引用的方式捕获容器。且函数对象本身接受传入一个整型参数。当向函数对象传入一个整型时，表达式将会把传入的整型，添加到捕获的容器尾部：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">C</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">consumer</span> <span class="token punctuation">(</span>C <span class="token operator">&amp;</span>container<span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	container<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>另一个辅助函数将会打印传入的容器中所有的内容：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">C</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">print</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> C <span class="token operator">&amp;</span>c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> i <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们先实例化一个<code>deque</code>和一个<code>list</code>，还有一个<code>vector</code>，这些容器存放的元素都是<code>int</code>类型。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> d<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> l<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在使用<code>consumer</code>函数对象与刚刚实例化的容器进行配合：将在<code>vector</code>中存储生成自定义的函数对象。然后，用一个<code>vector</code>存放着三个函数对象。每个函数对象都会捕获对应的容器对象。这些容器对象都是不同的类型，不过都是函数对象。所以，<code>vector</code>中的实例类型为<code>std::function&lt;void(int)&gt;</code>。所有函数对象都将隐式转换成一个<code>std::function</code>对象，这样就可以存储在<code>vector</code>中了。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> consumers
    	<span class="token punctuation">{</span><span class="token function">consumer</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">consumer</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">consumer</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们将10个整型值传入自定义函数对象：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;&amp;</span>consume <span class="token operator">:</span> consumers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token function">consume</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>三个容器都包含了同样的10个整数。让我们来打印它们：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行程序，就会看到如下输出，和我们的期望是一样的。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>std_function
<span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span>
<span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span>
<span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节中比较复杂的地方就是这一行：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> consumers
	<span class="token punctuation">{</span><span class="token function">consumer</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">consumer</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">consumer</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>d，l和v对象都包装进一个<code>consumer(...)</code>调用中。这个调用会返回多个函数对象，这样每个函数对象都能捕获这三个容器实例。虽然函数对象只能接受<code>int</code>型变量为参数，但是其捕获到的是完全不同的类型。这就将不同类型的A、B和C变量存入到一个<code>vector</code>中一样。</p>
<p>为了这个功能，需要找到一个共同的类型，也就是能保存不同类型的函数对象，这个类型就是<code>std::function</code>。一个<code>std::function&lt;void(int)&gt;</code>对象可以存储我们的函数对象或传统函数，其接受只有一个整型参数和返回为空的函数类型。这里使用了多态性，为函数类型进行解耦。思考如下的写法：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">f</span> <span class="token punctuation">(</span>
	<span class="token punctuation">[</span><span class="token operator">&amp;</span>vector<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> vector<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>这里有个函数对象，将Lambda表达式包装入<code>std::function</code>对象当中，当我们调用<code>f(123)</code>时，会产生一个虚函数调用，其会重定向到对象内部的实际执行函数。</p>
<p>当存储函数对象时，<code>std::function</code>就显得非常智能。当我们使用Lambda表达式捕获越来越多的变量时，<code>std::function</code>实例的体积也会越来越大。如果对象体积特别特别巨大，那么其将会在堆上分配出对应内存空间来存放这个函数对象。这些对于我们代码的功能性并没有什么影响，这里需要让你了解一下是因为这样的存储方式会对性能有一定的影响。</p>
<blockquote>
<p>Note:</p>
<p>很多初学者都认为或希望<code>std::function&lt;...&gt;</code>的实际表达类型是一个Lambda表达式。不过这是错误的理解！因为有多态库的帮助，其才能将Lambda表达式进行包装，从而抹去类型的差异。</p>
</blockquote>
</div></div><div id="ebook-heading-x5e76x7f6ex51fdx6570" ebook-toc-level-2="" heading="并置函数"><div><h1 class="mume-header" id="%E5%B9%B6%E7%BD%AE%E5%87%BD%E6%95%B0">并置函数</h1>

<p>其实很多函数没有必要完全自定义的去实现。让我们先来看一个使用Haskell实现的在文本中查找单一单词的例子。第一行定义了一个<code>unique_words</code>函数，在第二行中传入一个字符串：</p>
<p><img src="./C++17 STL Cook book_files/4-3-1.png" alt=""></p>
<p>Wow，就是这么简单！这里不对Haskell的语法做过多的解释，让我们来看一下代码。其定义了一个<code>unique_words</code>的函数，该函数对其传入的参数进行了一系列的处理。首先，使用<code>map toLower</code>将所有字符都小写化。然后，将句子用逗号进行分割，比如<code>"foo bar baz"</code>就会已变成<code>["foo", "bar","baz"]</code>。接下来，将单词列表进行排序。这样，<code>["a", "b", "a"]</code>就会变为<code>["a", "a", "b"]</code>。现在，使用<code>group</code>函数，其会将相同的词组放到一个列表中，也就是<code>["a", "a", "b"]</code>成为<code>[ ["a", "a"], ["b"] ]</code>。现在就差不多快完事了，接下来就让我们数一下列表中一共有多少个组，这个工作由<code>length</code>函数完成。</p>
<p>多么完美的编程方式呀！我们可以从右往左看，来了解这段代码是如何工作的。这里我就不需要关心每个细节是如何进行实现(除非其性能很差，或者有Bug)。</p>
<p>我们不是来赞美Haskell的，而是来提升我们自己C++技能的，这样的方式在C++中同样奏效。本节的例子会展示如何使用Lambda表达式来模仿并置函数。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中定义了一些函数对象，并将它们串联起来，也就是将一个函数的输出作为另一个函数的输入，以此类推。为了很好的展示这个例子，我们编写了一些串联辅助函数：</p>
<ol>
<li>
<p>包含必要的头文件</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
</pre></li>
<li>
<p>然后，我们实现一个辅助函数<code>concat</code>，其可以去任意多的参数。这些参数都是函数，比如f，g和h。并且一个函数的结果是另一个函数的输入，可以写成<code>f(g(h(...)))</code>:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">concat</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> Ts <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ts<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p>现在，代码就会变有些复杂了。当用户提供函数f，g和h时，我们现将其转换为<code>f( concat(g,h))</code>，然后再是<code>f(g(concat(h)))</code>，类似这样进行递归，直到得到<code>f(g(h(...)))</code>为止。用户提供的这些函数都可以由Lambda表达式进行捕获，并且Lambda表达式将在之后获得相应的参数p，然后前向执行这些函数<code>f(g(h(p)))</code>。这个Lambda表达式就是我们要返回的。<code>if constexpr</code>结构会检查在递归步骤中，当前函数是否串联了多个函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-if">if</span> <span class="token keyword keyword-constexpr">constexpr</span> <span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token function">concat</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">(</span>parameters<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>当我们到达递归的末尾，编译器会选择<code>if constexpr</code>的另一分支。这个例子中，我们只是返回函数<code>t</code>，因为其传入的只有参数了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
   		<span class="token keyword keyword-return">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</pre></li>
<li>
<p>现在，让我们使用刚创建的函数连接器对函数进行串联。我们先在主函数的起始位置定义两个简单的函数对象：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">twice</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">thrice</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，来串联他们。这里我们将两个乘法器函数和一个STL函数<code>std::plus&lt;int&gt;</code>放在一起，STL的这个函数可以接受两个参数，并返回其加和。这样我们就得到了函数<code>twice(thrice(plus( a, b )))</code>:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">combined</span> <span class="token punctuation">(</span>
    	<span class="token function">concat</span><span class="token punctuation">(</span>twice<span class="token punctuation">,</span> thrice<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>plus<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们来应用一下。<code>combined</code>函数现在看起来和一般函数一样，并且编译器会将这些函数连接在一起，且不产生任何不必要的开销：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">combined</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行这个例子就会得到如下的结果，和我们的期望一致，因为<code>2 * 3 * (2 + 3)</code>为30：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>concatenation
<span class="token number">30</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>concat</code>函数是本节的重点。其函数体看起来非常的复杂，因为其要对另一个Lambda表达式传过来<code>ts</code>参数包进行解析，<code>concat</code>会递归多次调用自己，每次调用参数都会减少：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">concat</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> Ts <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ts<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token keyword keyword-constexpr">constexpr</span> <span class="token punctuation">(</span><span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token function">concat</span><span class="token punctuation">(</span>ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">(</span>parameters<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> <span class="token function">t</span><span class="token punctuation">(</span>parameters<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre><p>让我们写一个简单点的版本，这次串联了三个函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">H</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">concat</span><span class="token punctuation">(</span>F f<span class="token punctuation">,</span> G g<span class="token punctuation">,</span> H h<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">f</span><span class="token punctuation">(</span> <span class="token function">g</span><span class="token punctuation">(</span> <span class="token function">h</span><span class="token punctuation">(</span> params<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>这个例子看起来应该很简单了吧。返回的Lambda表达式可以对f，g和h函数进行捕获。这个Lambda表达式可以接受任意多的参数传入，然后在调用f，g和h函数。我们先定义<code>auto combined (concat(f, g, h))</code>，并在之后传入两个参数，例如<code>combined(2, 3)</code>，这里的2和3就为<code>concat</code>函数的参数包。</p>
<p>看起来很复杂，但<code>concat</code>却很通用，有别与<code>f(g(h( params... )))</code>式的串联。我们完成的是<code>f(concat(g, h))(params...)</code>的串联，<code>f(g(concat(h)))(params...)</code>为其下一次递归调用的结果，最终会的结果为<code>f(g(h( params...)))</code>。</p>
</div></div><div id="ebook-heading-x901ax8fc7x903bx8f91x8fdex63a5x521bx5efax590dx6742x8c13x8bcd" ebook-toc-level-2="" heading="通过逻辑连接创建复杂谓词"><div><h1 class="mume-header" id="%E9%80%9A%E8%BF%87%E9%80%BB%E8%BE%91%E8%BF%9E%E6%8E%A5%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E8%B0%93%E8%AF%8D">通过逻辑连接创建复杂谓词</h1>

<p>当使用通用代码过滤数据时，我们通常会定义一些谓词，这些谓词就是告诉计算机，哪些数据是我们想要样，哪些数据时我们不想要的。通常谓词都是组合起来使用。</p>
<p>例如，当我们在过滤字符串时，我们需要实现一个谓词，当其发现输入的字符串以<code>foo</code>开头就返回true，其他情况都返回false。另一个谓词，当其发现输入的字符串以“bar”结尾时，返回true，否则返回false。</p>
<p>我们也不总是自己去定义谓词，有时候可以复用已经存在的谓词，并将它们结合起来使用。比如，如果我们既想要检查输入字符串的开头是否是<code>foo</code>，又想检查结尾是否为“bar”时，就可以将之前提到的两个谓词组合起来使用。本节我们使用Lambda表达式，用一种更加舒服的方式来完成这件事。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将来实现一个非常简单的字符串过滤谓词，并且将其和辅助函数结合让其变得更加通用。</p>
<ol>
<li>
<p>包含必要的头文件</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span> </span>
</pre></li>
<li>
<p>这里实现两个简单的谓词函数，后面会用到它们。第一个谓词会告诉我们字符串的首字母是否是<code>a</code>，第二个谓词则会告诉我们字符串的结尾字母是否为<code>b</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-bool">bool</span> <span class="token function">begins_with_a</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-bool">bool</span> <span class="token function">ends_with_b</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> s<span class="token punctuation">.</span><span class="token function">rfind</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在，让我们来实现辅助函数，我们称其为<code>combine</code>。其需要一个二元函数作为其第一个参数，可以是逻辑'与'或逻辑'或'操作。之后的两个参数为需要结合在一起的谓词函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">combine</span><span class="token punctuation">(</span>F binary_func<span class="token punctuation">,</span> A a<span class="token punctuation">,</span> B b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p>之后，我们会返回一个Lambda表达式，这个表达式可以获取到两个合并后的谓词。这个表达式需要一个参数，这个参数会传入两个谓词中，然后表达式将返回这个两个谓词结合后的结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">binary_func</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>在实现主函数之前，先声明所使用命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，让将两个谓词函数合并在一起，形成另一个全新的谓词函数，其会告诉我们输入的字符串是否以'a'开头，并且以'b'结尾，比如"ab"或"axxxb"就会返回true。二元函数我们选择<code>std::logical_and</code>。这是个模板类，需要进行实例化，所以这里我们使用大括号对创建其实例。需要注意的是，因为该类的默认类型为void，所以这里我们并没有提供模板参数。特化类的参数类型，都由编译器推导得到：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">a_xxx_b</span> <span class="token punctuation">(</span><span class="token function">combine</span><span class="token punctuation">(</span>
        logical_and<span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        begins_with_a<span class="token punctuation">,</span> ends_with_b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们现在可以对标准输入进行遍历，然后打印出满足全新谓词的词组：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">copy_if</span><span class="token punctuation">(</span>istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>cin<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
            ostream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
            a_xxx_b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</pre></li>
<li>
<p>编译边运行程序，就会得到如下输出。我们输入了四个单词，但是只有两个满足我们的谓词条件：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ echo <span class="token string">"ac cb ab axxxb"</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>combine
ab<span class="token punctuation">,</span> axxxb<span class="token punctuation">,</span>
</pre></li>
</ol>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>STL已经提供了一些非常有用的函数对象，例如<code>std::logical_and</code>，<code>std::logical_or</code>等等。所以我们没有必要所有东西都自己去实现。可以去看一下C++的参考手册，了解一下都有哪些函数对象已经实现：</p>
<ul>
<li>英文：<a href="http://en.cppreference.com/w/cpp/utility/functional">http://en.cppreference.com/w/cpp/utility/functional</a></li>
<li>中文：<a href="http://zh.cppreference.com/w/cpp/utility/functional">http://zh.cppreference.com/w/cpp/utility/functional</a></li>
</ul>
</div></div><div id="ebook-heading-x4f7fx7528x540cx4e00x8f93x5165x8c03x7528x591ax4e2ax51fdx6570" ebook-toc-level-2="" heading="使用同一输入调用多个函数"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E8%BE%93%E5%85%A5%E8%B0%83%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0">使用同一输入调用多个函数</h1>

<p>当我们有很多工作要做时，可能就会导致很多代码的重复。使用Lambda表达式就很容易的避免重复代码，并且Lambda表达式将帮助你将这些重复的任务包装起来。</p>
<p>本节，我们将使用Lambda表达式接受一组参数，然后分发给相应的任务函数。这种方式并不需要添加额外的数据结构，所以编译器很容易的将这些函数打包成一个二进制文件(并且没有额外的开销)。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将要完成两个Lambda表达式辅助器，一个能接受一组参数，并调用多个函数对象；另一个使用一个函数调用，引发后续多个函数调用。我们的例子中，我们将使用不同的打印函数打印一些信息出来。</p>
<ol>
<li>
<p>包含打印头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
</pre></li>
<li>
<p>首先，让我们实现<code>multicall</code>函数，这个函数是本章的重点。这个函数可以接受任意数量的参数，并且返回一个Lambda表达式，这个Lambda表达式只接受一个参数。表达式可以通过这个参数调用所有已提供的函数。这样，我们可以定义<code>auto call_all (multicall(f, g, h))</code>函数对象，然后调用<code>call_all(123)</code>，从而达到同时调用<code>f(123); g(123); h(123);</code>的效果。这个函数看起来比较复杂，是因为我们需要一个语法技巧来展开参数包functions，并在<code>std::initializer_list</code>实例中包含一系列可调用的函数对象。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">multicall</span> <span class="token punctuation">(</span>Ts <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>functions<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
        	<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token function">functions</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>下一个辅助器能接受一个函数f和一个参数包<code>xs</code>。这里要表示的就是参数包中的每个参数都会传入f中运行。这种方式类似于<code>for_each(f, 1, 2, 3)</code>调用，从而会产生一系列调用——<code>f(1); f(2); f(3);</code>。本质上来说，这个函数使用同样的技巧来为函数展开参数包<code>xs</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">for_each</span> <span class="token punctuation">(</span>F f<span class="token punctuation">,</span> Ts <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
   		<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span>xs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p><code>brace_print</code>函数能接受两个字符，并返回一个新的函数对象，这个函数对象可以接受一个参数<code>x</code>。其将会打印这个参数，当然会让之前的两个字符将这个参数包围：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">brace_print</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在，我们终于可以在main函数中使用这些定义好的东西了。首先，我们定义函数f，g和h。其使用括号打印函数将其参数进行包围。<code>nl</code>函数只打印换行符。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">f</span> <span class="token punctuation">(</span><span class="token function">brace_print</span><span class="token punctuation">(</span><span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">g</span> <span class="token punctuation">(</span><span class="token function">brace_print</span><span class="token punctuation">(</span><span class="token string">'['</span><span class="token punctuation">,</span> <span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">h</span> <span class="token punctuation">(</span><span class="token function">brace_print</span><span class="token punctuation">(</span><span class="token string">'{'</span><span class="token punctuation">,</span> <span class="token string">'}'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">nl</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		
</pre></li>
<li>
<p>让我们将所有函数和<code>multicall</code>辅助器放在一起：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">call_fgh</span> <span class="token punctuation">(</span><span class="token function">multicall</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">,</span> h<span class="token punctuation">,</span> nl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>这里我们提供一组数字，之后这些数字就会被相应的括号包围，然后打印出来。这样，我们现在调用一次，就等于以前调用五次主函数中定义的函数。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">for_each</span><span class="token punctuation">(</span>call_fgh<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行，我们应该能得到期望的结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">multicaller</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>我们刚刚实现的辅助函数还是挺复杂的。我们使用了<code>std::initializer_list</code>来帮助我们展开参数包。为什么这里不用特殊的数据结构呢？再来看一下<code>for_each</code>的实现：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">for_each</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> f<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
    	<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span>xs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>这段代码的核心在于<code>f(xs)</code>表达式。<code>xs</code>是一个参数包，我们需要将其进行解包，才能获取出独立的参数，以便调用函数f。不幸的是，我们知道这里不能简单的使用<code>...</code>标记，写成<code>f(xs)...</code>。</p>
<p>所以，我能做的只能是构造出一个<code>std::initializer_list</code>列表，其具有一个可变的构造函数。表达式可以直接通过<code>return std::initializer_list&lt;int&gt;{f(xs)...};</code>方式构建，不过其也有缺点。在让我们看一下<code>for_each</code>的实现，看起来要比之前简单许多：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">for_each</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> f<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token function">f</span><span class="token punctuation">(</span>xs<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>这看起来非常简单易懂，但是我们要了解其缺点所在：</p>
<ol>
<li>其使用f函数的所有调用返回值，构造了一个初始化列表。但我们并不关心返回值。</li>
<li>虽然其返回的初始化列表，但是我们想要一个“即发即弃”的函数，这些函数不用返回任何东西。</li>
<li>f在这里可能是一个函数，因为其不会返回任何东西，可能在编译时就会被优化掉。</li>
</ol>
<p>要想<code>for_each</code>修复上面所有的问题，会让其变的更加复杂。例子中做到了一下几点：</p>
<ol>
<li>不返回初始化列表，但会将所有表达式使用<code>(void)std::initializer_list&lt;int&gt;{...}</code>转换为<code>void</code>类型。</li>
<li>初始化表达式中，其将<code>f(xs)...</code>包装进<code>(f(xs),0)...</code>表达式中。这会让程序将返回值完全抛弃，不过0将会放置在初始化列表中。</li>
<li><code>f(xs)</code>在<code>(f(xs), 0)...</code>表达式中，将会再次转换成<code>void</code>，所以这里就和没有返回值一样。</li>
</ol>
<p>这些不幸的事导致例程如此复杂丑陋，不过其能为所有可变的函数对象工作，并且不管这些函数对象是否返回值，或返回什么样的值。</p>
<p>这种技术可以很好控制函数调用的顺序，严格保证多个函数/函数对象以某种顺序进行调用。</p>
<blockquote>
<p>Note:</p>
<p>不推荐使用C风格的类型转换，因为C++有自己的转换操作。我们可以使用<code>reinterpret_cast&lt;void&gt;(expression)</code>代替例程中的代码行，不过这样会降低代码的可读性，会给后面的阅读者带来一些困扰。</p>
</blockquote>
</div></div><div id="ebook-heading-x4f7fx7528stdaccumulatex548clambdax51fdx6570x5b9ex73b0transform_if" ebook-toc-level-2="" heading="使用std::accumulate和Lambda函数实现transform_if"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8stdaccumulate%E5%92%8Clambda%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0transform_if">使用std::accumulate和Lambda函数实现transform_if</h1>

<p>大多数用过<code>std::copy_if</code>和<code>std::transform</code>的开发者可能曾经疑惑过，为什么标准库里面没有<code>std::transform_if</code>。<code>std::copy_if</code>会将源范围内符合谓词判断的元素挑出来，不符合条件的元素忽略。而<code>std::transform</code>会无条件的将源范围内所有元素进行变换，然后放到目标范围内。这里的变换谓词是由用户提供的一个函数，这个函数不会太复杂，比如乘以多个数或将元素完全变换成另一种类型。</p>
<p>这两个函数很早就存在了，不过到现在还是没有<code>std::transform_if</code>函数。本节就来实现这个函数。看起来实现这个函数并不难，可以通过谓词将对应的元素选择出来，然后将这些挑选出来的元素进行变换。不过，我们会利用这个机会更加深入的了解Lambda表达式。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将来实现我们的<code>transform_if</code>函数，其将会和<code>std::accumulate</code>一起工作。</p>
<ol>
<li>
<p>包含必要的头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span>
</pre></li>
<li>
<p>首先，我们来实现一个<code>map</code>函数。其能接受一个转换函数作为参数，然后返回一个函数对象，这个函数对象将会和<code>std::accumulate</code>一起工作。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">map</span><span class="token punctuation">(</span>T fn<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p>当传入一个递减函数时，我们会返回一个函数对象，当这个函数对象调用递减函数时，其会返回另一个函数对象，这个函数对象可以接受一个累加器和一个输入参数。递减函数会在累加器中进行调用，并且<code>fn</code>将会对输入变量进行变换。如果这里看起来比较复杂的话，我们将在后面进行详细的解析：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> reduce_fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> accum<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> <span class="token function">reduce_fn</span><span class="token punctuation">(</span>accum<span class="token punctuation">,</span> <span class="token function">fn</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在，让我们来实现一个<code>filter</code>函数。其和<code>map</code>的工作原理一样，不过其不会对输入进行修改(<code>map</code>中会对输入进行变换)。另外，我们接受一个谓词函数，并且在不接受谓词函数的情况下，跳过输入变量，而非减少输入变量：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">filter</span><span class="token punctuation">(</span>T predicate<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p>两个Lambda表达式与<code>map</code>函数具有相同的函数签名。其不同点在于<code>input</code>参数是否进行过操作。谓词函数用来区分我们是否对输入调用<code>reduce_fn</code>函数，或者直接调用累加器而不进行任何修改：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> reduce_fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> accum<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">predicate</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            	<span class="token keyword keyword-return">return</span> <span class="token function">reduce_fn</span><span class="token punctuation">(</span>accum<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
            	<span class="token keyword keyword-return">return</span> accum<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在让我们使用这些辅助函数。我们实例化迭代器，我们会从标准输入中获取整数值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> it <span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> end_it<span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后，我们会调用谓词函数<code>even</code>，当传入一个偶数时，这个函数会返回true。变换函数<code>twice</code>会对输入整数做乘2处理：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">even</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">twice</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>std::accumulate</code>函数会将所对应范围内的数值进行累加。累加默认就是通过<code>+</code>操作符将范围内的值进行相加。我们想要提供自己的累加函数，也就是我们不想只对值进行累加。我们会将迭代器<code>it</code>进行解引用，获得其对应的值，之后对再对其进行处理：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">copy_and_advance</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> it<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>it <span class="token operator">=</span> input<span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">++</span>it<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们现在将之前零零散散的实现拼组在一起。我们对标准输入进行迭代，通过输出迭代器<code>ostream_iterator</code>将对应的值输出在终端上。 <code>copy_and_advance</code>函数对象将会接收用户输入的整型值，之后使用输出迭代器进行输出。将值赋值给输出迭代器，将会使打印变得高效。不过，我们只会将偶数挑出来，然后对其进行乘法操作。为了达到这个目的，我们将<code>copy_and_advance</code>函数包装入<code>even</code>过滤器中，再包装入<code>twice</code>引射器中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    std<span class="token double-colon punctuation">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> end_it<span class="token punctuation">,</span>
        std<span class="token double-colon punctuation">::</span>ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">filter</span><span class="token punctuation">(</span>even<span class="token punctuation">)</span><span class="token punctuation">(</span>
            <span class="token function">map</span><span class="token punctuation">(</span>twice<span class="token punctuation">)</span><span class="token punctuation">(</span>
            	copy_and_advance
            <span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们将得到如下的输出。奇数都被抛弃了，只有偶数做了乘2运算：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ echo <span class="token string">"1 2 3 4 5 6"</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>transform_if
<span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节看起来还是很复杂的，因为我们使用了很多嵌套Lambda表达式。为了跟清晰的了解它们是如何工作的，我们先了解一下<code>std::accumulate</code>的内部工作原理。下面的实现类似一个标准函数的实现：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
T <span class="token function">accumulate</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span> T init<span class="token punctuation">,</span> F f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> first <span class="token operator">!=</span> last<span class="token punctuation">;</span> <span class="token operator">++</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	init <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>init<span class="token punctuation">,</span> <span class="token operator">*</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> init<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>函数参数f在这起到主要作用，所有值都会累加到用户提供的<code>init</code>变量上。通常情况下，迭代器范围将会传入一组数字，类似<code>0, 1, 2, 3, 4</code>，并且<code>init</code>的值为0。函数<code>f</code>只是一个二元函数，其会计算两个数的加和。</p>
<p>例子中循环将会将所有值累加到<code>init</code>上，也就类似于<code>init += (((0 + 1) + 2) + 3) + 4</code>。这样看起来<code>std::accumulate</code>就是一个通用的折叠函数。折叠范围意味着，将二值操作应用于累加器变量和迭代范围内的每一个值(累加完一个数，再累加下一个数)。这个函数很通用，可以用它做很多事情，就比如实现<code>std::transform_if</code>函数！<code>f</code>函数也会递减函数中进行调用。</p>
<p><code>transform_if</code>的一种很直接的实现，类似如下代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">OutputIterator</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">P</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">Transform</span><span class="token operator">&gt;</span>
OutputIterator <span class="token function">transform_if</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">,</span>OutputIterator out<span class="token punctuation">,</span>P predicate<span class="token punctuation">,</span> Transform trans<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> first <span class="token operator">!=</span> last<span class="token punctuation">;</span> <span class="token operator">++</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">predicate</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">*</span>out <span class="token operator">=</span> <span class="token function">trans</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>out<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> out<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>这个实现看起来和<code>std::accumulate</code>的实现很类似，这里的<code>out</code>参数可以看作为<code>init</code>变量，并且使用函数<code>f</code>替换<code>if</code>。</p>
<p>我们确实做到了。我们构建了<code>if</code>代码块，并且将二元函数对象作为一个参数提供给了<code>std::accumulate</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">copy_and_advance</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> it<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>it <span class="token operator">=</span> input<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token operator">++</span>it<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p><code>std::accumulate</code>会将<code>init</code>值作为二元函数<code>it</code>的参数传入，第二个参数则是当前迭代器所指向的数据。我们提供了一个输出迭代器作为<code>init</code>参数。这样<code>std::accumulate</code>就不会做累加，而是将其迭代的内容转发到另一个范围内。这就意味着，我们只需要重新实现<code>std::copy</code>就可以了。</p>
<p>通过<code>copy_and_advance</code>函数对象，使用我们提供的谓词，将过滤后的结果传入另一个使用谓词的函数对象：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">filter</span><span class="token punctuation">(</span>T predicate<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> reduce_fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> accum<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">predicate</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            	<span class="token keyword keyword-return">return</span> <span class="token function">reduce_fn</span><span class="token punctuation">(</span>accum<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
            	<span class="token keyword keyword-return">return</span> accum<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>构建过程看上去没那么简单，不过先来看一下<code>if</code>代码块。当<code>predicate</code>函数返回true时，其将返回<code>reduce_fn</code>函数处理后的结果，也就是<code>accum</code>变量。这个实现省略了使用过滤器的操作。<code>if</code>代码块位于Lambda表达式的内部，其具有和<code>copy_and_advance</code>一样的函数签名，这使它成为一个合适的替代品。</p>
<p>现在我们就要进行过滤，但不进行变换。这个操作有<code>map</code>辅助函数完成：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">map</span><span class="token punctuation">(</span>T fn<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> reduce_fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> accum<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> <span class="token function">reduce_fn</span><span class="token punctuation">(</span>accum<span class="token punctuation">,</span> <span class="token function">fn</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>这段代码看起来就简单多了。其内部有一个还有一个Lambda表达式，该表达式的函数签名与<code>copy_and_advance</code>，所以可以替代<code>copy_and_advance</code>。这个实现仅转发输入变量，不过会通过二元函数对<code>fn</code>的调用，对参数进行量化。</p>
<p>之后，当我们使用这些辅助函数时，我们可以写成如下的表达式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token function">filter</span><span class="token punctuation">(</span>even<span class="token punctuation">)</span><span class="token punctuation">(</span>
    <span class="token function">map</span><span class="token punctuation">(</span>twice<span class="token punctuation">)</span><span class="token punctuation">(</span>
    	copy_and_advance
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</pre><p><code>filter(even)</code>将会捕获<code>even</code>谓词，并且返回给我们一个函数，其为一个包装了另一个二元函数的二元函数，被包装的那个二元函数则是进行过滤的函数。<code>map(twice)</code>函数做了相同的事情，<code>twice</code>变换函数，将<code>copy_and_advance</code>包装入另一个二元函数中，那另一个二元函数则是对参数进行变换的函数。</p>
<p>虽然没有任何的优化，但我们的代码还是非常的复杂。为了让函数之间能一起工作，我们对函数进行了多层嵌套。不过，这对于编译器来说不是一件很难的事情，并且能对所有代码进行优化。程序最后的结果要比实现<code>transform_if</code>简单很多。这里我们没有多花一分钱，就获得了非常好的函数模组。这里我们就像堆乐高积木一样，可将<code>even</code>谓词和<code>twice</code>转换函数相结合在一起。</p>
</div></div><div id="ebook-heading-x7f16x8bd1x65f6x751fx6210x7b1bx5361x5c14x4e58x79ef" ebook-toc-level-2="" heading="编译时生成笛卡尔乘积"><div><h1 class="mume-header" id="%E7%BC%96%E8%AF%91%E6%97%B6%E7%94%9F%E6%88%90%E7%AC%9B%E5%8D%A1%E5%B0%94%E4%B9%98%E7%A7%AF">编译时生成笛卡尔乘积</h1>

<p>Lambda表达式结合参数包一起使用，可以用来解决比较复杂的问题。本节中，我们将实现一个函数对象，其能接受任意多的输入参数，然后生成相应的<strong>笛卡尔乘积</strong>。</p>
<p>笛卡尔乘积是一个数学运算。其可以表示为<code>A x B</code>，其意思为使用集合A和集合B来结算笛卡尔乘积。结果为另一个单独的集合，其包含集合A和集合B一一对应的组对。这个运算的意义在于，将两个集合中的元素进行匹配。下图就描述了这种运算操作：</p>
<p><img src="./C++17 STL Cook book_files/4-7-1.png" alt=""></p>
<p>图中，<code>A = (x, y, z)</code>，<code>B = (1, 2, 3)</code>，所产生的笛卡尔乘积为<code>(x, 1)</code> , <code>(x, 2)</code> ,<code>(x, 3)</code>,<code>(y, 1)</code> ,<code>(y, 2)</code>等等。如果A和B为同一个集合，比如说是<code>(1, 2)</code>，那么其笛卡尔乘积为<code>(1, 1)</code> , <code>(1, 2)</code> ,<code>(2, 1)</code>, 和<code>(2, 2)</code>。有时候，这样的操作却十分冗余，比如集合<code>(1, 1)</code>，或是刚才例子中的<code>(1, 2)</code>和<code>(2, 1)</code>。笛卡尔乘积可以通过一个简单的条件，对结果进行过滤。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们实现了一个函数对形象，其能接受一个函数<code>f</code>，以及一组参数。该函数对象将会通过输出参数集合创建笛卡尔乘积，将冗余的部分进行过滤，并对每个乘积调用函数<code>f</code>。</p>
<ol>
<li>
<p>包含打印输出的头文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
</pre></li>
<li>
<p>然后，我们定义一个简单的辅助函数，用来对组对中的值进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> <span class="token string">")\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p>复杂的地方到了。我们先实现了一个辅助函数<code>cartesian</code>，我们将在下一步实现这个函数。这个函数能接受一个参数<code>f</code>，在我们使用过程中，这个<code>f</code>函数就是<code>print</code>函数。另一些参数是<code>x</code>和参数包<code>rest</code>。其包含了计算笛卡尔乘积的元素。在<code>f(x, rest)</code>表达式中：当<code>x=1</code>和<code>rest=2, 3, 4</code>，为了得到结果，我们需要调用三次:<code>f(1, 2); f(1, 3); f(1, 4);</code>。<code>(x &lt; rest)</code>的条件，会删除冗余的组对。我们来看下代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-constexpr">constexpr</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">call_cart</span> <span class="token punctuation">(</span>
        <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> f<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> x<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>rest<span class="token punctuation">)</span> <span class="token keyword keyword-constexpr">constexpr</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&lt;</span> rest<span class="token punctuation">)</span>
                    <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> rest<span class="token punctuation">)</span>
                    <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>cartesian</code>函数在本节中，算是最复杂的部分了。其能接受一个参数包<code>xs</code>，并返回一个其捕获的函数对象。返回的函数对象能接受一个函数对象<code>f</code>。参数包，比如<code>xs = 1, 2, 3</code>，其内部Lambda表达式将会生成如下调用：call_cart(f, <strong>1</strong>, 1, 2, 3); call_cart(f, <strong>2</strong>, 1, 2, 3); call_cart(f, <strong>3</strong>, 1, 2, 3);。通过对这些函数的调用，我们能得到我们想要的所有笛卡尔乘积。我们使用<code>...</code>对<code>xs</code>参数包扩展了两次，第一次看起来有些奇怪。调用<code>call_cart</code>时，我们第一次对<code>xs</code>进行了扩展。第二次扩展将会使得<code>call_cart</code>调用多次，并且每次的第二个参数都会不同。</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-constexpr">constexpr</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">cartesian</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>xs<span class="token punctuation">)</span> <span class="token keyword keyword-constexpr">constexpr</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> f<span class="token punctuation">)</span> <span class="token keyword keyword-constexpr">constexpr</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
            	<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token function">call_cart</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> xs<span class="token punctuation">,</span> xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><ol start="5">
<li>
<p>那么，现在让我们使用数字集<code>1, 2, 3</code>来生成笛卡尔乘积，并对组对进行打印。过滤了冗余的组对，所剩的结果应该为 <code>(1, 2)</code> , <code>(2, 3)</code> , 和 <code>(1, 3)</code>。我们对很多的结果进行了过滤，并且不考虑结果中组对中的数字顺序。这也就是说，我们不需要<code>(1, 1)</code>，并且认为<code>(1, 2)</code>和<code>(2, 1)</code>为同一个组对。首先，我们让<code>cartesian</code>函数产生一个函数对象，其会包含所有可能的组对，并且能够接受我们的打印函数。然后，我们将所产生的组对，使用打印函数进行打印输出。我们将<code>print_cart</code>变量声明为<code>constexpr</code>，这样我们就能在编译时获得所有的乘积结果:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-constexpr">constexpr</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">print_cart</span> <span class="token punctuation">(</span><span class="token function">cartesian</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">print_cart</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就会得到如下的输出。通过<code>call_cart</code>中的<code>x &lt; rest</code>判断条件，我们可以将一些冗余组对结果进行删除：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">cartesian_product</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>另一个看起来比较复杂的地方就是Lambda表达式了。但当我们充分的了解后，我们就不会再对Lambda表达式有任何的困惑了！</p>
<p>那么，让我们来仔细的了解一下吧。我们将所发生的事情，画了一张图来说明：</p>
<p><img src="./C++17 STL Cook book_files/4-7-2.png" alt=""></p>
<p>这里有3步：</p>
<ol>
<li>我们将<code>1, 2, 3</code>作为新集合中的三个元素，其报了三个新的集合。第一个则是集合中的每一个单独向，而第二部分则是整个集合本身。</li>
<li>我们可以将第一个元素与每一个元素相组合(包括自己)，就能得到很多组对。</li>
<li>对于三个结果组对来说，我们只需要将其中不冗余的部分取出就好。</li>
</ol>
<p>好了，回到我们例子：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-constexpr">constexpr</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">cartesian</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>xs<span class="token punctuation">)</span> <span class="token keyword keyword-constexpr">constexpr</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> f<span class="token punctuation">)</span> <span class="token keyword keyword-constexpr">constexpr</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
        	<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token function">call_cart</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> xs<span class="token punctuation">,</span> xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
</pre><p>内部表达式<code>call_cart(xs, xs...)</code>将会对集合<code>1, 2, 3</code>分别进行表示，比如：<code>1, [1, 2, 3]</code>。整个表达式<code>((void)call_cart(f, xs, xs...), 0)...</code>其将<code>...</code>放在外部，其会将集合进行拆解，我们将会得到<code>2，[1, 2, 3]</code>和<code>3, [1, 2, 3]</code>。</p>
<p><code>call_cart</code>完成了第2和第3步：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">call_cart</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> f<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> x<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>rest<span class="token punctuation">)</span> <span class="token keyword keyword-constexpr">constexpr</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&lt;</span> rest<span class="token punctuation">)</span>
            <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> rest<span class="token punctuation">)</span>
            <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>参数<code>x</code>始终包含从这个集合中挑出的但选值，并且<code>rest</code>包含了整个集合。让我么先忽略<code>x &lt; rest</code>这个条件。这里，<code>f(x, rest)</code>表达式与<code>...</code>参数包展开所得到的调用<code>f(1, 1)</code>，<code>f(1, 2)</code>等等，其就会生成将被打印的组对。这就是第2步完成的事。</p>
<p>第3步中，就是用<code>x &lt; rest</code>条件来过滤冗余的组对了。</p>
<p>我们先给所有Lambda表达式和持有变量声明成<code>constexpr</code>。通过这样做，我们可以在运行时对代码进行评估，这样编译出的二进制文件将会包含所有组对，而无需在运行时对其进行计算。需要注意的是，这里需要传入常量函数的参数为已知量，这样才能在运行时让编译器知道，并对函数进行执行。</p>
</div></div><div id="ebook-heading-x7b2c5x7ae0-stlx57fax7840x7b97x6cd5" ebook-toc-level-1="" heading="第5章 STL基础算法"><div><h1 class="mume-header" id="%E7%AC%AC5%E7%AB%A0-stl%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95">第5章 STL基础算法</h1>

<p>STL不仅包含数据结构，还有很多算法。数据结构可以帮助存放特定情况下需要保存的数据，而算法则会将数据结构中存储的数据进行变换。</p>
<p>让我们来看一个标准的例子，例如对<code>vector</code>实例中的数据进行累加。这个可以简单的通过循环迭代<code>vector</code>中的元素，将所有值累加在一个对应的值上：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">200</span> <span class="token comment">/*, ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> sum <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> sum <span class="token operator">+=</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>

cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><p>不过，作为一个标准的例子，当然可以使用STL的算法来完成：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><p>例子中循环变量也不是很长，不过其可读性比<code>accumulate</code>差很多。一个10行的循环代码看起来的确很尴尬，那么本章我们就看来了解一下标准算法(<code>accumulate</code>,  <code>copy</code>,  <code>move</code>,  <code>transform</code>和<code>shuffle</code>等等)的工作机制。</p>
<p>其思想就是提供丰富的算法供开发者使用，避免耗费大量的时间在重复制造轮子上面。另一方面就是，即便开发者会自己去实现相应STL中的算法，也要进行大量的测试来确保自己实现的算法是否正确，STL提供的算法都是经过了严格的测试。所以没有必要做重复的工作，这样也能节省代码审阅者的时间，否则他们还要确定算法实现中是否有Bug。</p>
<p>另一个重点是STL算法非常的高效。很多STL算法提供了多种特化实现，这样足以应对依赖迭代器类型的使用方式。例如，将<code>vector</code>中的所有元素都填充0时，就可以使用<code>std::fill</code>。因为<code>vector</code>使用的是一段连续的内存，对于这种使用连续内存存放数据的结构都可以使用<code>std::fill</code>进行填充，这个函数类似于C中的<code>memset</code>函数。当开发者将容器类型从<code>vector</code>改为<code>list</code>，STL算法就不能再使用<code>memset</code>了，并且需要逐个迭代list的元素，并将元素赋0。开发者不能为了使用<code>memset</code>将数据类型写死为<code>vector</code>或<code>array</code>，因为实际项目中，还是有很多数据结构存储的地址并不是连续的。大多数情况下，想要自己去将代码实现的更聪明是没有太多意义的，因为STL的实现者已经考虑到了这种情况，并且STL还是免费使用的，为什么不用呢？</p>
<p>让我们总结一下前面提到的几点。使用STL算法的好处：</p>
<ul>
<li><strong>维护性</strong>：算法的名字已经说明它要做什么了。显式使用循环的方式与使用STL算法的方式没法对比。</li>
<li><strong>正确性</strong>：STL是由专家编写和审阅过的，并且经过了良好的测试，重新实现的复杂程度可能是你无法想象的。</li>
<li><strong>高效性</strong>：STL算法真的很高效，至少要比手写的循环要强许多。</li>
</ul>
<p>很多算法都是对迭代器进行操作，第3章已经解释了迭代器的工作原理。本章专注于如何使用STL算法解决各种问题，了解这些STL应该如何使用。要展示所有STL算法的使用方式不是本书所要做的事情，这个事情C++手册已经完成了，你可以在网上进行查询，或者花钱购买电子/纸质发布版本。</p>
<p>作为一个STL“忍者”需要将C++手册放在手边……嗯，至少放在浏览器的书签中吧。当我们在完成一个任务的过程中，每个开发者都可以回看一下任务本身，在完成自己的任务时，确定这个STL算法是否适合于你的问题。</p>
<p>在线版本的C++手册：<a href="http://cppreference.com/">http://cppreference.com</a></p>
<p>其也提供离线下载功能。</p>
<blockquote>
<p>Note:</p>
<p>在面试过程中，对于STL算法的熟悉程度也是判断一个开发者对C++的熟悉程度的标准之一。</p>
</blockquote>
</div></div><div id="ebook-heading-x5bb9x5668x95f4x76f8x4e92x590dx5236x5143x7d20" ebook-toc-level-2="" heading="容器间相互复制元素"><div><h1 class="mume-header" id="%E5%AE%B9%E5%99%A8%E9%97%B4%E7%9B%B8%E4%BA%92%E5%A4%8D%E5%88%B6%E5%85%83%E7%B4%A0">容器间相互复制元素</h1>

<p>大多数STL数据结构都支持迭代器。这就意味着大多数数据结构能够通过成员函数<code>begin()</code>和<code>end()</code>成员函数得到相应的迭代器，并能对数据进行迭代。迭代的过程看起来是相同的，无论是什么样的数据结构都是一样的。</p>
<p>我们可以对<code>vector</code>，<code>list</code>，<code>deque</code>，<code>map</code>等等数据结构进行迭代。我们甚至可以使用迭代器作为文件/标准输入输出的出入口。此外，如之前章节介绍，我们能将迭代器接口放入算法中。这样的话，我们可以使用迭代器访问任何元素，并且可以将迭代器作为STL算法的参数传入，对特定范围内的数据进行处理。</p>
<p><code>std::copy</code>算法可以很好的展示迭代器是如何将不同的数据结构进行抽象，而后将一个容器的数据拷贝到另一个容器。类似这样的算法就与数据结构的类型完全没有关系了。为了证明这点，我们会把玩一下<code>std::copy</code>。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将对不同的变量使用<code>std::copy</code>。</p>
<ol>
<li>
<p>首先，包含必要的头文件，并声明所用到的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tuple&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将使用整型和字符串值进行组对。为了能很好的将其进行打印，我们将会重载<code>&lt;&lt;</code>流操作：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-namespace">namespace</span> std <span class="token punctuation">{</span>
ostream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> pair<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> os <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们将使用整型-字符串对填充一个<code>vector</code>。并且我们声明一个<code>map</code>变量，其用来关联整型值和字符串值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;&gt;</span> v <span class="token punctuation">{</span>
        <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"five"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    map<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span> m<span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在将<code>vector</code>中的前几个整型字符串对使用<code>std::copy_n</code>拷贝到<code>map</code>中。因为<code>vector</code>和<code>map</code>是两种完全不同的结构体，我们需要对<code>vector</code>中的数据进行变换，这里就要使用到<code>insert_iterator</code>适配器。<code>std::inserter</code>函数为我们提供了一个适配器。在算法中使用类似<code>std::copy_n</code>的算法时，需要与插入迭代器相结合，这是一种更加通用拷贝/插入元素的方式(从一种数据结构到另一种数据结构)，但这种方式不是最快的。使用指定数据结构的成员函数插入元素无疑是更加高效的方式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">copy_n</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token function">inserter</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>让我们打印一下<code>map</code>中的内容。纵观本书，我们会经常使用<code>std::copy</code>函数来打印容器的内容。<code>std::ostream_iterator</code>在这里很有用，因为其可以将用户的标准输出作为另一个容器，而后将要输出的内容拷贝过去：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">shell_it</span> <span class="token punctuation">(</span>ostream_iterator<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span>
    <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	<span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span> shell_it<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>对<code>map</code>进行清理，然后进行下一步的实验。这次，我们会将<code>vector</code>的元素<em>移动</em>到<code>map</code>中，并且是所有元素：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    m<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	<span class="token function">move</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">inserter</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将再次打印<code>map</code>中的内容。此外，<code>std::move</code>是一种改变数据源的算法，这次我们也会打印<code>vector</code>。这样，我们就会看到算法时如何对数据源进行的移动：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span> shell_it<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    
	<span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> shell_it<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行这个程序，看看会发生什么。第一二行非常简单，其反应的就是<code>copy_n</code>和<code>move</code>算法执行过后的结果。第三行比较有趣，因为移动算法将其源搬移到<code>map</code>中，所以这时的<code>vector</code>是空的。在重新分配空间前，我们通常不应该访问成为移动源的项。但是为了这个实验，我们忽略它：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">copying_items</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> one<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> two<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> three<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> one<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> two<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> three<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> four<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> five<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>std::copy</code>是STL中最简单的算法之一，其实现也非常短。我们可以看一下等价实现：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">InputIterator</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">OutputIterator</span><span class="token operator">&gt;</span>
OutputIterator <span class="token function">copy</span><span class="token punctuation">(</span>InputIterator it<span class="token punctuation">,</span> InputIterator end_it<span class="token punctuation">,</span>
OutputIterator out_it<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> end_it<span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">,</span> <span class="token operator">++</span>out_it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token operator">*</span>out_it <span class="token operator">=</span> <span class="token operator">*</span>it<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> out_it<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>这段代码很朴素，使用<code>for</code>循环将一个容器中的元素一个个的拷贝到另一个容器中。此时，有人就可能会发问："使用<code>for</code>循环的实现非常简单，并且还不用返回值。为什么要在标准库实现这样的算法？"，这是个不错的问题。</p>
<p><code>std::copy</code>并非能让代码大幅度减少的一个实现，很多其他的算法实现其实非常复杂。这种实现其实在代码层面并不明显，但STL算法更多的在于做了很多底层优化，编译器会选择最优的方式执行算法，这些底层的东西目前还不需要去了解。</p>
<p>STL算法也让能避免让开发者在代码的可读性和优化性上做权衡。</p>
<blockquote>
<p>Note：</p>
<p>如果类型只有一个或多个(使用<code>class</code>或<code>struct</code>包装)的矢量类型或是类，那么其拷贝赋值通常是轻量的，所以可以使用<code>memcopy</code>或<code>memmove</code>进行赋值操作，而不要使用自定义的赋值操作符进行操作。</p>
</blockquote>
<p>这里，我们也使用了<code>std::move</code>。其和<code>std::copy</code>一样优秀，不过<code>std::move(*it)</code>会将循环中的源迭代器，从局部值(左值)转换为引用值(右值)。这个函数就会告诉编译器，直接进行移动赋值操作来代替拷贝赋值操作。对于大多数复杂的对象，这会让程序的性能更好，但会破坏原始对象。</p>
</div></div><div id="ebook-heading-x5bb9x5668x5143x7d20x6392x5e8f" ebook-toc-level-2="" heading="容器元素排序"><div><h1 class="mume-header" id="%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F">容器元素排序</h1>

<p>排序是一项很常见的任务，并且可以通过各种各样的方式进行。每个计算机科学专业的学生，都学过很多排序算法(包括这些算法的性能和稳定性)。</p>
<p>因为这是个已解决的问题，所以开发者没必要浪费时间再次来解决排序问题，除非是出于学习的目的。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将展示如何使用<code>std::sort</code>和<code>std::partial_sort</code>。</p>
<ol>
<li>
<p>首先，包含必要的头文件和声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;random&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将打印整数在<code>vector</code>出现的次数，为了缩短任务代码的长度，我们在这里写一个辅助函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们开始实例化一个<code>vector</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>因为我们将使用不同的排序函数将<code>vector</code>多次打乱，所以我们需要一个随机数生成器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	random_device rd<span class="token punctuation">;</span>
	mt19937 g <span class="token punctuation">{</span><span class="token function">rd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>std::is_sorted</code>函数会告诉我们，容器内部的值是否已经经过排序。所以这行将打印到屏幕上：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token function">is_sorted</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>std::shuffle</code>将打乱<code>vector</code>中的内容，之后我们会再次对<code>vector</code>进行排序。前两个参数是容器的首尾迭代器，第三个参数是一个随机数生成器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在<code>is_sorted</code>函数将返回false，所以0将打印在屏幕上，<code>vector</code>的元素总量和具体数值都没有变，不过顺序发生了变化。我们会将函数的返回值再次打印在屏幕上：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token function">is_sorted</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
	<span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，在通过<code>std::sort</code>对<code>vector</code>进行排序。然后打印是否排序的结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">sort</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">is_sorted</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>另一个比较有趣的函数是<code>std::partition</code>。有时候，并不需要对列表完全进行排序，只需要比它前面的某些值小就可以。所以，让使用<code>partition</code>将数值小于5的元素排到前面，并打印它们：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	<span class="token function">partition</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	<span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>下一个与排序相关的函数是<code>std::partial_sort</code>。我们可以使用这个函数对容器的内容进行排序，不过只是在某种程度上的排序。其会将<code>vector</code>中最小的N个数，放在容器的前半部分。其余的留在<code>vector</code>的后半部分，不进行排序：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">middle</span> <span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">partial_sort</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> middle<span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	<span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>当我们要对没做比较操作符的结构体进行比较，该怎么办呢？让我们来定义一个结构体，然后用这个结构体来实例化一个<code>vector</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">mystruct</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    vector<span class="token operator">&lt;</span>mystruct<span class="token operator">&gt;</span> mv <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    				   <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>std::sort</code>函数可以将比较函数作为第三个参数进行传入。让我们来使用它，并且传递一个比较函数。为了展示其实如何工作的，我们会对其第二个成员b进行比较。这样，我们将按<code>mystruct::b</code>的顺序进行排序，而非<code>mystruct::a</code>的顺序：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">sort</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>mv<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>mv<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> mystruct <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> mystruct <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> lhs<span class="token punctuation">.</span>b <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>最后一步则是打印已经排序的<code>vector</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">:</span> mv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"{"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">"} "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行程序。第一个1是由<code>std::is_sorted</code>所返回的。之后将<code>vector</code>进行打乱后，<code>is_sorted</code>就返回0。第三行是打乱后的<code>vector</code>。下一个1是使用sort之后进行打印的。然后，<code>vector</code>会被再次打乱，并且使用<code>std::partition</code>对部分元素进行排序。我们可以看到所有比5小的元素都在左边，比5大的都在右边。我们暂且将现在的顺序认为是乱序。倒数第二行展示了<code>std::partial_sort</code>的结果。前半部分的内容进行了严格的排序，而后半部分则没有。最后一样，我们将打印<code>mystruct</code>实例的结果。其结果是严格根据第二个成员变量的值进行排序的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>sorting_containers
<span class="token number">1</span>
<span class="token number">0</span>
<span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span>
<span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span>
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span>
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span>
<span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">}</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>这里我们使用了很多与排序算法相关的函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">算法函数</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://zh.cppreference.com/w/cpp/algorithm/sort">std::sort</a></td>
<td style="text-align:left">接受一定范围的元素，并对元素进行排序。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://zh.cppreference.com/w/cpp/algorithm/is_sorted">std::is_sorted</a></td>
<td style="text-align:left">接受一定范围的元素，并判断该范围的元素是否经过排序。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://zh.cppreference.com/w/cpp/algorithm/random_shuffle">std::shuffle</a></td>
<td style="text-align:left">类似于反排序函数；其接受一定范围的元素，并打乱这些元素。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://zh.cppreference.com/w/cpp/algorithm/partial_sort">std::partial_sort</a></td>
<td style="text-align:left">接受一定范围的元素和另一个迭代器，前两个参数决定排序的范围，后两个参数决定不排序的范围。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://zh.cppreference.com/w/cpp/algorithm/partition">std::partition</a></td>
<td style="text-align:left">能够接受谓词函数。所有元素都会在谓词函数返回true时，被移动到范围的前端。剩下的将放在范围的后方。</td>
</tr>
</tbody>
</table>
<p>对于没有实现比较操作符的对象来说，想要排序就需要提供一个自定义的比较函数。其签名为<code>bool function_name(const T &amp;lhs, const T &amp;rhs)</code>，并且在执行过程中无副作用。</p>
<p>当然排序还有其他类似<code>std::stable_sort</code>的函数，其能保证排序后元素的原始顺序，<code>std::stable_partition</code>也有类似的功能。</p>
<blockquote>
<p>Note:</p>
<p><code>std::sort</code>对于排序有不同的实现。根据所提供的迭代器参数，其实现分为选择排序、插入排序、合并排序，对于元素数量较少的容器可以完全进行优化。在使用者的角度，我们通常都不需要了解这些。</p>
</blockquote>
</div></div><div id="ebook-heading-x4ecex5bb9x5668x4e2dx5220x9664x6307x5b9ax5143x7d20" ebook-toc-level-2="" heading="从容器中删除指定元素"><div><h1 class="mume-header" id="%E4%BB%8E%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0">从容器中删除指定元素</h1>

<p>复制、转换和过滤是对一段数据常做的操作。本节，我们将重点放在过滤元素上。</p>
<p>将过滤出的元素从数据结构中移除，或是简单的移除其中一个，但对于不同数据结构来说，操作上就完全不一样了。在链表中(比如<code>std::list</code>)，只要将对应节点的指针进行变动就好。不过，对于连续存储的结构体来说(比如<code>std::vector</code>，<code>std::array</code>，还有部分<code>std::deque</code>)，删除相应的元素时，将会有其他元素来替代删除元素的位置。当一个元素槽空出来后，那么后面所有的元素都要进行移动，来将这个空槽填满。这个听起来都很麻烦，不过本节中我们只是想要从字符串中移除空格，这个功能没有太多的工作量。</p>
<p>当我们定义了一个结构体时，我们是不会考虑如何将其元素进行删除的。当需要做这件事的时候，我们才会注意到。STL中的<code>std::remove</code>和<code>std::remove_if</code>函数可以给我们提供帮助。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将通过不同的方式将<code>vector</code>中的元素进行删除：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>一个简单的打印辅助函数，用来打印<code>vector</code>中的内容：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们将使用简单的整数对<code>vector</code>进行实例化。然后，对<code>vector</code>进行打印，这样就能和后面的结果进行对比：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，我们移除<code>vector</code>中所有的2。<code>std::remove</code>将2值移动到其他位置，这样这个值相当于消失了。因为<code>vector</code>长度在移除元素后变短了，<code>std::remove</code>将会返回一个迭代器，这个迭代器指向新的末尾处。旧的<code>end</code>迭代器所指向的地方，实际上就没有什么意义了，所以我们可以告诉<code>vector</code>将这个位置进行擦除。我们使用两行代码来完成这个任务：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">{</span>
        <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">new_end</span> <span class="token punctuation">(</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>new_end<span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，我们来移除奇数。为了完成移除，我们需要实现一个谓词函数，这个函数用来告诉程序哪些值是奇数，然后结合<code>std::remove_if</code>来使用。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">odd_number</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">new_end</span> <span class="token punctuation">(</span>
        	<span class="token function">remove_if</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> odd_number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>new_end<span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>下一个尝试的算法是<code>std::replace</code>。我们使用这个函数将所有4替换成123。与<code>std::replace</code>函数对应，<code>std::replace_if</code>也存在于STL中，同样可以接受谓词函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">replace</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>让我们重新初始化<code>vector</code>，并为接下来的实验创建两个空的<code>vector</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
	vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v2<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v3<span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后，我们实现两个判读奇偶数的谓词函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">odd_number</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-auto">auto</span> <span class="token function">even_number</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>接下来的两行做的事情完全相同。其将偶数拷贝到v2和v3中。第一行使用<code>std::remove_copy_if</code>函数，当相应数值不满足谓词条件时，函数会从源容器中拷贝到另一个容器中。第二行<code>std::copy_if</code>则是拷贝满足谓词条件的元素。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">remove_copy_if</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>
    	<span class="token function">back_inserter</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">,</span> odd_number<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">copy_if</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>
    	<span class="token function">back_inserter</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span><span class="token punctuation">,</span> even_number<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>然后，打印这两个<code>vector</code>，其内容应该是完全相同的。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">print</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行程序。第一行输出的是<code>vector</code>初始化的值。第二行是移除2之后的内容。接下来一行是移除所有奇数后的结果。第4行是将4替换为123的结果。最后两行则是v2和v3中的内容：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>removing_items_from_containers
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span>
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span>
<span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span>
<span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span>
<span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span>
<span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>这里我们使用了很多与排序算法相关的函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">算法函数</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://zh.cppreference.com/w/cpp/algorithm/remove">std::remove</a></td>
<td style="text-align:left">接受一个容器范围和一个具体的值作为参数，并且移除对应的值。返回一个新的end迭代器，用于修改容器的范围。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://zh.cppreference.com/w/cpp/algorithm/replace">std::replace</a></td>
<td style="text-align:left">接受一个容器范围和两个值作为参数，将使用第二个数值替换所有与第一个数值相同的值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://zh.cppreference.com/w/cpp/algorithm/remove_copy">std::remove_copy</a></td>
<td style="text-align:left">接受一个容器范围，一个输出迭代器和一个值作为参数。并且将所有不满足条件的元素拷贝到输出迭代器的容器中。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://zh.cppreference.com/w/cpp/algorithm/replace_copy">std::replace_copy</a></td>
<td style="text-align:left">与<code>std::replace</code>功能类似，但与<code>std::remove_copy</code>更类似些。源容器的范围并没有变化。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://zh.cppreference.com/w/cpp/algorithm/copy">std::copy_if</a></td>
<td style="text-align:left">与<code>std::copy</code>功能相同，可以多接受一个谓词函数作为是否进行拷贝的依据。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note:</p>
<p>表中没有if的算法函数，都有一个*_if版本存在，其能接受谓词函数，通过谓词函数判断的结果来进行相应的操作。</p>
</blockquote>
</div></div><div id="ebook-heading-x6539x53d8x5bb9x5668x5185x5bb9" ebook-toc-level-2="" heading="改变容器内容"><div><h1 class="mume-header" id="%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8%E5%86%85%E5%AE%B9">改变容器内容</h1>

<p>如果说<code>std::copy</code>是STL中最简单的算法，那么<code>std::transform</code>就是第二简单的算法。和<code>copy</code>类似，其可将容器某一范围的元素放置到其他容器中，在这个过程中允许进行一些变换(变换函数会对输入值进行一定操作，然后再赋给目标容器)。此外，两个具有不同元素类型的容间也可以使用这个函数。这个函数超级简单，并且非常有用，这个函数会让标准组件具有更好的可移植性。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将使用<code>std::transform</code>在拷贝的同时，修改<code>vector</code>中的元素：</p>
<ol>
<li>
<p>包含必要的头文件，并且声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>vector</code>由简单的整数组成：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了打印元素，会将所有元拷贝素到<code>ostream_iterator</code>适配器中。<code>transform</code>函数可以接受一个函数对象，其能在拷贝过程中对每个元素进行操作。这个例子中，我们将计算每个元素的平方值，所以代码将打印出平方数。因为直接进行了打印，所以平方数并没有进行保存：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">transform</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>
        ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>再来做另一个变换。例如，对于数字3来说，显示成<code>3^2 = 9</code>显然有更好的可读性。下面的辅助函数<code>int_to_string</code>函数对象就会使用<code>std::stringstream</code>对象进行打印操作：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">int_to_string</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    stringstream ss<span class="token punctuation">;</span>
    ss <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"^2 = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> ss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>这样就可以将整型值放入字符串中。可以说我么将这个证书映射到字符串中。使用<code>transform</code>函数，使我们可以拷贝所有数值到一个字符串<code>vector</code>中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> vs<span class="token punctuation">;</span>

    <span class="token function">transform</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span><span class="token punctuation">,</span>
    	int_to_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>在打印完成后，我们的例子就结束了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span><span class="token punctuation">,</span>
   		ostream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>transforming_items_in_containers
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span>
<span class="token number">1</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">=</span> <span class="token number">4</span>
<span class="token number">3</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">=</span> <span class="token number">9</span>
<span class="token number">4</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">=</span> <span class="token number">16</span>
<span class="token number">5</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">=</span> <span class="token number">25</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>std::transform</code>函数工作原理和<code>std::copy</code>差不多，不过在拷贝的过程中会对源容器中的元素进行变换，这个变换函数由用户提供。</p>
</div></div><div id="ebook-heading-x5728x6709x5e8fx548cx65e0x5e8fx7684vectorx4e2dx67e5x627ex5143x7d20" ebook-toc-level-2="" heading="在有序和无序的vector中查找元素"><div><h1 class="mume-header" id="%E5%9C%A8%E6%9C%89%E5%BA%8F%E5%92%8C%E6%97%A0%E5%BA%8F%E7%9A%84vector%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0">在有序和无序的vector中查找元素</h1>

<p>通常，需要确定某种元素在某个容器范围内是否存在。如果存在，我们会对这个值进行修改，或者访问与其相关的值。</p>
<p>查找元素的目的是不同的。当想要让在一段已排序的元素中进行查找，可以使用二分查找法，这种方法要比线性查找快的多。如果没有排序，那么就只能进行线性遍历来查找对应的值。</p>
<p>传统的STL查找算法我们都可以使用，所以了解一下这些算法。本节将会使用两个不同的算法，线性查找算法<code>std::find</code>，二分查找算法<code>std::equal_range</code>。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将对一个比较小的数据集进行线性和二分查找：</p>
<ol>
<li>
<p>包含必要的头文件，以及声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>数据集会包含<code>city</code>结构体，只是存储的城市的名字和人口数量：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">city</span> <span class="token punctuation">{</span>
    string name<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> population<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>	
</pre></li>
<li>
<p>搜索算法需要将元素与目标对象进行对比，所以我们需要重载<code>city</code>结构体的<code>==</code>操作符：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-bool">bool</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> city <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> city <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> a<span class="token punctuation">.</span>name <span class="token operator">==</span> b<span class="token punctuation">.</span>name <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span>population <span class="token operator">==</span> b<span class="token punctuation">.</span>population<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们也需要将<code>city</code>实例进行打印，所以我们对其输出操作符<code>&lt;&lt;</code>也进行了重载：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">ostream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> city <span class="token operator">&amp;</span>city<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> os <span class="token operator">&lt;&lt;</span> <span class="token string">"{"</span> <span class="token operator">&lt;&lt;</span> city<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>
    	<span class="token operator">&lt;&lt;</span> city<span class="token punctuation">.</span>population <span class="token operator">&lt;&lt;</span> <span class="token string">"}"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>查找函数通常会返回迭代器。当函数找到相应的元素时，会返回指向其的迭代器，否则就会返回容器的<code>end</code>迭代器。第二种情况下，我们就不能对该迭代器进行访问。因为要打印输出结果，所以需要实现一个函数，这个函数会返回另一个函数对象，并会将数据结构的<code>end</code>迭代器进行包装。当要对结果进行打印时，会与容器的<code>end</code>迭代器相比较，如果不是<code>end</code>，那么打印出查找到的值；如果是<code>end</code>，则仅打印<code>&lt;end&gt;</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">C</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">opt_print</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> C <span class="token operator">&amp;</span>container<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token function">end_it</span> <span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>item <span class="token operator">!=</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>item <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&lt;end&gt;\n"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们使用德国的一些城市对<code>vector</code>进行实例化：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> vector<span class="token operator">&lt;</span>city<span class="token operator">&gt;</span> c <span class="token punctuation">{</span>
        <span class="token punctuation">{</span><span class="token string">"Aachen"</span><span class="token punctuation">,</span> <span class="token number">246000</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"Berlin"</span><span class="token punctuation">,</span> <span class="token number">3502000</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"Braunschweig"</span><span class="token punctuation">,</span> <span class="token number">251000</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token string">"Cologne"</span><span class="token punctuation">,</span> <span class="token number">1060000</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>使用这个辅助函数构造一个城市打印函数，其会获取到城市<code>vector</code>容器的<code>end</code>迭代器<code>c</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">print_city</span> <span class="token punctuation">(</span><span class="token function">opt_print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>使用<code>std::find</code>在<code>vector</code>中找到相应的元素——科隆(Cologne)。因为可以直接获得这个元素，所以这个搜索看起来毫无意义。不过，在查找之前并不知道这个元素在<code>vector</code>中的位置，而<code>find</code>函数告诉我们这个元素的具体位置。我们也可以写一个循环，仅对城市名进行比较，而无需比较人口数量。不过，这是个不是很好的设计。下一步，我们将做另外一个实验：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">found_cologne</span> <span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span>
        	city<span class="token punctuation">{</span><span class="token string">"Cologne"</span><span class="token punctuation">,</span> <span class="token number">1060000</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print_city</span><span class="token punctuation">(</span>found_cologne<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>当不需要知道对应城市的人口数量时，就不需要使用<code>==</code>操作符，只需要比较城市名称就好。<code>std::find_if</code>函数可以接受一个函数对象作为谓词函数。这样，就能只使用城市名来查找“科隆”了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">found_cologne</span> <span class="token punctuation">(</span><span class="token function">find_if</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span>
        	<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> item<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">"Cologne"</span><span class="token punctuation">;</span>
        	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print_city</span><span class="token punctuation">(</span>found_cologne<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>为了让搜索更加优雅，可以实现谓词构建器。<code>population_higher_than</code>函数对象能接受一个人口数量，并且返回人口数量比这个数量多的城市。在这个小数据集中找一下多于2百万人口的城市。例子中，只有柏林(Berlin)符合条件：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">population_more_than</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> city <span class="token operator">&amp;</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> item<span class="token punctuation">.</span>population <span class="token operator">&gt;</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">found_large</span> <span class="token punctuation">(</span><span class="token function">find_if</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span>
    	<span class="token function">population_more_than</span><span class="token punctuation">(</span><span class="token number">2000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_city</span><span class="token punctuation">(</span>found_large<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><ol start="11">
<li>
<p>使用的查找函数，线性的遍历容器，查找的时间复杂度为O(n)。STL也有二分查找函数，其时间复杂度为O(log(n))。让我们生成一个新的数据集，其包含了一些整数，并构建了另一个<code>print</code>函数:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-const">const</span> vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-auto">auto</span> <span class="token function">print_int</span> <span class="token punctuation">(</span><span class="token function">opt_print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>std::binary_search</code>函数会返回一个布尔值，这个布尔值会告诉你函数是否找到了相应的元素，但是不会将指向元素的迭代器返回。二分查找需要查找的列表是已排序的，否则二分查找将出错：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-bool">bool</span> contains_7 <span class="token punctuation">{</span><span class="token function">binary_search</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> contains_7 <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>如果需要获得查找的元素，就需要使用其他STL函数。其中之一就是<code>std::equal_range</code>。其不会返回对应元素的迭代器给我们，不过会返回一组迭代器。第一个迭代器是指向第一个不小于给定值的元素。第二个迭代器指向第一个大于给定值的元素。我们的范围为数字1到10，那么第一个迭代器将指向7，因为其是第一个不小于7的元素。第二个迭代器指向8，因为其实第一个大于7的元素：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token punctuation">[</span>lower_it<span class="token punctuation">,</span> upper_it<span class="token punctuation">]</span> <span class="token punctuation">(</span>
		<span class="token function">equal_range</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">print_int</span><span class="token punctuation">(</span>lower_it<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">print_int</span><span class="token punctuation">(</span>upper_it<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>当需要其中一个迭代器，可以使用<code>std::lower_bound</code>或<code>std::upper_bound</code>。<code>lower_bound</code>函数只会返回第一个迭代器，而<code>upper_bound</code>则会返回第二个迭代器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">print_int</span><span class="token punctuation">(</span><span class="token function">lower_bound</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">print_int</span><span class="token punctuation">(</span><span class="token function">upper_bound</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行这个程序，我们看到如下输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>finding_items
<span class="token punctuation">{</span>Cologne<span class="token punctuation">,</span> <span class="token number">1060000</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span>Cologne<span class="token punctuation">,</span> <span class="token number">1060000</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span>Berlin<span class="token punctuation">,</span> <span class="token number">3502000</span><span class="token punctuation">}</span>
<span class="token number">1</span>
<span class="token number">7</span>
<span class="token number">8</span>
<span class="token number">7</span>
<span class="token number">8</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节使用的STL查找算法：</p>
<table>
<thead>
<tr>
<th>算法函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/algorithm/find">std::find</a></td>
<td>可将一个搜索范围和一个值作为参数。函数将返回找到的第一个值的迭代器。线性查找。</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/algorithm/find">std::find_if</a></td>
<td>与<code>std::find</code>原理类似，不过其使用谓词函数替换比较值。</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/algorithm/binary_search">std::binary_search</a></td>
<td>可将一个搜索范围和一个值作为参数。执行二分查找，当找到对应元素时，返回true；否则，返回false。</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound">std::lower_bound</a></td>
<td>可将一个查找返回和一个值作为参数，并且执行二分查找，返回第一个不小于给定值元素的迭代器。</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/algorithm/upper_bound">std::upper_bound</a></td>
<td>与<code>std::lower_bound</code>类似，不过会返回第一个大于给定值元素的迭代器。</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/algorithm/equal_range">std::equal_range</a></td>
<td>可将一个搜索范围和一个值作为参数，并且返回一对迭代器。其第一个迭代器和<code>std::lower_bound</code>返回结果一样，第二个迭代器和<code>std::upper_bound</code>返回结果一样。</td>
</tr>
</tbody>
</table>
<p>所有这些函数，都能接受一个自定义的比较函数作为可选参数传入。这样就可以自定义的进行查找，就如我们在本章做的那样。</p>
<p>来看一下<code>std::equal_range</code>是如何工作的。假设我们有一个<code>vector</code>，<code>v = {0, 1, 2, 3, 4, 5, 6, 7, 7, 7, 8}</code>，并且调用<code>equal_range(begin(v), end(v), 7);</code>，为了执行对7的二分查找。如<code>equal_range</code>要返回一对上下限迭代器那样，这个结果将返回一段区域<code>{7, 7, 7}</code>，因为原始<code>vector</code>中有很多7，所以这个子队列中也有很多7。下图能说明其运行的原理：</p>
<p><img src="./C++17 STL Cook book_files/5-5-1.png" alt=""></p>
<p>首先，<code>equal_range</code>会使用典型的二分查找，直到其找到那个不小于查找值的那个元素。而后，另一个迭代器也是用同样的方式找到。如同分开调用<code>lower_bound</code>和<code>upper_bound</code>一样。</p>
<p>为了获得一个二分查找函数，并返回其第一个适配条件的元素。我们可以按照如下的方式实现：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
Iterator <span class="token function">standard_binary_search</span><span class="token punctuation">(</span>Iterator it<span class="token punctuation">,</span> Iterator end_it<span class="token punctuation">,</span> T value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">potential_match</span> <span class="token punctuation">(</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> end_it<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>potential_match <span class="token operator">!=</span> end_it <span class="token operator">&amp;&amp;</span> value <span class="token operator">==</span> <span class="token operator">*</span>potential_match<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> potential_match<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> end_it<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>这个函数使用<code>std::lower_bound</code>，为的就是找到第一个不大于<code>value</code>的元素。返回结果<code>potential_match</code>，有三种情况：</p>
<ul>
<li>没有值不小于<code>value</code>。这样，返回值和<code>end_it</code>(<code>end</code>迭代器)一样。</li>
<li>遇到的第一个不小于<code>value</code>的元素，同时也大于<code>value</code>。因此需要返回<code>end_it</code>，表示没有找到相应的值。</li>
<li><code>potential_match</code>指向的元素与<code>value</code>相同。这个匹配没毛病。因此就返回相应的迭代器。</li>
</ul>
<p>当类型T没有<code>==</code>操作符时，需要为二分查找提供一个<code>&lt;</code>操作实现。然后，可以将比较重写为<code>!(value &lt; *potential_match) &amp;&amp; !(*potential_match &lt; value)</code>。如果它们不小于，也不大于，那么必定等于。</p>
<p>STL中因为缺少对多次命中的“定义”，所以并没有提供相应的函数来适配多次命中。</p>
<blockquote>
<p>Note：</p>
<p>需要留意<code>std::map</code>和<code>std::set</code>等数据结构，它们有自己的<code>find</code>函数。它们携带的<code>find</code>函数要比通用的算法快很多，因为他们的实现与数据结构强耦合。</p>
</blockquote>
</div></div><div id="ebook-heading-x5c06vectorx4e2dx7684x503cx63a7x5236x5728x7279x5b9ax6570x503cx8303x56f4x5185x2014x2014stdclamp" ebook-toc-level-2="" heading="将vector中的值控制在特定数值范围内——std::clamp"><div><h1 class="mume-header" id="%E5%B0%86vector%E4%B8%AD%E7%9A%84%E5%80%BC%E6%8E%A7%E5%88%B6%E5%9C%A8%E7%89%B9%E5%AE%9A%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4%E5%86%85stdclamp">将vector中的值控制在特定数值范围内——std::clamp</h1>

<p>很多应用中，需要获得相应的数据。在对其进行绘制或进行其他处理前，会先对这些数据进行归一化，因为这些数据的差距很大。</p>
<p>通常可以使用<code>std::transform</code>通过传入一个谓词函数，对数据结构中的所有数据进行处理。不过，当不知道这些值有多大时或多小时，需要通过相应的函数找到数值的范围。</p>
<p>STL就包含这样的函数，比如<code>std::minmax_element</code>和<code>std::clamp</code>。将这些函数与Lambda函数相结合，可以解决一些简单的任务。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，将<code>vector</code>中的值使用两种不同的方式进行归一化，一种使用<code>std::minmax_element</code>，另一种使用<code>std::clamp</code>：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>将实现一个获得最大值和最小值的函数。这里最大值和最小值会更新，以便我们进行处理。函数对象会获取最大最小值，并返回另一个函数对象，这个返回的函数对象会做一些实际的转换。为了简单起见，新的最小值为0，所以旧值不需要进行偏移，并且值的归一化都是相对于0。为了有更好的可读性，这里忽略了最大值和最小值可能是一个值的可能性，不过在实际程序中需要格外注意这点，否则就会遇到除零问题：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">norm</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> min<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> max<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> new_max<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-double">double</span> <span class="token function">diff</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">/</span> diff <span class="token operator">*</span> new_max<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>另一个函数对象构造器成为<code>clampval</code>，其会返回一个函数对象用于捕获最小值和最大值，并调用<code>std::clamp</code>将值控制在一定范围内：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">clampval</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> min<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> max<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> val<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword keyword-int">int</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">clamp</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> min<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p><code>vector</code>中需要归一化的值大小不一。这些数据可能是热度数据、海拔高度或股票金额：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">,</span> <span class="token number">321</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为对这些值进行归一化，我们需要找到这个<code>vector</code>中的最大值和最小值。<code>std::minmax_element</code>函数将帮助我们获得这两个值。其会返回一组迭代器来代表这两个值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token punctuation">[</span>min_it<span class="token punctuation">,</span> max_it<span class="token punctuation">]</span> <span class="token punctuation">(</span>
		<span class="token function">minmax_element</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们会将所有值从第一个<code>vector</code>拷贝到另一个中。让我们实例化第二个<code>vector</code>，并且让其接收第一个<code>vector</code>中的值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v_norm<span class="token punctuation">;</span>
    v_norm<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>使用<code>std::transform</code>从第一个<code>vector</code>拷贝到第二个<code>vector</code>。拷贝过程中，将会使用到归一化辅助函数。之前的最大值和最小值为0和1000。在归一化之后，为0和255：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">transform</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>v_norm<span class="token punctuation">)</span><span class="token punctuation">,</span>
    	<span class="token function">norm</span><span class="token punctuation">(</span><span class="token operator">*</span>min_it<span class="token punctuation">,</span> <span class="token operator">*</span>max_it<span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>在实现另一个归一化策略之前，先将这个操作过后的结果进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v_norm<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v_norm<span class="token punctuation">)</span><span class="token punctuation">,</span>
		ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>对已经归一化的<code>vector</code>使用<code>clampval</code>，这时的最大值和最小值分别为255和0：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token function">transform</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>v_norm<span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">clampval</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>完成之后，打印所有元素：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v_norm<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v_norm<span class="token punctuation">)</span><span class="token punctuation">,</span>
		ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>	
</pre></li>
<li>
<p>编译并运行程序。当前值的范围都在0到255之间，我们可以将其认为是RGB颜色的亮度值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>reducing_range_in_vector
<span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">,</span> <span class="token number">76</span><span class="token punctuation">,</span> <span class="token number">204</span><span class="token punctuation">,</span> <span class="token number">229</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">,</span>
<span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span>
</pre></li>
<li>
<p>我们将对应的数据进行绘制，就得到了如下的图像。我们可以看到，使用最大最小值对原始数据进行变换，得到的数据时线性的。clamp曲线会损失一些信息。两种不同的结果在不同的情况下会很有用：</p>
<p><img src="./C++17 STL Cook book_files/5-6-1.png" alt=""></p>
</li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>除了<code>std::transform</code>，我们使用量两个算法：</p>
<p><code>std::minmax_element</code>能接受一对<code>begin</code>和<code>end</code>迭代器作为输入。其会对这个范围进行遍历，然后找到这个范围内的最大值和最小值。其返回值是一个组对，我们会在我们的缩放函数中使用这个组对。</p>
<p><code>std::clamp</code>函数无法对一个范围进行可迭代操作。其接受三个值作为参数：一个给定值，一个最小值，一个最大值。这个函数的返回值则会将对应的值截断在最大值和最小值的范围内。我们也能使用<code>max(min_val, min(max_val, x))</code>来替代<code>std::clamp(x, min_val, max_val)</code>。</p>
</div></div><div id="ebook-heading-x5728x5b57x7b26x4e32x4e2dx5b9ax4f4dx6a21x5f0fx5e76x9009x62e9x6700x4f73x5b9ex73b0x2014x2014stdsearch" ebook-toc-level-2="" heading="在字符串中定位模式并选择最佳实现——std::search"><div><h1 class="mume-header" id="%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AE%9A%E4%BD%8D%E6%A8%A1%E5%BC%8F%E5%B9%B6%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E5%AE%9E%E7%8E%B0stdsearch">在字符串中定位模式并选择最佳实现——std::search</h1>

<p>在一个字符串中查找另一个字符串，与在一个范围内查找一个对象有些不同。首先，字符串是可迭代的对象。另一方面，从一个字符串中查询另一个字符串，就意味着就是在一个范围内查询另一个范围。所以在查找过程中，有多次的比较，所以我们需要其他算法参与。</p>
<p><code>std::string</code>就包含<code>find</code>函数，其能实现我们想要的；不过，本节我们将使用<code>std::search</code>来完成这个任务。虽然，<code>std::search</code>在字符串中会大量的用到，不过很多种容器都能使用这个算法来完成查找任务。C++17之后，<code>std::search</code>添加了更多有趣的特性，并且其本身可使用简单地交换搜索算法。这些算法都优化过，并且免费提供给开发者使用。另外，我们可以实现自己的搜索算法，并且可以将我们实现的算法插入<code>std::search</code>中。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将对字符串使用新<code>std::search</code>函数，并且尝试使用其不同的查找对象进行应用：</p>
<ol>
<li>
<p>首先，包含必要的头文件，和声明所要使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将实现一个辅助函数，用于打印查找算法所范围的位置，从而输出子字符串。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Itr</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span>Itr it<span class="token punctuation">,</span> size_t chars<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">copy_n</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> chars<span class="token punctuation">,</span> ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们例子输入的一个勒庞风格的字符串，其中包含我们要查找的字符串。本例中，这个需要查找的字符串为"elitr":</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> string long_string <span class="token punctuation">{</span>
        <span class="token string">"Lorem ipsum dolor sit amet, consetetur"</span>
        <span class="token string">" sadipscing elitr, sed diam nonumy eirmod"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> string needle <span class="token punctuation">{</span><span class="token string">"elitr"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>旧<code>std::search</code>接口接受一组<code>begin</code>和<code>end</code>迭代器，用于确定子字符串的查找范围。这个接口会返回一个迭代器指向所查找到的子字符串。如果接口没有找到对应的字符串，其将返回该范围的<code>end</code>迭代器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">match</span> <span class="token punctuation">(</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>long_string<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>long_string<span class="token punctuation">)</span><span class="token punctuation">,</span>
        				 <span class="token function">begin</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>match<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>C++17版本的<code>std::search</code>将会使用一组<code>begin/end</code>迭代器和一个所要查找的对象。<code>std::default_searcher</code>能接受一组子字符串的<code>begin</code>和<code>end</code>迭代器，再在一个更大的字符串中，查找这个字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">match</span> <span class="token punctuation">(</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>long_string<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>long_string<span class="token punctuation">)</span><span class="token punctuation">,</span>
        	<span class="token function">default_searcher</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>match<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>这种改变就很容易切换搜索算法。<code>std::boyer_moore_searcher</code>使用Boyer-Moore查找算法进行快速的查找：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">match</span> <span class="token punctuation">(</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>long_string<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>long_string<span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">boyer_moore_searcher</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>match<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>	
</pre></li>
<li>
<p>C++17标准中，有三种不同的搜索器对象实现。其中还有一种是Boyer-Moore-Horspool查找算法实现：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">match</span> <span class="token punctuation">(</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>long_string<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>long_string<span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">boyer_moore_horspool_searcher</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">end</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>match<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们编译并运行这个程序。我们可以看到相同的字符串输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>pattern_search_string
elitr
elitr
elitr
elitr
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>我们在<code>std::search</code>中使用了4种查找方式，得到了相同的结果。这几种方式适用于哪种情况呢？</p>
<p>让我们假设大字符串为<code>s</code>，要查找的部分为<code>p</code>。然后，调用<code>std::search(begin(s), end(s), begin(p), end(p));</code>和<code>std::search(begin(s), end(s), default_searcher(begin(p), end(p));</code>做相同的事情。</p>
<p>其他搜索方式将会以更复杂的方式实现：</p>
<ul>
<li><code>std::default_searcher</code>：其会重定向到<code>std::search</code>的实现。</li>
<li><code>std::boyer_moore_searcher</code>：使用Boyer-Moore查找算法。</li>
<li><code>std::boyer_moore_horspool_searcher</code>：使用Boyer-Moore-Horspool查找算法。</li>
</ul>
<p>为什么会有这些特殊的算法呢？Boyer-Moore算法起源于一个特殊想法——查找部分与原始字符串进行比较，其始于查找字符串的尾部，并且从右到左查找。如果查找的字符多个位置不匹配，并且对应部分没有出现，那么就需要在整个字符串进行平移，然后在进行查找。下图可能会看的更加明白一些。先来看一下第一步发生了什么：因为算法已知所要匹配字符串的长度，所以需要对相应位置上的字符进行比较，然后在平移到下一个长度点进行比较。在图中，这发生在第二步。这样Boyer-Moore算法就能避免对不必要的字符进行比较。</p>
<p><img src="./C++17 STL Cook book_files/5-7-1.png" alt=""></p>
<p>当然，在我们没有提供新的比较查找算法时，Boyer-Moore为默认的查找算法。其要比原先默认的算法快很多，不过其需要快速查找的数据结果进行支持，以判断搜索字符是否存在于查找块中，以及以多少为偏移进行定位。编译器将选择不同复杂度的算法实现，这取决于其所使用到的数据类型(对复杂类型的哈希映射和类型的原始查找表进行更改)。最后，默认的查找算法在查询不是很长的字符串也是非常的快。如果需要查找算法提高性能，那么Boyer-Moore将会是个不错的选择。</p>
<p>Boyer-Moore-Horspool为简化版的Boyer-Moore算法。其丢弃了“坏字符”规则，当对应字符串没有找到时，将会对整个查找块进行偏移。需要权衡的是，这个算法要比Boyer-Moore算法慢，但是其不需要对那么多特殊的数据结构进行操作。</p>
<blockquote>
<p>Note：</p>
<p>不要试图尝试比较哪种算法在哪种情况下更快。你可以使用自己实际的例子进行测试，并且基于你得到的结果进行讨论。</p>
</blockquote>
</div></div><div id="ebook-heading-x5bf9x5927vectorx8fdbx884cx91c7x6837" ebook-toc-level-2="" heading="对大vector进行采样"><div><h1 class="mume-header" id="%E5%AF%B9%E5%A4%A7vector%E8%BF%9B%E8%A1%8C%E9%87%87%E6%A0%B7">对大vector进行采样</h1>

<p>有时我们需要处理非常庞大的数据量，不可能在短时间内处理完这些数据。这样的话，数据可能就需要采样来减少要处理的数据量，从而加速整个处理过程。另一些情况下，不减少数据量也能加快程序处理的速度，不过这需要对一些数据进行存储或变换。</p>
<p>采样最原始的方式是每隔N个数据点，采样一次。在大多数情况下这样做没有问题，但是在信号处理中，其会引发一种称为<strong>混淆</strong>的数学情况。当减少两个随机采样点的距离时，这种现象会减弱。我们看一下下面的图，这张图就很能说明问题——当原始信号为一个sin波时，图例为三角的曲线就表示对这个曲线进行每隔100个点的取样。</p>
<p><img src="./C++17 STL Cook book_files/5-8-1.png" alt=""></p>
<p>不幸的是，其采样得到的值都是同一个Y值！连接起来就是与X轴平行的一条线。平方点采样，其每隔<code>100+random(-15, +15)</code>个值进行采样。不过，这样连接起来的曲线看起来和原始的曲线还是相差很远，所以在这个例子中就不能以固定的步长进行采样。</p>
<p><code>std::sample</code>函数不会添加随机值来改变采样的步长，而是采用完全随机的点进行采样。所以其工作方式与上图所显示的大为不同。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将对一个具有随机值的大vector进行采样。随机数据符合正态分布。采样结果也要符合正态分布，来让我们看下代码：</p>
<ol>
<li>
<p>首先包含必要的头文件，以及声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;random&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>使用常数直接对变量进行初始化。第一个值代表了<code>vector</code>的的长度，第二个数代表了采样的步长：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> size_t data_points <span class="token punctuation">{</span><span class="token number">100000</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> size_t sample_points <span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们要使用符合正态分布的随机值生成器来将<code>vector</code>填满。这里先来确定正太分布的平均值和标准差：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> mean <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-const">const</span> size_t dev <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，我们来设置随机数生成器。首先，我们实例化一个随机设备，然后给定一个随机种子，对生成器进行初始化。然后，就可以得到对应分布的随机生成器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	random_device rd<span class="token punctuation">;</span>
	mt19937 gen <span class="token punctuation">{</span><span class="token function">rd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	normal_distribution<span class="token operator">&lt;</span><span class="token operator">&gt;</span> d <span class="token punctuation">{</span>mean<span class="token punctuation">,</span> dev<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>对<code>vector</code>进行初始化，并用随机值将<code>vector</code>进行填充。这里会使用到<code>std::generate_n</code>算法，其会将随机值，通过<code>back_inserter</code>迭代器插入<code>vector</code>中。生成函数对象包装成了<code>d(gen)</code>表达式，其能生成符合分布的随机值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>data_points<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	<span class="token function">generate_n</span><span class="token punctuation">(</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> data_points<span class="token punctuation">,</span>
    	<span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">d</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们再实例化另一个<code>vector</code>，其来放采样过后的数值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> samples<span class="token punctuation">;</span>
	v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>sample_points<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>std::sample</code>算法与<code>std::copy</code>的原理类似，不过其需要两个额外的参数：采样数量和随机值生成对象。前者确定输入范围，后者去确定采样点：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">sample</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>samples<span class="token punctuation">)</span><span class="token punctuation">,</span>
		sample_points<span class="token punctuation">,</span> mt19937<span class="token punctuation">{</span>random_device<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>这样就完成了采样。代码的最后展示一下我们的采样结果。输入数据符合正态分布，如果采样算法可行，那么其采样的结果也要符合正态分布。为了展示采样后的值是否符合正态分布，我们将数值的直方图进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	map<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> hist<span class="token punctuation">;</span>

	<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">:</span> samples<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>hist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre></li>
<li>
<p>最后，我们使用循环打印出直方图：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>value<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">:</span> hist<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span>
    		<span class="token operator">&lt;&lt;</span> <span class="token function">string</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们将看到采样后的结果，其也符合正态分布：<img src="./C++17 STL Cook book_files/5-8-2.png" alt=""></p>
</li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>std::sample</code>算法是C++17添加的。其函数签名如下：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-class">class</span> <span class="token class-name">InIterator</span><span class="token punctuation">,</span> <span class="token keyword keyword-class">class</span> <span class="token class-name">OutIterator</span><span class="token punctuation">,</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">Distance</span><span class="token punctuation">,</span> <span class="token keyword keyword-class">class</span> <span class="token class-name">UniformRandomBitGenerator</span><span class="token operator">&gt;</span>
OutIterator <span class="token function">sample</span><span class="token punctuation">(</span>InIterator first<span class="token punctuation">,</span> InIterator last<span class="token punctuation">,</span>
				 SampleIterator out<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span>
				 UniformRandomBitGenerator<span class="token operator">&amp;&amp;</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>其输入范围有first和last迭代器确定，<code>out</code>迭代器作为采样输出。这些迭代器对于该函数来说和<code>std::copy</code>类似，元素从一个容器拷贝到另一个。<code>std::sample</code>算法只会拷贝输入中的一部分，因为采样结果只有n个元素。其在内部使用均匀分布，所以能以相同的概率选择输入范围中的每个数据点。</p>
</div></div><div id="ebook-heading-x751fx6210x8f93x5165x5e8fx5217x7684x5e8fx5217" ebook-toc-level-2="" heading="生成输入序列的序列"><div><h1 class="mume-header" id="%E7%94%9F%E6%88%90%E8%BE%93%E5%85%A5%E5%BA%8F%E5%88%97%E7%9A%84%E5%BA%8F%E5%88%97">生成输入序列的序列</h1>

<p>当测试代码需要处理参数顺序不重要的输入序列时，有必要测试它是否对所有可能的输入产生相同的输出。当你自己实现了一个排序算法时，就要写这样的测试代码来确定自己的实现是否正确。</p>
<p><code>std::next_permutation</code>在任何时候都能帮我们将序列进行打乱。我们在可修改的范围中可以调用它，其会将以字典序进行置换。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将从标准输入中读取多个字符串，然后使用<code>std::next_permutation</code>生成已排序的序列，并且打印这个序列：</p>
<ol>
<li>
<p>首先，包含必要的头文件，并声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>使用标准数组对<code>vector</code>进行初始化，接下来对<code>vector</code>进行排序：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v <span class="token punctuation">{</span>istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>cin<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在来打印<code>vector</code>中的内容。随后，调用<code>std::next_permutation</code>，其会打乱已经排序的<code>vector</code>，再对其进行打印。直到<code>next_permutation</code>返回false时，代表<code>next_permutation</code>完成了其操作，循环结束：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-do">do</span> <span class="token punctuation">{</span>
        <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>
        	ostream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token function">next_permutation</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行这个程序，会有如下的打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ echo <span class="token string">"a b c"</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>input_permutations
a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span>
a<span class="token punctuation">,</span> c<span class="token punctuation">,</span> b<span class="token punctuation">,</span>
b<span class="token punctuation">,</span> a<span class="token punctuation">,</span> c<span class="token punctuation">,</span>
b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> a<span class="token punctuation">,</span>
c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span>
c<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a<span class="token punctuation">,</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>std::next_permutation</code>算法使用起来有点奇怪。因为这个函数接受一组开始/结束迭代器，当其找到下一个置换时返回true；否则，返回false。不过“下一个置换”又是什么意思呢？</p>
<p>当<code>std::next_permutation</code>算法找到元素中的下一个字典序时，其会以如下方式工作：</p>
<ol>
<li>通过<code>v[i - 1] &lt; v[i]</code>的方式找到最大索引i。如果这个最大索引不存在，那么返回false。</li>
<li>再找到最大所以j，这里j需要大于等于i，并且<code>v[j] &gt; v[i - 1]</code>。</li>
<li>将位于索引位置j和i - 1上的值进行交换。</li>
<li>将从i到范围末尾的元素进行反向。</li>
<li>返回true。</li>
</ol>
<p>每次单独的置换顺序，都会在同一个序列中呈现。为了看到所有置换的可能，我们先对数组进行了排序。如果我们输入“c b a”到算法中，算法会立即终止，因为每个元素都以反字典序排列。</p>
</div></div><div id="ebook-heading-x5b9ex73b0x5b57x5178x5408x5e76x5de5x5177" ebook-toc-level-2="" heading="实现字典合并工具"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E5%AD%97%E5%85%B8%E5%90%88%E5%B9%B6%E5%B7%A5%E5%85%B7">实现字典合并工具</h1>

<p>假设我们有一个已经排序的列表，有人有另一个已排序的列表，我们想要将这两个列表进行共享。那么最好的方式就是将这两个列表合并起来。我们需要合并后的列表也是有序的，这样我们查找元素就会十分方便。</p>
<p>为了将两个已排序列表中的元素进行合并，我们本能的会想需要创建一个新的列表来放置这两个列表中的元素。对于要加入的元素，我们需要将队列中的元素进行对比，然后找到最小的那个元素将其放到列表的最前面。不过，这样输出队列的顺序会被打乱。下面的图就能很好的说明这个问题：</p>
<p><img src="./C++17 STL Cook book_files/5-10-1.png" alt=""></p>
<p><code>std::merge</code>算法就可以直接来帮助我们做这个事情，这样我们就无需过多的参与。本节我们将展示如何使用这个算法。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将创建一个简单的字典，其为英语单词和德语单词一对一的翻译，之后将其存储在<code>std::deque</code>数据结构中。程序将标注输入中获取这个字典，并且打印合并之后的字典。</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;deque&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tuple&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>字典是一对字符串，两两对应：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> dict_entry <span class="token operator">=</span> pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将在屏幕上打印这个组对，并且要从用户输入中读取这个组对，所以我们必须要重载<code>&gt;&gt;</code>和<code>&lt;&lt;</code>操作符：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-namespace">namespace</span> std <span class="token punctuation">{</span>
ostream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> dict_entry p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> os <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
istream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> dict_entry <span class="token operator">&amp;</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> is <span class="token operator">&gt;&gt;</span> p<span class="token punctuation">.</span>first <span class="token operator">&gt;&gt;</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>这里需要创建一个辅助函数，其能接受任何流对象作为输入，帮助我们构建字典。其会构建一个<code>std::deque</code>来存放一对一的字符串对，并且其会读取标准输入中的所有字符。并在返回字典前，对字典进行排序：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">IS</span><span class="token operator">&gt;</span>
deque<span class="token operator">&lt;</span>dict_entry<span class="token operator">&gt;</span> <span class="token function">from_instream</span><span class="token punctuation">(</span>IS <span class="token operator">&amp;&amp;</span>is<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    deque<span class="token operator">&lt;</span>dict_entry<span class="token operator">&gt;</span> d <span class="token punctuation">{</span>istream_iterator<span class="token operator">&lt;</span>dict_entry<span class="token operator">&gt;</span><span class="token punctuation">{</span>is<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>这里使用不同的输入流，创建两个不同的字典。其中一个是从<code>dict.txt</code>文件中读取出的字符，我们先假设这个文件存在。其每一行为一个组对，另一个流就是标准输入：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">dict1</span> <span class="token punctuation">(</span><span class="token function">from_instream</span><span class="token punctuation">(</span>ifstream<span class="token punctuation">{</span><span class="token string">"dict.txt"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">dict2</span> <span class="token punctuation">(</span><span class="token function">from_instream</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>作为辅助函数<code>from_instream</code>将返回给我们一个已经排过序的字典，这样我们就可以将两个字典直接放入<code>std::merge</code>算法中。其能通过给定两个的<code>begin</code>和<code>end</code>迭代器组确定输入的范围，并在最后给定输出。这里的输出将会打印在用户的屏幕上：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>dict1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>dict1<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">begin</span><span class="token punctuation">(</span>dict2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>dict2<span class="token punctuation">)</span><span class="token punctuation">,</span>
        ostream_iterator<span class="token operator">&lt;</span>dict_entry<span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>可以编译这个程序，不过在运行之前，我们需要创建<code>dict.txt</code>文件，并且写入如下内容：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">car <span class="token keyword keyword-auto">auto</span>
cellphone handy
house haus
</pre></li>
<li>
<p>现在我们运行程序了，输入一些英文单词，将其翻译为德文。这时的输出仍旧是一个排序后的字典，其可以将输入的所有单词进行翻译。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ echo <span class="token string">"table tisch fish fisch dog hund"</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>dictionary_merge
car <span class="token keyword keyword-auto">auto</span>
cellphone handy
dog hund
fish fisch
house haus
table tisch
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>std::meger</code>算法接受两对<code>begin/end</code>迭代器，这两对迭代器确定了输入范围。这两对迭代器所提供的输入范围也必须是已排序的。第五个参数就是输出容器的迭代器，其接受两段范围合并的元素。</p>
<p>其有一个变体<code>std::inplace_merge</code>。两个算法几乎一样，不过这个变体只需要一对迭代器，并且没有输出，和其名字一样，其会直接在输入范围上进行操作。比如对<code>{A, C, B, D}</code>这个序列来说，可以将第一个子序列定义为<code>{A, C}</code>，第二个子序列定义为<code>{B, D}</code>。使用<code>std::inplace_merge</code>算法将两个序列进行合并，其结果为<code>{A, B, C, D}</code>。</p>
</div></div><div id="ebook-heading-x7b2c6x7ae0-stlx7b97x6cd5x7684x9ad8x7ea7x4f7fx7528x65b9x5f0f" ebook-toc-level-1="" heading="第6章 STL算法的高级使用方式"><div><h1 class="mume-header" id="%E7%AC%AC6%E7%AB%A0-stl%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">第6章 STL算法的高级使用方式</h1>

<p>上一章，我们了解了基础STL算法，并且使用简单的例子实践操作了一下这些STL接口：大多数STL算法都将一个或多个迭代器对，作为其输入或输出参数。STL算法也能接受谓词函数，自定义比较函数和转换函数。最后，有些接口会返回迭代器，因为其他算法还会用到这个迭代器。</p>
<p>STL算法旨在保持简单和通用。这样大多数代码就可以使用STL算法，从而让代码看起来简单明了。一个经验丰富的C++开发者对于STL算法非常了解，其会在代码中尽可能使用STL算法，这会让其他人更容易明白这段代码存在的原因，这样能帮助开发者和阅读者产生最大程度的共鸣。一个开发者的大脑会很容易的解析这些普及度很高的算法，这要比解析一段复杂的循环简单的多。虽然实现的主要方式一样，但是细节方面还有不同。</p>
<p>我们使用STL数据结构结构能够很好的避免指针、裸数组和粗犷的结构体。那么接下来我们将升级对STL算法的理解，以便使用通用的STL算法来替代复杂的循环控制符合代码块。因为代码变得短小，在提高可读性的同时，又增加了通用性。这就能避免循环，仅调用<code>std</code>命名空间的算法即可，不过有时也会造成很糟糕的代码。我们不会去衡量代码是否糟糕，只会讨论可能性。</p>
<p>本章，我们将使用STL算法，以创造性的视野去了解现代C++能做些什么。我们将会实现属于我们自己的类STL算法，其能和已存在的数据结构完美结合，并且其他算法也会以同样的方式进行设计。我们也会将现有的STL算法与新算法相融合。这样的结合可以塑造出更加复杂的算法，不过其实现会更加短小，更具有可读性。过程中，我们可以看到STL是多么的简单和优雅。只有了解了所有方法，才能在使用时选择最合适的那一种。</p>
</div></div><div id="ebook-heading-x4f7fx7528stlx7b97x6cd5x5b9ex73b0x5355x8bcdx67e5x627ex6811x7c7b" ebook-toc-level-2="" heading="使用STL算法实现单词查找树类"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8stl%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91%E7%B1%BB">使用STL算法实现单词查找树类</h1>

<p>所谓的trie数据类型，能够对感兴趣的数据进行存储，并且易于查找。将文本语句分割成多个单词，放置在列表中，我们能发现其开头一些单词的共性。</p>
<p>让我们看下下图，这里有两个句子“hi how are you”和“hi how do you do”，存储在一个类似于树的结构体中。其都以“hi how”开头，句子后面不同的部分，划分为树结构：</p>
<p><img src="./C++17 STL Cook book_files/6-1-1.png" alt=""></p>
<p>因为trie数据结构结合了相同的前缀，其也称为前缀树，很容易使用STL的数据结构实现。本章我们将关注如何实现我们自己的trie类。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将使用STL数据结构和算法实现前缀树结构。</p>
<ol>
<li>
<p>包含必要的头文件和声明所使用的命名空间</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;optional&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们首先实现一个类。我们的实现中，trie为<code>map</code>的递归映射。每个trie节点够包含一个<code>map</code>，节点的有效值<code>T</code>映射了下一个节点：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">trie</span>
<span class="token punctuation">{</span>
	map<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> trie<span class="token operator">&gt;</span> tries<span class="token punctuation">;</span>
</pre></li>
<li>
<p>将新节点插入队列的代码很简单。使用者需要提供一个<code>begin/end</code>迭代器对，并且会通过循环进行递归。当用户输入的序列为{1, 2, 3}时，我们可以将1作为一个子trie，2为下一个子trie，以此类推。如果这些子trie在之前不存在，其将会通过<code>std::map</code>的<code>[]</code>操作符进行添加：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>It it<span class="token punctuation">,</span> It end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        tries<span class="token punctuation">[</span><span class="token operator">*</span>it<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">,</span> end_it<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们这里也会定义一个辅助函数，用户只需要提供一个容器，之后辅助函数就会通过迭代器自动进行查询：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">C</span><span class="token operator">&gt;</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> C <span class="token operator">&amp;</span>container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
</pre></li>
<li>
<p>调用我们的类时，可以写成这样<code>my_trie.insert({"a", "b","c"});</code>，必须帮助编译器正确的判断出这段代码中的所有类型，因此我们又添加了一个函数，这个函数用于重载的插入接口：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-void">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>il<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>il<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>il<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们也想了解，trie中有什么，所以我们需要一个打印函数。为了打印，我们可以对tire进行深度遍历。这样根节点下面的是第一个叶子节点，我们会记录我们所看到的元素的负载。当我们达到叶子节点，那么就可以进行打印了。我们会看到，当到达叶子的时候<code>tries.empty()</code>为true。递归调用print后，我们将再次弹出最后添加的负载元素：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>tries<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>
            	ostream_iterator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>p <span class="token operator">:</span> tries<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p<span class="token punctuation">.</span>second<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
            v<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>打印函数需要传入一个可打印负载元素的列表，不过用户不需要传入任何参数就能调用它。这样，我们就定义了一个无参数的打印函数，其构造了辅助列表对象：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
        vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
</pre></li>
<li>
<p>现在，我们就可以创建和打印trie了，我们将先搜索子trie。当trie包含的序列为<code>{a, b, c}</code>和<code>{a, b, d, e}</code>，并且我们给定的序列为<code>{a, b}</code>，对于查询来说，返回的子序列为包含<code>{c}</code>和<code>{d, e}</code>的部分。当我们找到子trie，将返回一个<code>const</code>的引用。在搜索中，也会出现没有要搜索序列的情况。即便如此，我们还是要返回些什么。<code>std::optional</code>是一个非常好的帮手，因为当没有找到匹配的序列，我们可以返回一个空的<code>optional</code>对象：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span>
    optional<span class="token operator">&lt;</span>reference_wrapper<span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> trie<span class="token operator">&gt;&gt;</span>
    <span class="token function">subtrie</span><span class="token punctuation">(</span>It it<span class="token punctuation">,</span> It end_it<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">found</span> <span class="token punctuation">(</span>tries<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>found <span class="token operator">==</span> <span class="token function">end</span><span class="token punctuation">(</span>tries<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        
        <span class="token keyword keyword-return">return</span> found<span class="token operator">-&gt;</span>second<span class="token punctuation">.</span><span class="token function">subtrie</span><span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">,</span> end_it<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>与<code>insert</code>方法类似，我们将提供一个只需要一个参数的<code>subtrie</code>方法，其能自动的从输入容器中获取迭代器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">C</span><span class="token operator">&gt;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">subtrie</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> C <span class="token operator">&amp;</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">subtrie</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>这样就实现完了。我们在主函数中使用我们trie类，使用<code>std::string</code>类型对类进行特化，并实例化对象：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    trie<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> t<span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"hi"</span><span class="token punctuation">,</span> <span class="token string">"how"</span><span class="token punctuation">,</span> <span class="token string">"are"</span><span class="token punctuation">,</span> <span class="token string">"you"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"hi"</span><span class="token punctuation">,</span> <span class="token string">"i"</span><span class="token punctuation">,</span> <span class="token string">"am"</span><span class="token punctuation">,</span> <span class="token string">"great"</span><span class="token punctuation">,</span> <span class="token string">"thanks"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"what"</span><span class="token punctuation">,</span> <span class="token string">"are"</span><span class="token punctuation">,</span> <span class="token string">"you"</span><span class="token punctuation">,</span> <span class="token string">"doing"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"i"</span><span class="token punctuation">,</span> <span class="token string">"am"</span><span class="token punctuation">,</span> <span class="token string">"watching"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"movie"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>打印整个trie：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"recorded sentences:\n"</span><span class="token punctuation">;</span>
	t<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>而后，我们将获取输入语句的子trie，其以“hi”开头：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\npossible suggestions after \"hi\":\n"</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token function">st</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">subtrie</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token string">"hi"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        st<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        st<span class="token operator">-&gt;</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，其会返回两个句子的以“hi”开头的子trie：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>trie
recorded sentences<span class="token operator">:</span>
hi how are you
hi i am great thanks
i am watching a movie
what are you doing

possible suggestions after <span class="token string">"hi"</span><span class="token operator">:</span>
how are you
i am great thanks
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>有趣的是，单词序列的插入代码要比在子trie查找给定字母序列的代码简单许多。所以，我们首先来看一下插入代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> trie<span class="token double-colon punctuation">::</span><span class="token function">insert</span><span class="token punctuation">(</span>It it<span class="token punctuation">,</span> It end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    tries<span class="token punctuation">[</span><span class="token operator">*</span>it<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">,</span> end_it<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>迭代器对<code>it</code>和<code>end_it</code>，表示要插入的字符序列。<code>tries[*it]</code>代表在子trie中要搜索的第一个字母，然后调用<code>.insert(next(it), end_it);</code>对更低级的子trie序列使用插入函数，使用迭代器一个词一个词的推进。<code>if (it == end_it) { return; }</code>行会终止递归。返回语句不会做任何事情，这到有点奇怪了。所有插入操作都在<code>tries[*it]</code>语句上进行，<code>std::map</code>的中括号操作将返回键所对应的值或是创建该键，相关的值(本节中映射类型是一个trie)由默认构造函数构造。这样，当我们查找不理解的单词时，就能隐式的创建一个新的trie分支。</p>
<p>查找子trie看起来十分复杂，因为我们没有必要隐藏那么多的代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span>
optional<span class="token operator">&lt;</span>reference_wrapper<span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> trie<span class="token operator">&gt;&gt;</span>
<span class="token function">subtrie</span><span class="token punctuation">(</span>It it<span class="token punctuation">,</span> It end_it<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">found</span> <span class="token punctuation">(</span>tries<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>found <span class="token operator">==</span> <span class="token function">end</span><span class="token punctuation">(</span>tries<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword keyword-return">return</span> found<span class="token operator">-&gt;</span>second<span class="token punctuation">.</span><span class="token function">subtrie</span><span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">,</span> end_it<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>这段代码的主要部分在于<code>auto found (tries.find(*it));</code>。我们使用find来替代中括号操作符。当我们使用中括号操作符进行查找时，trie将会为我们创建丢失的元素(顺带一提，当我们尝试这样做，类的函数为<code>const</code>，所以这样做事不可能的。这样的修饰能帮助我们减少bug的发生)。</p>
<p>另一个细节是返回值<code>optional&lt;reference_wrapper&lt;const trie&gt;&gt;</code>。我们选择<code>std::optional</code>作为包装器，因为其可能没有我们所要找打tire。当我们仅插入“hello my friend”，那么就不会找到“goodbye my friend”。这样，我们仅返回<code>{}</code>就可以了，其代表返回一个空<code>optional</code>对象给调用者。不过这还是没有解释，我们为什么使用<code>reference_wrapper</code>代替<code>optional&lt;const trie &amp;&gt;</code>。<code>optional</code>的实例，其为<code>trie&amp;</code>类型，是不可赋值的，因此不会被编译。使用<code>reference_warpper</code>实现一个引用，就是用来对对象进行赋值的。</p>
</div></div><div id="ebook-heading-x4f7fx7528x6811x5b9ex73b0x641cx7d22x8f93x5165x5efax8baex751fx6210x5668" ebook-toc-level-2="" heading="使用树实现搜索输入建议生成器"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E6%A0%91%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E8%BE%93%E5%85%A5%E5%BB%BA%E8%AE%AE%E7%94%9F%E6%88%90%E5%99%A8">使用树实现搜索输入建议生成器</h1>

<p>上网时，在搜索引擎中输入要查找的东西时，对应下拉选项中会尝试猜测你想要查找什么。这种猜测是基于之前相关主题被查找的数量。有时搜索引擎十分有趣，其会显示一些奇怪的主题。</p>
<p><img src="./C++17 STL Cook book_files/6-2-1.png" alt=""></p>
<p>本章，我们将使用树类实现一个简单的搜索建议引擎。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将实现一个终端应用，其能接受输入，并且能对所要查找的内容进行猜测，当然猜测的依据是我们用文本完成的“数据库”。</p>
<ol>
<li>
<p>包含必要的头文件和声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;optional&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将使用上一节实现的trie类：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">trie</span>
<span class="token punctuation">{</span>
	map<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> trie<span class="token operator">&gt;</span> tries<span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
	<span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span>
	<span class="token keyword keyword-void">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>It it<span class="token punctuation">,</span> It end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
		tries<span class="token punctuation">[</span><span class="token operator">*</span>it<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">,</span> end_it<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

    <span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">C</span><span class="token operator">&gt;</span>
	<span class="token keyword keyword-void">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> C <span class="token operator">&amp;</span>container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    
	<span class="token keyword keyword-void">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>il<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>il<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>il<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    
	<span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>l<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
		<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>tries<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span>
				ostream_iterator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>p <span class="token operator">:</span> tries<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			l<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
			p<span class="token punctuation">.</span>second<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>
			l<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
   	 
	<span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
		list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> l<span class="token punctuation">;</span>
		<span class="token function">print</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    
	<span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span>
	optional<span class="token operator">&lt;</span>reference_wrapper<span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> trie<span class="token operator">&gt;&gt;</span>
	<span class="token function">subtrie</span><span class="token punctuation">(</span>It it<span class="token punctuation">,</span> It end_it<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
		<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
		<span class="token keyword keyword-auto">auto</span> <span class="token function">found</span> <span class="token punctuation">(</span>tries<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>found <span class="token operator">==</span> <span class="token function">end</span><span class="token punctuation">(</span>tries<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token keyword keyword-return">return</span> found<span class="token operator">-&gt;</span>second<span class="token punctuation">.</span><span class="token function">subtrie</span><span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">,</span> end_it<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    
	<span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">C</span><span class="token operator">&gt;</span>
	<span class="token keyword keyword-auto">auto</span> <span class="token function">subtrie</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> C <span class="token operator">&amp;</span>c<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
		<span class="token keyword keyword-return">return</span> <span class="token function">subtrie</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>实现一个简单的辅助函数，这个函数将用于提示用户输入他们想要查找的东西：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Next input please:\n &gt; "</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</pre></li>
<li>
<p>主函数中，我们打开一个文本文件，其作为我们的基础数据库。我们逐行读取文本文件的内容，并且将数据放入trie中解析：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    trie<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> t<span class="token punctuation">;</span>
    fstream infile <span class="token punctuation">{</span><span class="token string">"db.txt"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>string line<span class="token punctuation">;</span> <span class="token function">getline</span><span class="token punctuation">(</span>infile<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        istringstream iss <span class="token punctuation">{</span>line<span class="token punctuation">}</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>iss<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在可以使用构建好的trie类，并且需要实现接收用户查询输入的接口。会提示用户进行输入，并且将用户的输入整行读取：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>string line<span class="token punctuation">;</span> <span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	istringstream iss <span class="token punctuation">{</span>line<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>通过文本输入，可以使用trie对其子trie进行查询。如果在数据库中已经有相应的语句，那么会对输入进行建议，否则会告诉用户没有建议给他们：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token function">st</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">subtrie</span><span class="token punctuation">(</span>istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>iss<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	st<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Suggestions:\n"</span><span class="token punctuation">;</span>
    	st<span class="token operator">-&gt;</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"No suggestions found.\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>之后，将打印一段分割符，并且再次等待用户的输入：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"----------------\n"</span><span class="token punctuation">;</span>
        <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>运行程序之前，我们需要将db.txt文件进行设置。查找的输入可以是任何字符，并且其不确保是已经排过序的。进入trie类的所有语句：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-do">do</span> ghosts exist
<span class="token keyword keyword-do">do</span> goldfish sleep
<span class="token keyword keyword-do">do</span> guinea pigs bite
how wrong can you be
how could trump become president
how could <span class="token keyword keyword-this">this</span> happen to me
how did bruce lee die
how did you learn c<span class="token operator">++</span>
what would aliens look like
what would macgiver <span class="token keyword keyword-do">do</span>
what would bjarne stroustrup <span class="token keyword keyword-do">do</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</pre></li>
<li>
<p>创建完db.txt之后，我们就可以运行程序了。其内容如下所示：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">hi how are you
hi i am great thanks
<span class="token keyword keyword-do">do</span> ghosts exist
<span class="token keyword keyword-do">do</span> goldfish sleep
<span class="token keyword keyword-do">do</span> guinea pigs bite
how wrong can you be
how could trump become president
how could <span class="token keyword keyword-this">this</span> happen to me
how did bruce lee die
how did you learn c<span class="token operator">++</span>
what would aliens look like
what would macgiver <span class="token keyword keyword-do">do</span>
what would bjarne stroustrup <span class="token keyword keyword-do">do</span>
what would chuck norris <span class="token keyword keyword-do">do</span>
why <span class="token keyword keyword-do">do</span> cats like boxes
why does it rain
why is the sky blue
why <span class="token keyword keyword-do">do</span> cats hate water
why <span class="token keyword keyword-do">do</span> cats hate dogs
why is c<span class="token operator">++</span> so hard
</pre></li>
<li>
<p>编译并运行程序，然后进行输入查找：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>word_suggestion
Next input please<span class="token operator">:</span>
<span class="token operator">&gt;</span> what would
Suggestions<span class="token operator">:</span>
aliens look like
bjarne stroustrup <span class="token keyword keyword-do">do</span>
chuck norris <span class="token keyword keyword-do">do</span>
macgiver <span class="token keyword keyword-do">do</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
Next input please<span class="token operator">:</span>
<span class="token operator">&gt;</span> why <span class="token keyword keyword-do">do</span>
Suggestions<span class="token operator">:</span>
cats hate dogs
cats hate water
cats like boxes
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
Next input please<span class="token operator">:</span>
<span class="token operator">&gt;</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>trie是如何工作的，已经在上一节中介绍过了，不过本节我们对其进行填充和查找的过程看起来有些奇怪。让我们来仔细观察一下代码片段，其使用文本数据库文件对空trie类进行填充：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">fstream infile <span class="token punctuation">{</span><span class="token string">"db.txt"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>string line<span class="token punctuation">;</span> <span class="token function">getline</span><span class="token punctuation">(</span>infile<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    istringstream iss <span class="token punctuation">{</span>line<span class="token punctuation">}</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>iss<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>这段代码会逐行的将文本文件中的内容读取出来。然后，我们将字符串拷贝到一个<code>istringstream</code>对象中。我们可以根据输入流对象，创建一个<code>istring_iterator</code>迭代器，其能帮助我们查找子trie。这样，我们就不需要将字符串放入<code>vector</code>或<code>list</code>中了。上述代码中，有一段不必要的内存分配，可以使用移动方式，将<code>line</code>中的内容移动到iss中，避免不必要的内存分配。不过，<code>std::istringstream</code>没有提供构造函数，所以只能将<code>std::string</code>中的内容移动到流中。不过，这里会对输入字符串进行复制。</p>
<p>当在trie中查询用户的输入时，使用了相同的策略，但不使用输入文件流。我们使用<code>std::cin</code>作为替代，因为<code>trie::subtrie</code>对迭代器的操作，和<code>trie::insert</code>如出一辙。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>这里有必要对每个trie节点添加统计变量，这样我们就能知道各种前缀被查询的频率。因此，我们就可以将程序的建议进行排序，当前的搜索引擎就是这样做的。智能手机触摸屏文本输入的建议，也可以通过这种方式实现。</p>
<p>这个修改就留给读者当作业了。 ：）</p>
</div></div><div id="ebook-heading-x4f7fx7528stlx6570x503cx7b97x6cd5x5b9ex73b0x5085x91ccx53f6x53d8x6362" ebook-toc-level-2="" heading="使用STL数值算法实现傅里叶变换"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8stl%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2">使用STL数值算法实现傅里叶变换</h1>

<p>信号处理领域傅里叶变换是非常重要和著名的公式。这个公式发现于200年前，其计算机用例实很多了。傅里叶变换可以用于音频/图像/视频压缩、音频滤波、医疗图像设备和用于辨识声音的手机引用。</p>
<p>因为其应用领域广泛，STL也试图将其用在数值计算领域。傅里叶变换只是其中一个例子，同样也是非常棘手的一个。其公式如下所示：</p>
<p><img src="./C++17 STL Cook book_files/6-3-1.png" alt=""></p>
<p>公式基于累加和的变换。累加中的每个元素是输入信号向量中的一个数据点和表达式<code>exp(-2 * i * ...)</code>的乘积。这里需要一些工程数学的知识，你需要简单的了解复数的概念，如果你没有相关的知识，了解概念就可以了。仔细观察这个公式，其就是将信号中的所有数据点进行加和(信号数据的长度为N)，其循环索引值为j。其中k是另一个循环变量，因为傅里叶变换计算出的是一组值。在这组值中，每一个数据点都表示着一段重复波形的幅值和相位，这些信息不包含在原始数据中。当使用循环对其进行实现时，代码可能就会写成下面这样：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">csignal <span class="token function">fourier_transform</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> csignal <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    csignal <span class="token function">t</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-double">double</span> pol <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">2.0</span> <span class="token operator">*</span> M_PI <span class="token operator">/</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t k <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t j <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            t<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token function">polar</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> pol <span class="token operator">*</span> k <span class="token operator">*</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>这里<code>csignal</code>的类型可能是<code>std::vector</code>，其每个元素都是一个复数。对于复数而言，STL中已经有了对应的数据结构可以对其进行表示——<code>std::complex</code>。<code>std::polar</code>函数计算得是<code>exp(-2 * i * ...)</code>部分。</p>
<p>这样实现看起来也挺好，不过本节中我们将使用STL工具对其进行实现。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将实现傅里叶变换和逆变换，然后会对一些信号进行转换：</p>
<ol>
<li>
<p>首先，包含必要的头文件和声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;complex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;valarray&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>信号点的值一个复数，我们使用<code>std::complex</code>来表示，并使用<code>double</code>进行特化。我们可以对类型进行别名操作，使用<code>cmple</code>表示两个<code>double</code>值，这两个<code>double</code>值分别表示复数的实部和虚部。使用<code>csdignal</code>来别名相应的<code>vector</code>对象：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> cmplx <span class="token operator">=</span> complex<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> csignal <span class="token operator">=</span> vector<span class="token operator">&lt;</span>cmplx<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们需要使用数值指针遍历数值序列。公式中的变量k和j就会随着序列进行累加：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">num_iterator</span> <span class="token punctuation">{</span>
	size_t i<span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
	<span class="token keyword keyword-explicit">explicit</span> <span class="token function">num_iterator</span><span class="token punctuation">(</span>size_t position<span class="token punctuation">)</span> <span class="token operator">:</span> i<span class="token punctuation">{</span>position<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
	size_t <span class="token keyword keyword-operator">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
	num_iterator<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token operator">++</span>i<span class="token punctuation">;</span>
		<span class="token keyword keyword-return">return</span> <span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    
	<span class="token keyword keyword-bool">bool</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> num_iterator <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
		<span class="token keyword keyword-return">return</span> i <span class="token operator">!=</span> other<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>傅里叶变换需要接收一个信号，并返回一个新的信号。返回的信号表示已经经过傅里叶变换的信号。通过傅里叶逆变换，我们可以将一个经过傅里叶变换的信号，还原成原始信号，这里我们会提供一个可选的<code>bool</code>参数，其会决定变换的方向。<code>bool</code>参数作为参数是一种不好习惯，特别是在一个函数的签名中出现多次。我们这有个很简洁的例子。我们做的第一件事，是使用原始信号的尺寸来分配新的信号数组：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">csignal <span class="token function">fourier_transform</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> csignal <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword keyword-bool">bool</span> back <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	csignal <span class="token function">t</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>公式中有两个因子，其看起来是相同的。让我们将其打包成一个变量：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-double">double</span> pol <span class="token punctuation">{</span><span class="token number">2.0</span> <span class="token operator">*</span> M_PI <span class="token operator">*</span> <span class="token punctuation">(</span>back <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1.0</span> <span class="token operator">:</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-double">double</span> div <span class="token punctuation">{</span>back <span class="token operator">?</span> <span class="token number">1.0</span> <span class="token operator">:</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>std::accumulate</code>很适合用来执行公式中的累加部分，我们将对一个范围内的数值使用<code>accumulate</code>。对于每个值，我们将逐步的进行单个相加。<code>std::accumulate</code>算法会调用一个二元函数。该函数的第一个参数为目前为止我们所累加的变量<code>sum</code>，第二个参数为范围内下一个要累加的值。我们会在信号<code>s</code>中对当前为止的值进行查找，并且会将其和复数因子<code>pol</code>相乘。然后，我们返回新的<code>sum</code>。这里的二元函数，使用Lambda表达式进行包装，因为我们将在每次<code>accumulate</code>的调用时，<code>j</code>变量的值是不同的。因为其是二维循环算法，所以内层Lambda做内部的循环，外层Lambda做外层的循环：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">sum_up</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">]</span> <span class="token punctuation">(</span>size_t j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">]</span> <span class="token punctuation">(</span>cmplx c<span class="token punctuation">,</span> size_t k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> c <span class="token operator">+</span> s<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span>
        		<span class="token function">polar</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> pol <span class="token operator">*</span> k <span class="token operator">*</span> j <span class="token operator">/</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>傅里叶的内部循环，现在使用<code>std::accumulate</code>进行，算法中每个位置都会进行加和。我们使用Lambda表达式来实现，这样我们就能计算出傅里叶变换数组中的每个数据点的值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">to_ft</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">]</span><span class="token punctuation">(</span>size_t j<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>num_iterator<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                          num_iterator<span class="token punctuation">{</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                          cmplx<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                          <span class="token function">sum_up</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token operator">/</span> div<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>目前位置，还没有执行傅里叶变换的代码。我们会准备大量的功能性代码，他们会帮助我们完成很多事情。<code>std::transform</code>的调用将会使j的值在[0, N)间变换(这步是在外层循环完成)。变换之后的值将全部放入<code>t</code>中，<code>t</code>就是我们要返回给用户的值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">transform</span><span class="token punctuation">(</span>num_iterator<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> num_iterator<span class="token punctuation">{</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    		 <span class="token function">begin</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> to_ft<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们将会实现一些辅助函数帮助我们生成信号。首先实现的是一个余弦信号生成器，其会返回一个Lambda表达式，这个表达式通过传入的长度参数，产生对应长度的余弦信号数据。信号本身的长度是不固定的，但是其有固定的周期。周期为N，意味着该信号会在N步之后重复。返回的Lambda表达式不接受任何参数。我们可以重复的对其进行调用，并且每次调用表达式将会返回给我们下一个时间点的信号值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">gen_cosine</span> <span class="token punctuation">(</span>size_t period_len<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span>period_len<span class="token punctuation">,</span> n<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-mutable">mutable</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span><span class="token punctuation">(</span>n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2.0</span> <span class="token operator">*</span> M_PI <span class="token operator">/</span> period_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们所要生成另一个波形是方波。该波形会在<code>-1</code>和<code>+1</code>两值间震荡，其中不会有其他的值。公式看起来有点复杂，但是其变换非常简单，也就是将值n置为<code>+1</code>或<code>-1</code>，并且其震荡周期为<code>period_len</code>。这里要注意，我们没有使用0对n进行初始化。这样，我们的方波的其实位置就在<code>+1</code>上：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">gen_square_wave</span> <span class="token punctuation">(</span>size_t period_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span>period_len<span class="token punctuation">,</span> n<span class="token punctuation">{</span>period_len<span class="token operator">*</span><span class="token number">7</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-mutable">mutable</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">++</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">/</span> period_len<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>产生实际信号可以通过<code>vector</code>和信号生成器联合进行，使用重复调用信号生成器对<code>vector</code>数组进行填充。<code>std::generate</code>就用来完成这个任务的。其接受一组<code>begin/end</code>迭代器组和一个生成函数。对于每个合法的迭代器，都会进行<code>*it = gen()</code>。通过将这些代码包装成一个函数，我们可以很容易的生成一个信号数组：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> csignal <span class="token function">signal_from_generator</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> F gen<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    csignal <span class="token function">r</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">generate</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> gen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>最后，我们需要将信号的结果进行打印。我们可以将数组中的值拷贝到输出流迭代器中进行输出，不过我们需要先将数据进行变换，因为我们的信号数据都是复数对。这样，我们只需要在意每个点的实部就好；所以，我们可以将数组扔到<code>std::transform</code>中进行变换，然后将实部提取出来：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">print_signal</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> csignal <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">real_val</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>cmplx c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> c<span class="token punctuation">.</span><span class="token function">real</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">transform</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span>
    		 ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">}</span><span class="token punctuation">,</span> real_val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>目前为止，傅里叶公式就已经实现了，不过现在还没有信号进行变换。这个工作我们将在主函数中完成。我们先来定义信号数据的长度：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-const">const</span> size_t sig_len <span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在来生成信号数据，转换他们，然后进行打印。首先，生成一个余弦信号和一个方波信号。这两组信号的长度和周期数相同：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">cosine</span> <span class="token punctuation">(</span><span class="token function">signal_from_generator</span><span class="token punctuation">(</span>sig_len<span class="token punctuation">,</span>
        <span class="token function">gen_cosine</span><span class="token punctuation">(</span> sig_len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-auto">auto</span> <span class="token function">square_wave</span> <span class="token punctuation">(</span><span class="token function">signal_from_generator</span><span class="token punctuation">(</span>sig_len<span class="token punctuation">,</span>
        <span class="token function">gen_square_wave</span><span class="token punctuation">(</span>sig_len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>那么现在有了两个波形信号。为了生成第三个信号，我们对方波信号进行傅里叶变换，并且保存在<code>trans_sqw</code>数组中。方波的傅里叶变换有些特殊，我们在后面会进行介绍。索引从10到<code>(signal_length - 10)</code>都设置为0.0。经过傅里叶变换之后，原始信号将发生很大的变化。我们将在最后看到结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">trans_sqw</span> <span class="token punctuation">(</span><span class="token function">fourier_transform</span><span class="token punctuation">(</span>square_wave<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">fill</span> <span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>trans_sqw<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">prev</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span>trans_sqw<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">mid</span> <span class="token punctuation">(</span><span class="token function">fourier_transform</span><span class="token punctuation">(</span>trans_sqw<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，我们有三个信号：余弦、mid和方波。对于每个信号，我们将会打印其原始波形，和傅里叶变换过后的波形。输出将有六条曲线组成：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">print_signal</span><span class="token punctuation">(</span>cosine<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_signal</span><span class="token punctuation">(</span><span class="token function">fourier_transform</span><span class="token punctuation">(</span>cosine<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">print_signal</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_signal</span><span class="token punctuation">(</span>trans_sqw<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">print_signal</span><span class="token punctuation">(</span>square_wave<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_signal</span><span class="token punctuation">(</span><span class="token function">fourier_transform</span><span class="token punctuation">(</span>square_wave<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，终端上会打印出大量的数据。如果这里使用绘图输出，就可以看到如下的结果：</p>
<p><img src="./C++17 STL Cook book_files/6-3-2.png" alt=""></p>
</li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>这段代码又两个比较难理解的部分。第一个是傅里叶变换本身，另一个是使用可变Lambda表达式生成信号数据。</p>
<p>首先，我们来看一下傅里叶变换。其核心部分在循环中实现(虽然没有在我们实现中这样做，但可以结合代码看下介绍中的公式)，可能会以如下方式实现：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t k <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t j <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	t<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token function">polar</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> pol <span class="token operator">*</span> k <span class="token operator">*</span> j <span class="token operator">/</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre><p>基于STL算法<code>std::transform</code>和<code>std::accumulate</code>，我们完成了自己的例子，总结一下就类似如下的伪代码：</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>transform(num_iterator{0}, num_iterator{s.size()}, ...
	accumulate((num_iterator0}, num_iterator{s.size()}, ...
		c + s[k] * polar(1.0, pol * k * j / double(s.size()));
</code></pre><p>和循环相比，结果完全一样。当然，使用STL算法也可以产生不太好的代码。不管怎么样吧，这个实现是不依赖所选用的数据结构。其对于列表也起作用(虽然这没有太大的意义)。另一个好处是，在C++17中STL很容易并行(将在本书的另一个章节进行介绍)，当需要并行的时候，我们就需要对纯循环进行重构和拆分，将其放入指定的线程中(除非使用类似OpenMP这样的并发库，其会自动的将循环进行重构)。</p>
<p>下一个难点是信号生成。让我来看一下另一个<code>gen_cosine</code>:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">gen_cosine</span> <span class="token punctuation">(</span>size_t period_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span>period_len<span class="token punctuation">,</span> n<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-mutable">mutable</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span><span class="token punctuation">(</span>n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2.0</span> <span class="token operator">*</span> M_PI <span class="token operator">/</span> period_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>每一个Lambda表达式代表一个函数对象，其会在每次调用时改变自身的状态。其状态包含两个变量<code>period_len</code>和<code>n</code>。变量n会在每次调用时，进行变更。在不同的时间点上，得到的是不同的信号值，并且在时间增加时会使用<code>n++</code>对<code>n</code>的值进行更新。为了获得信号值的数组，我们创建了辅助函数<code>signal_from_generator</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">signal_from_generator</span><span class="token punctuation">(</span>size_t len<span class="token punctuation">,</span> F gen<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    csignal <span class="token function">r</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">generate</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> gen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>这个函数会通过所选长度创建一个信号<code>vector</code>，并且调用<code>std::generate</code>对数据点进行填充。数组r中的每一个元素，都会调用一个<code>gen</code>函数。<code>gen</code>函数是是一种自修改函数对象，我们使用相同的方式创建了<code>gen_cosine</code>对象。</p>
<blockquote>
<p>Note：</p>
<p>本节例子中，STL没有让代码更加的优雅。如果将范围库添加入STL(希望在C++20时加入)，那么可能就会有改观。</p>
</blockquote>
</div></div><div id="ebook-heading-x8ba1x7b97x4e24x4e2avectorx7684x8befx5deex548c" ebook-toc-level-2="" heading="计算两个vector的误差和"><div><h1 class="mume-header" id="%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AAvector%E7%9A%84%E8%AF%AF%E5%B7%AE%E5%92%8C">计算两个vector的误差和</h1>

<p>对两个值进行计算的时候，计算机的计算结果与我们期望的结果有一定的差别。比如，测量由多个数据点组成的信号之间的差异，通常会涉及相应数据点的循环和减法等计算。</p>
<p>我们给出一个简单的计算信号a与信号b之间的误差公式：</p>
<p><img src="./C++17 STL Cook book_files/6-4-1.png" alt=""></p>
<p>对于每一个<code>i</code>，都会计算一次<code>a[i] - b[i]</code>，对差值求平方(负值和正值就能进行比较)，最后计算平方差的和。通常我们会使用循环来做这件事，但是为了让事情更加好玩，我们决定使用STL算法来完成。使用STL的好处是，无需耦合特定的数据结果。我们的算法能够适应<code>vector</code>和类似链表的数据结构，不用直接进行索引。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将创建两个信号，并计算这两个信号之间的误差：</p>
<ol>
<li>
<p>依旧是包含必要的头文件和声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>我们将对两个信号的误差和进行计算。这两个信号一个是<code>sine</code>，另一个信号也是<code>sine</code>，不过其中之一的使用<code>double</code>类型进行保存，另一个使用<code>int</code>类型进行保存。因为<code>double</code>和<code>int</code>类型表示数值的范围有差异，就像是模拟信号<code>as</code>转换成数字信号<code>ds</code>。</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> size_t sig_len <span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> <span class="token function">as</span> <span class="token punctuation">(</span>sig_len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a for analog</span>
    vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token function">ds</span> <span class="token punctuation">(</span>sig_len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// d for digital</span>
</pre><ol start="3">
<li>
<p>为了生成一个<code>sin</code>波形，我们事先了一个简单的Lambda表达式，并可以传入一个可变的计数变量<code>n</code>。我们可以经常在需要的时候调用表达式，其将返回下一个时间点的<code>sine</code>波形。<code>std::generate</code>可以使用信号值来填充数组，并且使用<code>std::copy</code>将数组中的<code>double</code>类型的变量，转换成<code>int</code>类型变量：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">sin_gen</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>n<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-mutable">mutable</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token number">5.0</span> <span class="token operator">*</span> <span class="token function">sin</span><span class="token punctuation">(</span>n<span class="token operator">++</span> <span class="token operator">*</span> <span class="token number">2.0</span> <span class="token operator">*</span> M_PI <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">generate</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">,</span> sin_gen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>ds<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们可以对信号进行打印，也可以使用绘图进行显示：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">,</span>
    	ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>ds<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>ds<span class="token punctuation">)</span><span class="token punctuation">,</span>
    	ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>现在来计算误差和，我们使用<code>std::inner_product</code>，因为这个函数能帮助我们计算两个信号矢量的差异。该函数能在指定范围内进行迭代，然后选择相应位置上进行差值计算，然后在进行平方，再进行相加：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token function">inner_product</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>as<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>ds<span class="token punctuation">)</span><span class="token punctuation">,</span>
    					<span class="token number">0.0</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>plus<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    					<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span> a<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   							<span class="token keyword keyword-return">return</span> <span class="token function">pow</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    					<span class="token punctuation">}</span><span class="token punctuation">)</span>
    	<span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就能得到两条曲线，还有一条曲线代表的是两个信号的误差和。最终这两个信号的误差为40.889。当我们使用连续的方式对误差进行统计，要对值进行逐对匹配，然后得到无法曲线，其就像我们在下图中看到的一样：</p>
<p><img src="./C++17 STL Cook book_files/6-4-2.png" alt=""></p>
</li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节，我们需要将两个向量放入循环中，然后对不同位置的值计算差值，然后差值进行平方，最后使用<code>std::inner_product</code>将差的平方进行加和。这样，我们可以使用Lambda表达式来完成求差值平方的操作——<code>[](double a, double b){return pow(a - b), 2}</code>，这样就可以通过传入不同的参数来计算差值平方。</p>
<p>这里我们可以看下<code>std::inner_product</code>是如何工作的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-class">class</span> <span class="token class-name">InIt1</span><span class="token punctuation">,</span> <span class="token keyword keyword-class">class</span> <span class="token class-name">InIt2</span><span class="token punctuation">,</span> <span class="token keyword keyword-class">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword keyword-class">class</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword keyword-class">class</span> <span class="token class-name">G</span><span class="token operator">&gt;</span>
T <span class="token function">inner_product</span><span class="token punctuation">(</span>InIt1 it1<span class="token punctuation">,</span> InIt1 end1<span class="token punctuation">,</span> InIt2 it2<span class="token punctuation">,</span> T val<span class="token punctuation">,</span>
			   F bin_op1<span class="token punctuation">,</span> G bin_op2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>it1<span class="token operator">!=</span> end1<span class="token punctuation">)</span><span class="token punctuation">{</span>
        val <span class="token operator">=</span> <span class="token function">bin_op1</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> <span class="token function">bin_op2</span><span class="token punctuation">(</span><span class="token operator">*</span>it1<span class="token punctuation">,</span> <span class="token operator">*</span>it2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>it1<span class="token punctuation">;</span>
        <span class="token operator">++</span>it2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>算法会接受一对<code>begin/end</code>迭代器作为第一个输入范围，另一个<code>begin</code>迭代器代表第二个输入范围。我们的例子中，这些迭代器所指向的是<code>vector</code>，并对这两个<code>vector</code>进行误差和的计算。<code>val</code>是一个初始化值。我们这里将其设置为<code>0.0</code>。然后，算法可以接受两个二元函数，分别为<code>bin_op1</code>和<code>bin_op2</code>。</p>
<p>我们会发现，这个算法与<code>std::accumulate</code>很相似。不过<code>std::accumulate</code>只对一个范围进行操作。当将<code>bin_op2(*it1, *it2)</code>看做一个迭代器，那么我们可以简单的是用<code>accumulate</code>算法进行计算了。所以，我们可以将<code>std::inner_product</code>看成是带有打包输入范围的<code>std::accumulate</code>。</p>
<p>例子中，打包函数就是<code>pow(a - b, 2)</code>。因为我们需要将所有元素的差平方进行加和，所以我们选择<code>std::plus&lt;double&gt;</code>作为<code>bin_op1</code>。</p>
</div></div><div id="ebook-heading-x4f7fx7528asciix5b57x7b26x66fcx5fb7x5c14x5e03x7f57x7279x96c6x5408" ebook-toc-level-2="" heading="使用ASCII字符曼德尔布罗特集合"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8ascii%E5%AD%97%E7%AC%A6%E6%9B%BC%E5%BE%B7%E5%B0%94%E5%B8%83%E7%BD%97%E7%89%B9%E9%9B%86%E5%90%88">使用ASCII字符曼德尔布罗特集合</h1>

<p>1975年，数学家贝诺曼德尔布罗特(Benoit Mandelbrot)创造了一个术语——<strong>分形</strong>。分形是一个数学图像或者集合，这个术语中包含了很多有趣的数学特性，不过最后看起来分形更像是艺术品。分形图像看起来是无限重复的缩小。其中最为众人所知的分形是曼德尔布罗特(Mandelbrot)集合，其集合看起来就像下图一样：</p>
<p><img src="./C++17 STL Cook book_files/6-5-1.png" alt=""></p>
<p>曼德尔布罗特集合可以通过迭代下面的等式得到：</p>
<p><img src="./C++17 STL Cook book_files/6-5-2.png" alt=""></p>
<p><code>z</code>和<code>c</code>变量都是复数。曼德尔布罗特集合包含等式所覆盖所有让方程收敛的<code>c</code>值，也就是海报彩色的部分。有些值收敛的早，有些值收敛的晚，这里用不同的颜色对这些值进行描述，所以我们能在海报中看到各种不同的颜色。对于那些不收敛的值，我们则直接将其所在区域直接涂黑。</p>
<p>使用STL的<code>std::complex</code>类，且不使用循环来实现上面的等式。这并不是炫技，只是为了让大家更容易理解STL相关特性的使用方式。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将打印类似墙上海报的图，不过是使用ASCII字符将图像打印在终端上：</p>
<ol>
<li>
<p>包含必要的头文件并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;complex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>曼德尔布罗特集合和之前的等式，都是对复数进行操作。所以，我们需要使用类型别名，使用<code>cmplx</code>来代表<code>std::complex</code>，并特化为<code>double</code>类型：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">  <span class="token keyword keyword-using">using</span> cmplx <span class="token operator">=</span> complex<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将使用大约20行的代码来完成一个ASCII组成的曼德尔布罗特集合图像，不过我们会将逻辑逐步实现，最后将所有结果进行组合。第一步就是实现一个函数，用于将整型坐标缩放为浮点坐标。这也就是我们如何在屏幕上特定的位置上打印相应的字符。我们想要的是曼德尔布罗特集合中复数的坐标，就需要实现一个函数，用于将对应的坐标转换成相应的几何图形。用一个Lambda表达式来构建这些变量，并将其返回。该函数能将<code>int</code>类型的函数转换成一个<code>double</code>类型的函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">scaler</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> min_from<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> max_from<span class="token punctuation">,</span>
<span class="token keyword keyword-double">double</span> min_to<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> max_to<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> w_from <span class="token punctuation">{</span>max_from <span class="token operator">-</span> min_from<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-double">double</span> w_to <span class="token punctuation">{</span>max_to <span class="token operator">-</span> min_to<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> mid_from <span class="token punctuation">{</span><span class="token punctuation">(</span>max_from <span class="token operator">-</span> min_from<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> min_from<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-double">double</span> mid_to <span class="token punctuation">{</span><span class="token punctuation">(</span>max_to <span class="token operator">-</span> min_to<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span> <span class="token operator">+</span> min_to<span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> from<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   		<span class="token keyword keyword-return">return</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">(</span>from <span class="token operator">-</span> mid_from<span class="token punctuation">)</span> <span class="token operator">/</span> w_from <span class="token operator">*</span> w_to <span class="token operator">+</span> mid_to<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在需要在一个维度上进行坐标变换，不过曼德尔布罗特集合使用的是二维坐标系。为了能将(x, y)坐标系统转换成另一个，我们需要将<code>x-scaler</code>和<code>y-scaler</code>相结合，并且构建一个<code>cmplx</code>实例作为输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">B</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">scaled_cmplx</span><span class="token punctuation">(</span>A scaler_x<span class="token punctuation">,</span> B scaler_y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> cmplx<span class="token punctuation">{</span><span class="token function">scaler_x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">scaler_y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>将坐标转换到正确的维度上后，就可以来实现曼德尔布罗特方程。现在不管怎么打印输出，一心只关注于实现方程即可。循环中，对<code>z</code>进行平方，然后加上<code>c</code>，知道<code>abs</code>的值小于2。对于一些坐标来说，其值永远不可能比2小，所以当循环次数达到<code>max_iterations</code>时，我们就决定放弃。最后，将会返回那些<code>abs</code>值收敛的迭代次数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">mandelbrot_iterations</span><span class="token punctuation">(</span>cmplx c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cmplx z <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    size_t iterations <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> size_t max_iterations <span class="token punctuation">{</span><span class="token number">1000</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> iterations <span class="token operator">&lt;</span> max_iterations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>iterations<span class="token punctuation">;</span>
        z <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> iterations<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>那么现在我们就来实现主函数。在主函数中我们会定义缩放函数对象<code>scale</code>，用于对坐标值进行多维变换：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> size_t w <span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> size_t h <span class="token punctuation">{</span><span class="token number">40</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-auto">auto</span> <span class="token function">scale</span> <span class="token punctuation">(</span><span class="token function">scaled_cmplx</span><span class="token punctuation">(</span>
        <span class="token function">scaler</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">scaler</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了可以在一维上迭代器整个图形，需要完成另一个转换函数，用于将二维图像进行降维操作。其会根据我们所设置的字符宽度进行计算。其会将一维上的长度进行折断，然后进行多行显示，通过使用<code>scale</code>函数对坐标进行变换，然后返回复数坐标：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">i_to_xy</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">scale</span><span class="token punctuation">(</span>i <span class="token operator">%</span> w<span class="token punctuation">,</span> i <span class="token operator">/</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将图像的二维坐标(int，int类型)转换为一维坐标(int类型)，再将坐标转换成曼德尔布罗特结合坐标(cmplx类型)。让我们将所有功能放入一个函数，我们将使用一组调用链：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">to_iteration_count</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword keyword-return">return</span> <span class="token function">mandelbrot_iterations</span><span class="token punctuation">(</span><span class="token function">i_to_xy</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们可以来设置所有数据。假设我们的结果ASCII图像的字符宽度为<code>w</code>，高度为<code>h</code>。这样就能将结果存储在一个长度为<code>w * h</code>数组中。我们使用<code>std::iota</code>将数值范围进行填充。这些数字可以用来作为转换的输入源 ，我们将变换过程包装在<code>to_iteration_count</code>中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token function">v</span> <span class="token punctuation">(</span>w <span class="token operator">*</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">iota</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">transform</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> to_iteration_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在有一个v数组，其使用一维坐标进行初始化，不过后来会被曼德尔布罗特迭代计数所覆盖。因此，我们就可以对图像进行打印。可以将终端窗口设置为<code>w</code>个字符宽度，这样我们就不需要打印换行符。不过，可能会有对<code>std::accumulate</code>有一种创造性的误用。<code>std::accumulate</code>使用二元函数对处理范围进行缩小。我们可以对其提供一个二元函数，其能接受一个输出迭代器(并且我们将在下一步进行终端打印)，并使用范围内的单个值进行计算。如果相应值的迭代次数大于50次时，我们会打印<code>*</code>字符到屏幕上。否则，会打印空字符在屏幕上。在每行结束时(因为计数器变量n可被W均匀地分割)，我们会打印一个换行符：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">binfunc</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>w<span class="token punctuation">,</span> n<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> output_it<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> x<span class="token punctuation">)</span> <span class="token keyword keyword-mutable">mutable</span> <span class="token punctuation">{</span>
    	<span class="token operator">*</span><span class="token operator">++</span>output_it <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> <span class="token number">50</span> <span class="token operator">?</span> <span class="token string">'*'</span> <span class="token operator">:</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>n <span class="token operator">%</span> w <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>output_it <span class="token operator">=</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    	<span class="token keyword keyword-return">return</span> output_it<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>通过对输入范围使用<code>std::accumulate</code>，我们将二元打印函数和<code>ostream_iterator</code>相结合，我们需要在屏幕上刷新计算出的曼德尔布罗特集合：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">}</span><span class="token punctuation">,</span>
			  binfunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就可以看到如下的输出，其看起来和墙上的海报很像吧！</p>
</li>
</ol>
<p><img src="./C++17 STL Cook book_files/6-5-3.png" alt=""></p>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>整个计算过程都使用<code>std::transform</code>对一维数组进行处理：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token function">v</span> <span class="token punctuation">(</span>w <span class="token operator">*</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">iota</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">transform</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> to_iteration_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>所以，会发生什么呢？我们为什么要这么做？<code>to_iteration_count</code>函数是基于从<code>i_to_xy</code>开始的调用链，从<code>scale</code>到<code>mandelbrot_iterations</code>。下面的图像就能展示我们的转换步骤：</p>
<p><img src="./C++17 STL Cook book_files/6-5-4.png" alt=""></p>
<p>这样，我们就可以使用一维数组作为输入，并且获得曼德尔布罗特方程的迭代次数(使用一维坐标表示的二维坐标上的值)。三个互不相关的转换是件好事。这样代码就可以独立的进行测试，这样就不用互相牵制了。同样，这样更容易进行正确性测试，并寻找并修复bug。</p>
</div></div><div id="ebook-heading-x5b9ex73b0x5206x5272x7b97x6cd5" ebook-toc-level-2="" heading="实现分割算法"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95">实现分割算法</h1>

<p>很多情况下，STL中的算法并不够我们使用，有些算法需要我们自己去实现。解决具体问题之前，我们需要确定，这个问题是否有通解。当我们自己遇到一些问题时，我们可以实现一些辅助函数帮助我们，这些辅助函数逐渐的就可以形成库。这里关键是要明白什么样的代码是足够通用的，否则我们就需要创造一套通用语言了。</p>
<p>本节我们将实现一个算法，叫做<strong>分割</strong>(split)。该算法可以通过给定的值，对任何范围的元素进行分割，将分割后的结果块拷贝到输出区域中。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，将实现类似于STL的算法叫做分割，并且用这个算法对字符串进行分割：</p>
<ol>
<li>
<p>首先，包含必要的头文件，并声明相应的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>本节的所有算法都围绕分割来进行。其接受一对<code>begin/end</code>迭代器和一个输出迭代器，其用法和<code>std::copy</code>或<code>std::transform</code>类似。其他参数为<code>split_val</code>和<code>bin_func</code>。<code>split_val</code>参数是要在输入范围内要查找的值，其表示要当碰到这个值时，要对范围进行分割。<code>bin_func</code>参数是一个函数，其为分割的子序列的开始和结尾。我们可以使用<code>std::find</code>对输入范围进行迭代查找，这样就能直接跳转到<code>split_val</code>所在的位置。当将一个长字符串分割成多个单词，可以通过分割空格字符达到目的。对于每一个分割值，都会做相应的分割，并将对应的分割块拷贝到输出范围内：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">InIt</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">OutIt</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
InIt <span class="token function">split</span><span class="token punctuation">(</span>InIt it<span class="token punctuation">,</span> InIt end_it<span class="token punctuation">,</span> OutIt out_it<span class="token punctuation">,</span> T split_val<span class="token punctuation">,</span>
		  F bin_func<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">slice_end</span> <span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> end_it<span class="token punctuation">,</span> split_val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>out_it<span class="token operator">++</span> <span class="token operator">=</span> <span class="token function">bin_func</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> slice_end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>slice_end <span class="token operator">==</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> end_it<span class="token punctuation">;</span> <span class="token punctuation">}</span>
        it <span class="token operator">=</span> <span class="token function">next</span><span class="token punctuation">(</span>slice_end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> it<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在尝试一下我们的新算法，构建一个需要进行分割的字符串。其中的字符使用<code>-</code>进行连接：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-const">const</span> string s <span class="token punctuation">{</span><span class="token string">"a-b-c-d-e-f-g"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>创建一个<code>bin_func</code>对象，其能接受一组迭代器，我们需要通过该函数创建一个新的字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">binfunc</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> it_a<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> it_b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">string</span><span class="token punctuation">(</span>it_a<span class="token punctuation">,</span> it_b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>输出的子序列将保存在<code>std::list</code>中。我们现在可以调用<code>split</code>算法：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> l<span class="token punctuation">;</span>
    <span class="token function">split</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">,</span> binfunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了看一下结果，我们将对子字符串进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span> ostream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</pre></li>
<li>
<p>编译并运行程序，就可以看到如下输出。其子序列将不会包含破折号，只有单个单词(在我们的例子中，为单个字母)：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>split
a
b
c
d
e
f
g
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>split</code>算法与<code>std::transform</code>的工作原理很类似，因为其能接受一对<code>begin/end</code>迭代器和一个输出迭代器。其也会将最终的算法结果拷贝到输出迭代器所在的容器。除此之外，其接受一个<code>split_val</code>值和一个二元函数。让我们再来看一起其整体实现：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">InIt</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">OutIt</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
InIt <span class="token function">split</span><span class="token punctuation">(</span>InIt it<span class="token punctuation">,</span> InIt end_it<span class="token punctuation">,</span> OutIt out_it<span class="token punctuation">,</span> T split_val<span class="token punctuation">,</span> F bin_func<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">slice_end</span> <span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> end_it<span class="token punctuation">,</span> split_val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>out_it<span class="token operator">++</span> <span class="token operator">=</span> <span class="token function">bin_func</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> slice_end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>slice_end <span class="token operator">==</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> end_it<span class="token punctuation">;</span> <span class="token punctuation">}</span>
        it <span class="token operator">=</span> <span class="token function">next</span><span class="token punctuation">(</span>slice_end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> it<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>实现中的循环会一直进行到输入范围结束。每次迭代中都会调用<code>std::find</code>用来在输入范围内查找下一个与<code>split_val</code>匹配的元素。在我们的例子中，分割字符就是<code>-</code>。每次的下一个减号字符的位置会存在<code>slice_end</code>。每次循环迭代之后，<code>it</code>迭代器将会更新到下一个分割字符所在的位置。循环起始范围将从一个减号跳到下一个减号，而非每一个独立的元素。</p>
<p>这一系列的操作中，迭代器<code>it</code>指向的是最后子字符串的起始位置，<code>slice_end</code>指向的是子字符串的末尾位置。通过这两个迭代器，就能表示分割后的子字符串。对于字符串<code>foo-bar-baz</code>来说，循环中就有三个迭代器。对于用户而言，迭代器什么的并不重要，他们想要的是子字符串，所以这里就是<code>bin_func</code>来完成这个任务。当我们调用<code>split</code>时，我们可以给定其一个如下的二元函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> it_a<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> it_b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token function">string</span><span class="token punctuation">(</span>it_a<span class="token punctuation">,</span> it_b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p><code>split</code>函数会将迭代器传递给<code>bin_func</code>，并通过迭代器将结果放入输出迭代器中。这样我们就能通过<code>bin_func</code>获得相应的单词，这里的结果是<code>foo</code>，<code>bar</code>和<code>baz</code>。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>我们也可以实现相应的迭代器来完成这个算法的实现。我们现在不会去实现这样一个迭代器，但是可以简单的看一下。</p>
<p>迭代的每次增长，都会跳转到下一个限定符。</p>
<p>当对迭代器进行解引用时，其会通过迭代器指向的当前位置，创建一个字符串对象，就如同之前用到的<code>bin_func</code>函数那样。</p>
<p>迭代器类可以称为<code>split_iterator</code>，用来替代算法<code>split</code>，用户的代码可以写成如下的样式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">string s <span class="token punctuation">{</span><span class="token string">"a-b-c-d-e-f-g"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> l<span class="token punctuation">;</span>

<span class="token keyword keyword-auto">auto</span> <span class="token function">binfunc</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> it_a<span class="token punctuation">,</span> <span class="token keyword keyword-auto">auto</span> it_b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token function">string</span><span class="token punctuation">(</span>it_a<span class="token punctuation">,</span> it_b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">copy</span><span class="token punctuation">(</span>split_iterator<span class="token punctuation">{</span><span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">,</span> binfunc<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">back_inserter</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>虽然在使用中很方便，但是在实现时，迭代器的方式要比算法的形式复杂许多。并且，迭代器实现中很多边缘值会触发代码的bug，并且迭代器实现需要经过非常庞杂的测试。不过，其与其他STL算法能够很好的兼容。</p>
</div></div><div id="ebook-heading-x5c06x6807x51c6x7b97x6cd5x8fdbx884cx7ec4x5408" ebook-toc-level-2="" heading="将标准算法进行组合"><div><h1 class="mume-header" id="%E5%B0%86%E6%A0%87%E5%87%86%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%BB%84%E5%90%88">将标准算法进行组合</h1>

<p><code>gather</code>为STL算法中最好的组合性例子。Sean Parent在任Adobe系统首席科学家时，就在向世人普及这个算法，因为其本身短小精悍。其使用方式就如同做一件艺术品一样。</p>
<p><code>gather</code>算法能操作任意的元素类型。其更改元素的顺序，通过用户的选择，其会将对应的数据放置在对应位置上。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们来实现<code>gather</code>算法，并对其进行一定的修改。最后，将展示如何进行使用：</p>
<ol>
<li>
<p>包含必要的头文件，声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p><code>gather</code>算法是表现标准算法组合性很好的一个例子。<code>gather</code>接受一对<code>begin/end</code>迭代器和另一个迭代器<code>gather_pos</code>，其指向<code>begin</code>和<code>end</code>迭代器的中间位置。最后一个参数是一个谓词函数。使用谓词函数，算法会将满足谓词条件的所有元素放置在<code>gather_pos</code>迭代器附近。使用<code>std::stable_partition</code>来完成移动元素的任务。<code>gather</code>算法将会返回一对迭代器。这两个迭代器由<code>stable_partition</code>所返回，其表示汇集范围的起始点和结束点：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">It</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
pair<span class="token operator">&lt;</span>It<span class="token punctuation">,</span> It<span class="token operator">&gt;</span> <span class="token function">gather</span><span class="token punctuation">(</span>It first<span class="token punctuation">,</span> It last<span class="token punctuation">,</span> It gather_pos<span class="token punctuation">,</span> F predicate<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token function">stable_partition</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> gather_pos<span class="token punctuation">,</span> <span class="token function">not_fn</span><span class="token punctuation">(</span>predicate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		    <span class="token function">stable_partition</span><span class="token punctuation">(</span>gather_pos<span class="token punctuation">,</span> last<span class="token punctuation">,</span> predicate<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>算法的另一种变体为<code>gather_sort</code>。其工作原理与<code>gather</code>相同，不过其不接受一元谓词函数；其能接受一个二元比较函数。这样，其就也能将对应值汇集在<code>gather_pos</code>附近，并且能知道其中最大值和最小值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">It</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">gather_sort</span><span class="token punctuation">(</span>It first<span class="token punctuation">,</span> It last<span class="token punctuation">,</span> It gather_pos<span class="token punctuation">,</span> F comp_func<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">inv_comp_func</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token operator">!</span><span class="token function">comp_func</span><span class="token punctuation">(</span>ps<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">stable_sort</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> gather_pos<span class="token punctuation">,</span> inv_comp_func<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">stable_sort</span><span class="token punctuation">(</span>gather_pos<span class="token punctuation">,</span> last<span class="token punctuation">,</span> comp_func<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>让我们来使用一下这些算法。先创建一个谓词函数，其会告诉我们当前的字母是不是<code>a</code>，再构建一个字符串，仅包含<code>a</code>和<code>-</code>字符：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">is_a</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> c <span class="token operator">==</span> <span class="token string">'a'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    string a <span class="token punctuation">{</span><span class="token string">"a_a_a_a_a_a_a_a_a_a_a"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>继续构造一个迭代器，让其指向字符串的中间位置。这时可以调用<code>gather</code>算法，然后看看会发生什么。<code>a</code>字符将汇集在字符串中间的某个位置附近：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">middle</span> <span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	<span class="token function">gather</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> middle<span class="token punctuation">,</span> is_a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>再次调用<code>gather</code>，不过这次<code>gather_pos</code>的位置在字符串的起始端：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">gather</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> is_a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>再将<code>gather_pos</code>的位置放在末尾试试：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">gather</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> is_a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>最后一次，这次将再次将迭代器指向中间位置。这次与我们的期望不相符，后面我们来看看发生了什么：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token comment">// This will NOT work as naively expected</span>
	<span class="token function">gather</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> middle<span class="token punctuation">,</span> is_a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>再构造另一个字符串，使用下划线和一些数字组成。对于这个输入队列，我们使用<code>gather_sort</code>。<code>gather_pos</code>迭代器指向字符串的中间，并且比较函数为<code>std::less&lt;char&gt;</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    string b <span class="token punctuation">{</span><span class="token string">"_9_2_4_7_3_8_1_6_5_0_"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">gather_sort</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span>
    		   less<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就会看到如下的输出。对于前三行来说和预期一样，不过第四行貌似出现了一些问题。最后一行中，我们可以看到<code>gather_short</code>函数的结果。数字的顺序是排过序的(中间小，两边大)：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>gather
_____aaaaaaaaaaa_____
aaaaaaaaaaa__________
__________aaaaaaaaaaa
__________aaaaaaaaaaa
_____9743201568______
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>gather</code>算法有点难以掌握，因为其非常短，但处理的是比较复杂的问题。让我们来逐步解析这个算法：</p>
<p><img src="./C++17 STL Cook book_files/6-7-1.png" alt=""></p>
<ol>
<li>初始化相应元素，并提供一个谓词函数。图中满足谓词函数条件的元素为灰色，其他的为白色。迭代器<code>a</code>和<code>c</code>表示整个范围的长度，并且迭代器<code>b</code>指向了最中间的元素。这就表示要将所有灰色的格子聚集在这个迭代器附近。</li>
<li><code>gather</code>算法会对范围<code>(a, b]</code>调用<code>std::stable_partition</code>，并对另一边使用不满足谓词条件的结果。这样就能将所有灰色格子集中在b迭代器附近。</li>
<li>另一个<code>std::stable_partition</code>已经完成，不过在<code>[b, c)</code>间我们将使用满足谓词函数的结果。这样就将灰色的格子汇集在b迭代器附近。</li>
<li>所有灰色的格子都汇集在<code>b</code>迭代器附近，这是就可以返回起始迭代器<code>x</code>和末尾迭代器<code>y</code>，用来表示所有连续灰色格子的范围。</li>
</ol>
<p>我们对同一个范围多次调用<code>gather</code>算法。最初，将所有元素放在范围中间位置。然后，尝试放在开始和末尾。这种实验很有趣，因为这会让其中一个<code>std::stable_partition</code>无元素可以处理。</p>
<p>最后一次对<code>gather</code>进行调用时，参数为<code>(begin, end, middle)</code>，但没有和我们预期的一样，这是为什么呢？这看起来像是一个bug，实际上不是。</p>
<p>试想一个字符组<code>aabb</code>，使用谓词函数<code>is_character_a</code>，用来判断元素是否为<code>a</code>，当我们将第三个迭代器指向字符范围的中间时，会复现这个bug。原因：第一个<code>stable_partition</code>调用会对子范围<code>aa</code>进行操作，并且另一个<code>stable_partition</code>会对子范围<code>bb</code>上进行操作。这种串行的调用时无法得到<code>baab</code>的，其结果看起来和开始一样，没有任何变化。</p>
<blockquote>
<p>Note：</p>
<p>要是想得到我们预期的序列，我们可以使用<code>std::rotate(begin, begin + 1, end);</code></p>
</blockquote>
<p><code>gather_sort</code>基本上和<code>gather</code>差不多。签名不同的就是在于谓词函数。实现的不同在于<code>gather</code>调用了两次<code>std::stable_partition</code>，而<code>gather_sort</code>调用了两次<code>std::stable_sort</code>。</p>
<p>这是由于<code>not_fn</code>不能作用域二元函数，所以反向比较不能由<code>not_fn</code>完成。</p>
</div></div><div id="ebook-heading-x5220x9664x8bcdx7ec4x95f4x8fdex7eedx7684x7a7ax683c" ebook-toc-level-2="" heading="删除词组间连续的空格"><div><h1 class="mume-header" id="%E5%88%A0%E9%99%A4%E8%AF%8D%E7%BB%84%E9%97%B4%E8%BF%9E%E7%BB%AD%E7%9A%84%E7%A9%BA%E6%A0%BC">删除词组间连续的空格</h1>

<p>我们会经常从输入中读取字符串，这些字符串会包含一些原生格式，需要进行清洗。其中一个例子就是字符串中包含了太多的空格。</p>
<p>本节，我们将实现一个聪明的空格滤波算法，其会删除多于的空格，会给单词间留下一个空格。我们可以将这个算法称为<code>remove_multi_whitespace</code>，并且接口与STL很像。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将实现过滤空格的算法，并了解其是如何进行工作的：</p>
<ol>
<li>
<p>包含必要的头文件和声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>remove_multi_whitespace</code>看起来与STL的风格非常类似。这个算法会移除多余的空格，只保留一个空格。当字符串为<code>a b</code>，算法是不会进行任何操作的；当字符串为<code>a b</code>时，算法会返回<code>a b</code>。为了完成这个算法，我们使用<code>std::unqiue</code>通过对一段区域的迭代，用来查找一对连续的元素。然后，通过谓词函数进行判断，确定两个元素是否相等。如果相等，那么<code>std::unique</code>会将其中一个移除。这样，子范围中就不会存在相等的元素了。谓词函数会通过读取到的内容来判断二者是否相等。我们需要给<code>std::unique</code>怎么样一个谓词函数呢？其需要判断两个元素是否是连续的空格；如果是，就要移除一个空格。与<code>std::unique</code>类似，也需要传入一对<code>begin/end</code>迭代器，然后返回的迭代器将返回新范围的末尾迭代器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span>
It <span class="token function">remove_multi_whitespace</span><span class="token punctuation">(</span>It it<span class="token punctuation">,</span> It end_it<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">unique</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> end_it<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">isspace</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isspace</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>万事俱备，就来进行测试，尝试使用算法将不必要的空格进行删除：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    string s <span class="token punctuation">{</span><span class="token string">"fooo bar \t baz"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>对字符串使用过滤算法，去掉多余的空格：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove_multi_whitespace</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就会得到如下的输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>remove_consecutive_whitespace
fooo bar       baz
fooo bar baz
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>整个问题的解决中，我们没有使用循环或者元素间的互相比较。我们只使用谓词函数来完成判断两个给定字符是否是空格的任务。然后，将谓词函数与<code>std::unique</code>相结合，所有多余的空格就都消失了。本章中有些算法可能会有些争议，不过这个算法的确算的上短小精悍的典范了。</p>
<p>我们如何在将算法进行组合的呢？我们来看一下<code>std::unique</code>可能的实现代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">It</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">P</span><span class="token operator">&gt;</span>
It <span class="token function">unique</span><span class="token punctuation">(</span>It it<span class="token punctuation">,</span> It end<span class="token punctuation">,</span> P p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> end<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    It result <span class="token punctuation">{</span>it<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>it <span class="token operator">!=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">*</span>result<span class="token punctuation">,</span> <span class="token operator">*</span>it<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">++</span>result <span class="token operator">!=</span> it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token operator">*</span>result <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword keyword-return">return</span> <span class="token operator">++</span>result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>其中循环会迭代到范围的最后，当元素满足谓词条件，就会从原始位置上移除一个元素。这个版本的<code>std::unique</code>不接受多余的谓词函数，来判断两个相邻的元素是否相等。这样的话，只能将重复的字符去除，比如会将<code>abbbbbbbbc</code>变换成<code>abc</code>。</p>
<p>那么，我们应该怎么做才能不去除除了空格之外的重复的元素呢？这样，谓词函数不能告诉程序“两个输入字符是相同的”，而是要说“两个输入字符都是空格”。</p>
<p>最后需要注意的是，无论是<code>std::unique</code>还是<code>remove_multi_whitespace</code>都会从字符串中移除字母元素。根据字符串的语义来移动字符串，并表明新的结尾在哪里。新的尾部到旧的尾部的元素依旧存在，所以我们必须将它们删除：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">remove_multi_whitespace</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>和<code>vector</code>和<code>list</code>一样，<code>erase</code>成员函数其会对元素进行擦除和删除。</p>
</div></div><div id="ebook-heading-x538bx7f29x548cx89e3x538bx7f29x5b57x7b26x4e32" ebook-toc-level-2="" heading="压缩和解压缩字符串"><div><h1 class="mume-header" id="%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2">压缩和解压缩字符串</h1>

<p>压缩问题在编程面试中出现的相对较多。就是使用一个函数将<code>aaaaabbbbbbbccc</code>字符串转换成一个短字符串<code>a5b7c3</code>。<code>a5</code>表示原始字符串中有5个a，<code>b7</code>表示原始字符串中有7个b。这就一个相对简单的压缩算法。对于普通的文本，并不需要使用这个算法，因为文本中重复的东西很少，不需要进行压缩。不过，这套算法就算没有计算机，我们也能很容易的对其进行实现。如果代码在一开始没有进行很好的设计，那么就很容易出现bug。虽然，处理字符串并不是一件很困难的事情，但是代码中大量使用C风格的字符串时，很有可能遇到缓冲区溢出的bug。</p>
<p>本节让我们使用STL来对字符压缩和解压进行实现。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将对字符串实现简单的<code>compress</code>和<code>decompress</code>函数：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tuple&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>对于我们的压缩算法，我们会尝试去找到文本中连续相同的字符，并且对他们进行单独的进行压缩处理。当我们拿到一个字符串，我们需要知道与第一个字符不同的字符在哪里。这里使用<code>std::find</code>来寻找与第一个位置上的元素不同的元素位置。先将起始位置的字符赋予<code>c</code>。经过查找后就会返回一个迭代器，其指向第一个不同的元素。两个不同字符间的距离，会放到元组中返回：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">It</span><span class="token operator">&gt;</span>
tuple<span class="token operator">&lt;</span>It<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span><span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> <span class="token function">occurrences</span><span class="token punctuation">(</span>It it<span class="token punctuation">,</span> It end_it<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span>it<span class="token punctuation">,</span> <span class="token string">'?'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> c <span class="token punctuation">{</span><span class="token operator">*</span>it<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">diff</span> <span class="token punctuation">(</span><span class="token function">find_if</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> end_it<span class="token punctuation">,</span>
    			    <span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> c <span class="token operator">!=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span>diff<span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token function">distance</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> diff<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p><code>compress</code>会连续的对<code>occurrences</code>函数进行调用。这样，就能从同一个字符组，跳转到另一个。<code>r &lt;&lt; c &lt;&lt; n</code>行表示将字符<code>c</code>推入到输出流中，并且将<code>occurrences</code>函数的调用次数作为结果字符串的一部分。最后会返回一个字符串对象，就包含了压缩过的字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">string <span class="token function">compress</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">end_it</span> <span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stringstream r<span class="token punctuation">;</span>
    
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token function">it</span> <span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> end_it<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token punctuation">[</span>next_diff<span class="token punctuation">,</span> c<span class="token punctuation">,</span> n<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token function">occurrences</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> end_it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	r <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">;</span>
    	it <span class="token operator">=</span> next_diff<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-return">return</span> r<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p><code>decompress</code>的原理也不复杂，但会更简短。其会持续的从输入流中获取字符，字符串包括字符和数字。对于这两种值，函数会构造一个字符串用于解压所获取到的字符串。最后，会再次返回一个字符串。顺带一提，这里的<code>decompress</code>函数是不安全的。其很容易被破解。我们会在后面来看下这个问题：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">string <span class="token function">decompress</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    stringstream ss<span class="token punctuation">{</span>s<span class="token punctuation">}</span><span class="token punctuation">;</span>
    stringstream r<span class="token punctuation">;</span>
    
    <span class="token keyword keyword-char">char</span> c<span class="token punctuation">;</span>
    size_t n<span class="token punctuation">;</span>
    
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>ss <span class="token operator">&gt;&gt;</span> c <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> r <span class="token operator">&lt;&lt;</span> <span class="token function">string</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> r<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中会构造一个简单的字符串，里面有很多重复的字符。打印压缩过后，和解压过后的字符串。最后，我们应该会得到原始的字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    string s <span class="token punctuation">{</span><span class="token string">"aaaaaaaaabbbbbbbbbccccccccccc"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">compress</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">decompress</span><span class="token punctuation">(</span><span class="token function">compress</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就会得到如下的输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>compress
a9b9c11
aaaaaaaaabbbbbbbbbccccccccccc
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>这里我们使用两个函数<code>compress</code>和<code>decompress</code>来解决这个问题。</p>
<p>解压函数这里实现的十分简单，因为其就包含一些变量的声明，其主要工作的代码其实只有一行：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>ss <span class="token operator">&gt;&gt;</span> c <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> r <span class="token operator">&lt;&lt;</span> <span class="token function">string</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre><p>其能持续将字符读取到<code>c</code>当中，并且将数字变量读取到<code>n</code>中，然后输出到<code>r</code>中。<code>stringstream</code>类在这里会隐藏对字符串解析的细节。当成功进行解压后，解压的字符串将输入到字符流中，这也就是<code>decompress</code>最后的结果。如果<code>c = 'a'</code>并且<code>n = 5</code>，那么<code>string(n, c)</code>的字符串为<code>aaaaa</code>。</p>
<p>压缩函数比较复杂，我们为其编写了一个小的辅助函数。这个辅助函数就是<code>occurences</code>。那么我们就先来看一下<code>occurences</code>函数。下面的图展示了<code>occurences</code>函数工作的方式：</p>
<p><img src="./C++17 STL Cook book_files/6-9-1.png" alt=""></p>
<p><code>occurences</code>函数能够接受两个参数：指向字符序列起始点的迭代器和末尾点的迭代器。使用<code>find_if</code>能找到第一个与起始点字符不同的字符的位置，也就是图中的<code>diff</code>迭代器的位置。起始位置与<code>diff</code>位置之间元素就与起始字符相同，图中相同的字符有6个。在我们计算出这些信息后，<code>diff</code>迭代就可以在下次查询时，进行重复利用。因此，我们将<code>diff</code>、子序列范围和子序列范围的长度包装在一个元组中进行返回。</p>
<p>根据这些信息，我们就能在子序列之间切换，并且将结果推入到目标字符串中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token function">it</span> <span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> end_it<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token punctuation">[</span>next_diff<span class="token punctuation">,</span> c<span class="token punctuation">,</span> n<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token function">occurrences</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> end_it<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    r <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">;</span>
    it <span class="token operator">=</span> next_diff<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><h2 class="mume-header" id="theres-more">There's more...</h2>

<p>还记得在第4步的时候，我们说过<code>decompress</code>不安全吗？这个函数确实容易被利用。</p>
<p>试想我们传入一个字符串：<code>a00000</code>。压缩的第一个结果为<code>a1</code>因为其只包含了一个字母<code>a</code>。然后，对后面5个0进行处理，结果为<code>05</code>。然后将两个结果合并，那么结果就为<code>a105</code>。不幸的是，外部对这个字符串的解读是“a连续出现了105次”。我们的输入字符串并没有什么错。这里最糟糕的情况就是，我们将这个字符串进行了压缩，然后我们通过输入的六个字符得到了一个长度为105的字符串。试想当用户得到了这样的结果会不会感到愤怒？因为我们的算法并没有准备好应对这样的输入。</p>
<p>为了避免这样的事情发生，我们只能在<code>compress</code>函数中禁止数字的输入，或者将数字使用其他的方式进行处理。之后，<code>decompress</code>算法需要加入一个条件，就是需要固定输出字符串的最大长度。这个就当做作业，交由读者自行完成。</p>
</div></div><div id="ebook-heading-x7b2c7x7ae0-x5b57x7b26x4e32-x6d41x548cx6b63x5219x8868x8fbe" ebook-toc-level-1="" heading="第7章 字符串, 流和正则表达"><div><h1 class="mume-header" id="%E7%AC%AC7%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%B5%81%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE">第7章 字符串, 流和正则表达</h1>

<p>本章，我们将对字符串的处理进行介绍，其中包括处理、解析和打印任意的数据。对于这样的需求，STL提供了I/O流库进行支持。这些库由以下的类组成，对应的类使用灰色框表示：</p>
<p><img src="./C++17 STL Cook book_files/7-0-1.png" alt=""></p>
<p>箭头的指向代表了每个类之间的继承关系。这里面类的数量还挺多，本章中，我们会逐个来熟悉。我们使用类型名称在STL的手册中进行查找时，不一定能直接找到这些类。因为图中的这些名字是对于应用开发者来说的，其中大多数类型的名称都是以<code>basic_</code>为前缀(例如：我们能很容易的在STL文档章找到<code>basic_istream</code>，而<code>istream</code>却很难找到)。以<code>basic_</code>为前缀的I/O流类型为模板类，可以将其特化成不同的字符类型。图中的类型都可以以<code>char</code>类型进行特化。我们将会在本书剩下的章节中，使用以<code>char</code>为特化的版本。当我们看到类型名前面以<code>w</code>开头时(例如：<code>wistream</code>，<code>wostream</code>)，将使用<code>wchar_t</code>类型代替<code>char</code>类型。</p>
<p>图的最顶端，能看到<code>std::ios_base</code>类。我们不能直接对其进行使用，不过其他的类型都是其子类。其一种特化为<code>std::ios</code>，这个类型对象会包含流数据，其能通过<code>good</code>成员函数对流的状态进行查询，还能通过<code>empty</code>成员函数数据状态是否为(EOF)。</p>
<p>我们经常使用的特化类有两个：<code>std::istream</code>和<code>std::ostream</code>。两个类型的前缀<code>i</code>和<code>o</code>代表着输入和输出。我们在之前的代码使用使用其<code>std::cout</code>和<code>std::cin</code>(还有<code>std::cerr</code>)对象对字符串进行过输入和输出。其都是这些类型的实例，也是非常通用的。我们通过<code>ostream</code>进行数据输出，使用<code>istream</code>进行数据输入。</p>
<p><code>iostream</code>类则是对<code>istream</code>和<code>ostream</code>的继承，其将输入和输出的能力进行合并。当我们要对流数据进行输入和输出的时候，我们就有三个类可供使用。</p>
<p><code>ifstream</code>，<code>ofstream</code>和<code>fstream</code>继承于<code>istream</code>，<code>ostream</code>和<code>iostream</code>，不过为I/O流添加了文件的读入写出功能。</p>
<p><code>istringstream</code>,  <code>ostringstream</code>和<code>iostringstream</code>原理十分类似，会将字符串读入内存中，并在内存中对数据进行处理。</p>
</div></div><div id="ebook-heading-x521bx5efax3001x8fdex63a5x548cx8f6cx6362x5b57x7b26x4e32" ebook-toc-level-2="" heading="创建、连接和转换字符串"><div><h1 class="mume-header" id="%E5%88%9B%E5%BB%BA-%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2">创建、连接和转换字符串</h1>

<p>熟悉C++的“老人”们对<code>std::string</code>一定不会陌生。在处理C风格的字符串时，会感觉冗余和痛苦，特别是在于解析、连接和复制这些字符串的时候，而使用<code>std::string</code>确实一种简单的安全的方法。</p>
<p>要特别感谢C++11添加了移动的特性，这样我们就可以对字符串的所有权进行转移。这样，很多情况下的开销就能降的很低。</p>
<p><code>std::string</code>也随着标准的更新添加了新的特性。C++17中添加了一个全新的类——<code>std::string_view</code>。本节我们将在C++17下感受一下这些新特性(将在其他节中使用<code>std::string_view</code>新类，来连接多个字符串)。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，将创建几个字符串和几个字符串代理，并使用它们进行对字符串的连接和转换：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string_view&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token double-colon punctuation">::</span>literals<span class="token punctuation">;</span>
</pre></li>
<li>
<p>首先来创建字符串对象，这里<code>a</code>就为一个<code>string</code>对象。我们使用C风格的字符串对其进行构造(编译后，C风格的字符串就成为静态数组)。构造函数将对其进行拷贝，然后构成一个字符串对象。或者也可直接使用字符字面值操作符<code>""s</code>来代替C风格的字符串。其也会在运行时创建一个字符串对象，这里<code>b</code>也是一个字符串对象，不过这里我们让程序自己去推断这个类型：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	string a <span class="token punctuation">{</span> <span class="token string">"a"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-auto">auto</span> <span class="token function">b</span> <span class="token punctuation">(</span> <span class="token string">"b"</span>s <span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>构造字符串对象的时候，会将相应的内容拷贝到字符串的内部内存中。为了不拷贝，可以直接对输入字符串进行引用，这里就用一下<code>string_view</code>。这个类具有一个字面值操作，称为<code>""sv</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	string_view c <span class="token punctuation">{</span> <span class="token string">"c"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-auto">auto</span> <span class="token function">d</span> <span class="token punctuation">(</span> <span class="token string">"d"</span>sv <span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>OK！现在就让我们来用一下字符串和代理字符串吧！对于这两种类型，其<code>operator&lt;&lt;</code>都是对<code>std::ostream</code>类型重载的类型，所以这两种类型可以直接打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>字符串类也对<code>operator+</code>操作进行了重载，所以可以直接将两个字符串进行连接。连接<code>a</code>和<code>b</code>只要使用<code>+</code>操作就能完成。对于<code>a</code>和<code>c</code>来说，就没有那么简单了，因为c不是一个字符串对象，而是一个字符串代理对象。我们必须先获取<code>c</code>的字符串，这步可以通过对<code>c</code>进行新的字符串构造得到，然后再和<code>a</code>进行相加。这里就有一个问题，“等下！只是为了和<code>a</code>相加，我们就要将<code>c</code>的内容拷贝到临时字符串对象中吗？没有避免使用<code>c.data()</code>进行内容拷贝的方法吗？”这个想法很好，但是类型本身具有缺陷——<code>string_view</code>实例中没有终止符。这个很可能会导致缓存溢出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">+</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">+</span> string<span class="token punctuation">{</span>c<span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>我们来创建一个新的字符串，其包含我们之前创建的所有字符串和字符串代理。使用<code>std::ostringstream</code>，我们能将任意的变量通过流对象进行打印(类似<code>std::cout</code>)，不过其不会显示在终端，而是打印到一个字符串缓存中。对于所有的字符串，我们是用空格对这些字符串进行分割，并使用<code>operator&lt;&lt;</code>将这些字符串打印到新的字符串对象中(使用<code>o.str()</code>):</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">ostringstream o<span class="token punctuation">;</span>

o <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">concatenated</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> concatenated <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>这时我们可以通过相应的函数，将新字符串中所有的字符转换成大写字符。这里使用C库中的<code>toupper</code>函数来完成将字母转换为大写的工作，可将其与<code>std::transform</code>相结合。因为这里字符串的基础类型为<code>char</code>，所以可以直接使用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">transform</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>concatenated<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>concatenated<span class="token punctuation">)</span><span class="token punctuation">,</span>
    		 <span class="token function">begin</span><span class="token punctuation">(</span>concatenated<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token double-colon punctuation">::</span>toupper<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> concatenated <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，将会得到如下输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>creating_strings
a<span class="token punctuation">,</span> b
c<span class="token punctuation">,</span> d
ab
ac
a b c d
A B C D
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>显然，字符串可以通过加法操作进行连接。如果要对<code>string_view</code>使用这个特性，我们首先需要将其转化为<code>std::string</code>。</p>
<p>不过，进行字符串和字符串代理编码时要格外注意，<code>string_view</code>的内容中没有终止符！这也就是为什么我们宁愿写成<code>"abc"s + string{some_string_view}</code>，而不写成<code>"abc"s + some_string_view.data()</code>的原因。除此之外，<code>std::string</code>也提供了<code>append</code>成员函数，其能对<code>string_view</code>实例进行处理，不过其会对字符串的内容直接进行操作。</p>
<blockquote>
<p>Note：</p>
<p><code>std::string_view</code>是非常有用的，不过为了将其与字符串和字符串函数相混合。我们不能假设其具有终止符，其会在标准字符串环境中快速的跳出。幸运的是，通常一些函数的重载版本，可以对其进行正确的处理。</p>
</blockquote>
<p>如果我们想要将更为复杂的字符串进行格式化连接，不需要对字符串实例进行逐个处理。<code>std::stringstream</code>，<code>std::ostringstream</code>和<code>std::istringstream</code>类就适合来处理这种任务，它们能对通过对内存的管理来进行字符串的添加，并且能提供流所具有的所有通用格式化特性。这也就是本节为什么选择<code>std::ostringstream</code>类的原因，其可以很方便的对变量类型进行解析，然后将其放入字符串中。如果想将输入输出进行结合，那么<code>std::stringstream</code>则是一个不错的选择。</p>
</div></div><div id="ebook-heading-x6d88x9664x5b57x7b26x4e32x5f00x59cbx548cx7ed3x675fx5904x7684x7a7ax683c" ebook-toc-level-2="" heading="消除字符串开始和结束处的空格"><div><h1 class="mume-header" id="%E6%B6%88%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F%E5%A4%84%E7%9A%84%E7%A9%BA%E6%A0%BC">消除字符串开始和结束处的空格</h1>

<p>应用从用户端获取到的输入，经常会有很多不必要的空格存在。之前的章节中，将单词间多余的空格进行移除。</p>
<p>现在让我们来看看，被空格包围的字符串应该怎么去移除多余的空格。<code>std::string</code>具有很多不错的辅助函数能完成这项工作。</p>
<blockquote>
<p>Note：</p>
<p>这节看完后，下节也别错过。将会在下节看到我们如何使用<code>std::string_view</code>类来避免不必要的拷贝或数据修改。</p>
</blockquote>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将完成一个辅助函数的实现，其将判断是否有多余的空格在字符串开头和结尾，并复制返回去掉这些空格的字符串，并进行简单的测试：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cctype&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>函数将对一个常量字符串进行首尾空格的去除，并返回首尾没有空格的新字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">string <span class="token function">trim_whitespace_surrounding</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
</pre></li>
<li>
<p><code>std::string</code>能够提供两个函数，这两个函数对我们很有帮助。第一个就是<code>string::find_first_not_of</code>，其能帮助我们找到我们想要跳过的字符。本节中毫无疑问就是空格，其包括空格，制表符和换行符。函数能返回第一个非空格字符的位置。如果字符串里面只有空格，那么会返回<code>string::npos</code>。这意味着没有找到除了空格的其他字符。如果这样，我们就会返回一个空的字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> whitespace<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">" \t\n"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-const">const</span> size_t <span class="token function">first</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_first_not_of</span><span class="token punctuation">(</span>whitespace<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>string<span class="token double-colon punctuation">::</span>npos <span class="token operator">==</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在我们知道新字符串从哪里开始，但是再哪里结尾呢？因此，需要使用另一个函数<code>string::find_last_not_of</code>，其能找到最后一个非空格字符的位置：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-const">const</span> size_t <span class="token function">last</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">find_last_not_of</span><span class="token punctuation">(</span>whitespace<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>使用<code>string::substr</code>就能返回子字符串，返回的字符串没有空格。这个函数需要两个参数——一个是字符串的起始位置，另一个是字符串的长度：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-return">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>这就完成了。现在让我们来编写主函数，创建字符串，让字符串的前后充满空格，以便我们进行移除：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    string s <span class="token punctuation">{</span><span class="token string">" \t\n string surrounded by ugly"</span>
    		 <span class="token string">" whitespace \t\n "</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将打印去除前和去除后的字符串。将字符串放入大括号中，这样就很容易辨别哪里有空格了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"{"</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">"}\n"</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"{"</span>
    	 <span class="token operator">&lt;&lt;</span> <span class="token function">trim_whitespace_surrounding</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    	 <span class="token operator">&lt;&lt;</span> <span class="token string">"}\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译运行程序，就会得到如下的结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>trim_whitespace
<span class="token punctuation">{</span>
string surrounded by ugly whitespace
<span class="token punctuation">}</span>
<span class="token punctuation">{</span>string surrounded by ugly whitespace<span class="token punctuation">}</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节，我们使用了<code>string::find_first_not_of</code>和<code>string::find_last_not_of</code>函数。这两个函数也能接受C风格的字符串，会将其当做字符链表进行搜索。当有一个字符串<code>foo bar</code>时，当调用<code>find_first_not_of("bfo ")</code>时返回5，因为'a'字符是第一个不属于<code>bfo</code>的字符。参数中字符的顺序，在这里并不重要。</p>
<p>倒装的函数也是同样的原理，当然还有两个没有使用到的函数：<code>string::find_first_of</code>和<code>string::find_last_of</code>。</p>
<p>同样也是基于迭代器的函数，需要检查函数是否返回了合理的位置，当没有找到时，函数会返回一个特殊的位置——<code>string::npos</code>。</p>
<p>我们可以从辅助函数中找出字符所在的位置，并且使用<code>string::substr</code>来构造前后没有空格的字符串。这个函数接受一个首字符相对位置和字符串长度，然后就会构造一个子字符串进行返回。举个栗子，<code>string{"abcdef"}.substr(2, 2)</code>将返回<code>cd</code>。</p>
</div></div><div id="ebook-heading-x65e0x9700x6784x9020x83b7x53d6stdstring" ebook-toc-level-2="" heading="无需构造获取std::string"><div><h1 class="mume-header" id="%E6%97%A0%E9%9C%80%E6%9E%84%E9%80%A0%E8%8E%B7%E5%8F%96stdstring">无需构造获取std::string</h1>

<p><code>std::string</code>类是一个十分有用的类，因为其对字符串的处理很方便。其有一个缺陷，当我们想要根据一个字符串获取其子字符串时，我们需要传入一个指针和一个长度变量，两个迭代器或一段拷贝的子字符串。我在之前的章节也这样使用过，消除字符串前后的空格的最后，使用的是拷贝的方式获得前后无空格的字符串。</p>
<p>当我们想要传递一个字符串或一个子字符串到一个不支持<code>std::string</code>的库中时，需要提供裸指针，这样的用法就回退到C的时代。与子字符串问题一样，裸指针不携带字符串长度信息。这样的话就需要将指针和字符串长度进行捆绑。</p>
<p>另一个十分简单的方式就是使用<code>std::string_view</code>。这个类是C++17添加的新特性，并且能提供将字符串指针与其长度捆绑的方法，其体现了数组引用的思想。</p>
<p>当设计函数时，将<code>std::string</code>实例作为参数，但在函数中使用了额外的内存来存储这些字符，以确保原始的字符串不被修改，这时就可以使用<code>std::string_view</code>，其可移植性很好，与STL无关。可以让其他库来提供一个<code>string_view</code>实现，然后将复杂的实现隐藏在背后，并且可以将其用在我们的STL代码中。这样，<code>string_view</code>类就显得非常小，非常好用，因为其能在不同的库间都可以用。</p>
<p><code>string_view</code>另一个很酷的特性，就是可以使用非拷贝的方式引用大字符串中的子字符串。本节将使用<code>string_view</code>，从而了解其优点和缺点。我们还会看到如何使用字符串代理来去除字符两端的空格，并不对原始字符串进行修改和拷贝。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，将使用<code>string_view</code>的一些特性来实现一个函数，我们将会看到有多少种类型可以输入：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string_view&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>将<code>string_view</code>作为函数的参数：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span>string_view v<span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
</pre><ol start="3">
<li>
<p>对输入字符串做其他事情之前，将移除字符开头和末尾的空格。将不会对字符串进行修改，仅适用字符串代理获取没有空格字符串。<code>find_first_not_of</code>函数将会在字符串找到第一个非空格的字符，适用<code>remove_prefix</code>，<code>string_view</code>将指向第一个非空格的字符。当字符串只有空格，<code>find_first_not_of</code>函数会返回<code>npos</code>，其为<code>size_type(-1)</code>。<code>size_type</code>是一个无符号类型，其可以是一个非常大的值。所以，会在字符串代理的长度和<code>words_begin</code>中选择较小的那个：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">words_begin</span> <span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">find_first_not_of</span><span class="token punctuation">(</span><span class="token string">" \t\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	v<span class="token punctuation">.</span><span class="token function">remove_prefix</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>words_begin<span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们对尾部的空格做同样的事情。<code>remove_suffix</code>将收缩到代理的大小：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">words_end</span> <span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">find_last_not_of</span><span class="token punctuation">(</span><span class="token string">" \t\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>words_end <span class="token operator">!=</span> string_view<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		v<span class="token punctuation">.</span><span class="token function">remove_suffix</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> words_end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 
</pre></li>
<li>
<p>现在可以打印字符串代理和其长度：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"length: "</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		 <span class="token operator">&lt;&lt;</span> <span class="token string">" ["</span> <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> <span class="token string">"]\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，将使用<code>print</code>的函数答应一系列完全不同的参数类型。首先，会通过<code>argv</code>传入<code>char*</code>类型的变量，运行时其会包含可执行文件的名字。然后，传入一个<code>string_view</code>的实例。然后，使用C风格的静态字符串，并使用<code>""sv</code>字面字符构造的<code>string_view</code>类型。最后，传入一个<code>std::string</code>。<code>print</code>函数不需要对参数进行修改和拷贝。这样就没有多余的内存分配发生。对于很多大型的字符串，这将会非常有效：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">print</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a const char * array"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"an std::string_view literal"</span>sv<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"an std::string instance"</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>这里还没对空格移除特性进行测试。这里也给出一个头尾都有空格的字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" \t\n foobar \n \t "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p><code>string_view</code>另一个非常酷的特性是，其给予的字符串是不包含终止符的。当构造一个字符串，比如"abc"，没有终止符，<code>print</code>函数就能很安全的对其进行处理，因为<code>string_view</code>携带字符串的长度信息和指向信息：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-char">char</span> cstr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">string_view</span><span class="token punctuation">(</span>cstr<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>cstr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就会得到如下的输出，所有字符串都能被正确处理。前后有很多空格的字符串都被正确的处理，<code>abc</code>字符串没有终止符也能被正确的打印，而没有任何内存溢出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>string_view
length<span class="token operator">:</span> <span class="token number">17</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token operator">/</span>string_view<span class="token punctuation">]</span>
length<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
length<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">[</span>a <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span> array<span class="token punctuation">]</span>
length<span class="token operator">:</span> <span class="token number">27</span> <span class="token punctuation">[</span>an std<span class="token double-colon punctuation">::</span>string_view literal<span class="token punctuation">]</span>
length<span class="token operator">:</span> <span class="token number">23</span> <span class="token punctuation">[</span>an std<span class="token double-colon punctuation">::</span>string instance<span class="token punctuation">]</span>
length<span class="token operator">:</span> <span class="token number">6</span> <span class="token punctuation">[</span>foobar<span class="token punctuation">]</span>
length<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">[</span>abc<span class="token punctuation">]</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>我们可以看到，函数可以接受传入一个<code>string_view</code>的参数，其看起来与字符串类型没有任何区别。我们实现的<code>print</code>，对于传入的字符串不进行任何的拷贝。</p>
<p>对于<code>print(argv[0])</code>的调用是非常有趣的，字符串代理会自动的推断字符串的长度，因为需要将其适用于无终止符的字符串。另外，我们不能通过查找终止符的方式来确定<code>string_view</code>实例的长度。正因如此，当使用裸指针(<code>string_view::data()</code>)的时候就需要格外小心。通常字符串函数都会认为字符串具有终止符，这样就很难出现使用裸指针时出现内存溢出的情况。这里还是使用字符串代理的接口比较好。</p>
<p>除此之外，<code>std::string</code>接口阵容已经非常豪华了。</p>
<blockquote>
<p>Note：</p>
<p>使用<code>std::string_view</code>用于解析字符或获取子字符串时，能避免多余的拷贝和内存分配，并且还不失代码的舒适感。不过，对于<code>std::string_view</code>将终止符去掉这点，需要特别注意。</p>
</blockquote>
</div></div><div id="ebook-heading-x4ecex7528x6237x7684x8f93x5165x8bfbx53d6x6570x503c" ebook-toc-level-2="" heading="从用户的输入读取数值"><div><h1 class="mume-header" id="%E4%BB%8E%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5%E8%AF%BB%E5%8F%96%E6%95%B0%E5%80%BC">从用户的输入读取数值</h1>

<p>本书中大多数例程的输入都是从文件或标准输入中获得。这次我们重点来了解一下读取，以及当遇到一些有问题的流时，不能直接终止程序，而是要做一些错误处理的工作。</p>
<p>本节只会从用户输入中读取，知道如何读取后，将了解如何从其他的流中读取数据。用户输入通常通过<code>std::cin</code>，其为最基础的输入流对象，类似这样的类还有<code>ifstream</code>和<code>istringstream</code>。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，将从用户输入中读取不同值，并且了解如何进行错误处理，并对输入中有用的部分进行较为复杂的标记。</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>首先，提示用户输入两个数字。将这两个数字解析为<code>int</code>和<code>double</code>类型。例如，用户输入<code>1 2.3</code>:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please Enter two numbers:\n&gt; "</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword keyword-double">double</span> y<span class="token punctuation">;</span>
</pre></li>
<li>
<p>解析和错误检查同时在<code>if</code>判断分支中进行。只有两个数都被解析成有效的数字，才能对其进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> x <span class="token operator">&gt;&gt;</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"You entered: "</span> <span class="token operator">&lt;&lt;</span> x
    		 <span class="token operator">&lt;&lt;</span> <span class="token string">" and "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>如果因为任何原因，解析不成功，那么我们要告诉用户为什么会出错。<code>cin</code>流对象现在处于失败的状态，并且将错误状态进行清理之前，无法为我们提供输入功能。为了能够对新的输入进行解析需要调用<code>cin.clear()</code>，并且将之前接受到的字符丢弃。使用<code>cin.ignore</code>完成丢弃的任务，这里我们指定了丢弃字符的数量，直到遇到下一个换行符为止。完成这些事之后，输入有可以用了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Oh no, that did not go well!\n"</span><span class="token punctuation">;</span>
        cin<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cin<span class="token punctuation">.</span><span class="token function">ignore</span><span class="token punctuation">(</span>
        	std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>streamsize<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        	<span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>让用户输入一些其他信息。我们让用户输入名字，名字由多个字母组成，字母间使用空格隔开。因此，可以使用<code>std::getline</code>函数，其需要传入一个流对象和一个分隔字符。我们选逗号作为分隔字符。这里使用<code>getline</code>来代替<code>cin &gt;&gt; ws</code>的方式读入字符，这样我们就能丢弃在名字前的所有空格。对于每一个循环中都会打印当前的名字，如果名字为空，那么我们会将其丢弃：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"now please enter some "</span>
    		<span class="token string">"comma-separated names:\n&gt; "</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>string s<span class="token punctuation">;</span> <span class="token function">getline</span><span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> ws<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name: \""</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">"\"\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就会得到如下的输出，其会让用户进行输入，然后我们输入合法的字符。数字<code>1 2</code>都能被正确的解析，并且后面输入的名字也能立即排列出来。两个逗号间没有单词的情况将会跳过：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>strings_from_user_input
Please Enter two numbers<span class="token operator">:</span>
<span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token number">2</span>
You entered<span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">2</span>
now please enter some comma<span class="token operator">-</span>separated names<span class="token operator">:</span>
<span class="token operator">&gt;</span> john doe<span class="token punctuation">,</span>ellen ripley<span class="token punctuation">,</span> alice<span class="token punctuation">,</span>chuck norris<span class="token punctuation">,</span><span class="token punctuation">,</span>
name<span class="token operator">:</span> <span class="token string">"john doe"</span>
name<span class="token operator">:</span> <span class="token string">"ellen ripley"</span>
name<span class="token operator">:</span> <span class="token string">"alice"</span>
name<span class="token operator">:</span> <span class="token string">"chuck norris"</span>
</pre></li>
<li>
<p>再次运行程序，这次将在一开始就输入一些非法数字，可以看到程序就会走到不同的分支，然后丢弃相应的输入，并继续监听正确的输入。可以看到<code>cin.clear()</code>和<code>cin.ignore(...)</code>的调用如何对名字读取进行影响：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>strings_from_user_input
Please Enter two numbers<span class="token operator">:</span>
<span class="token operator">&gt;</span> a b
Oh no<span class="token punctuation">,</span> that did <span class="token operator">not</span> go well<span class="token operator">!</span>
now please enter some comma<span class="token operator">-</span>separated names<span class="token operator">:</span>
<span class="token operator">&gt;</span> bud spencer<span class="token punctuation">,</span> terence hill<span class="token punctuation">,</span><span class="token punctuation">,</span>
name<span class="token operator">:</span> <span class="token string">"bud spencer"</span>
name<span class="token operator">:</span> <span class="token string">"terence hill"</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节，我们对一些复杂输入进行了检索。首要注意的是，我们的检索和错误处理是同时进行。</p>
<p>表达式<code>cin &gt;&gt; x</code>是对<code>cin</code>的再次引用。因此，就可以将输入些为<code>cin &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; ...</code>。与此同时，其也能将输入内容转换成为一个布尔值，并在<code>if</code>条件中使用。这个布尔值告诉我们最后一次读取是否成功，这也就是为什么我们会将代码写成<code>if (cin &gt;&gt; x &gt;&gt; y) { ... }</code>的原因。</p>
<p>当我们想要读取一个整型，但输入中包含<code>foobar</code>为下一个表示，那么流对象将无法对这段字符进行解析，并且这让输入流的状态变为失败。这对于解析来说是非常关键的，但对于整个程序来说就不是了。这里可以将输入流的状态进行重置，然后在进行其他的操作。在我们的例程中，我们尝试在读取两个数值失败后，读取一组姓名。例子中，我们使用<code>cin.clear()</code>对<code>cin</code>的工作状态进行了重置。不过，这样内部的光标就处于我们的现在的类型上，而非之前的数字。为了将之前输入的内容丢弃，并对姓名输入进行流水式的读取，我们使用了一个比较长的表达式，<code>cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(),'\n');</code>。这里对内存的清理是十分有必要的，因为我们需要在用户输入一组姓名时，对缓存进行刷新。</p>
<p>下面的循环看起来也挺奇怪的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>string s<span class="token punctuation">;</span> <span class="token function">getline</span><span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> ws<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</pre><p><code>for</code>循环的判断部分，使用了<code>getline</code>函数。<code>getline</code>函数接受一个输入流对象，一个字符串引用作为输出，以及一个分隔符。通常，分隔字符代表新的一行。这里使用逗号作为分隔符，所以姓名输入列表为<code>john, carl, frank</code>，这样就可以单个的进行读取。</p>
<p>目前为止还不错。不过，<code>cin &gt;&gt; ws</code>的操作是怎么回事呢？这可以让<code>cin</code>对所有空格进行刷新，其会读取下一个非空格字符到下一个逗号间的字符。回看一下"john, carl, frank"例子，当我们不使用<code>ws</code>时，将获取到"john"，" carl"和" frank"字符串。这里需要注意"carl"和"frank"开头不必要的空格，因为在<code>ws</code>中对输入流进行了预处理，所以能够避免开头出现空格的情况。</p>
</div></div><div id="ebook-heading-x8ba1x7b97x6587x4ef6x4e2dx7684x5355x8bcdx6570x91cf" ebook-toc-level-2="" heading="计算文件中的单词数量"><div><h1 class="mume-header" id="%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0%E9%87%8F">计算文件中的单词数量</h1>

<p>我们在读取一个文件的时候，也想知道这个文件中包含的单词数量。我们定义的单词是位于两个空格之间的字符组合。那要如何进行统计呢？</p>
<p>根据对单词的定义， 我们可以统计空格的数量。例如句子<code>John has a funny little dog.</code>，这里有五个空格，所以说这句话有六个单词。</p>
<p>如果句子中有空格干扰怎么办，例如：<code>John has \t a\nfunny little dog .</code>。这句中有很多不必要的空格、制表符和换行符。本书的其他章节中，我们已经了解如何将多余空格从字符串中去掉。所以，可以对字符串进行预处理，将不必要的空格都去掉。这样做的确可行，不过我们有更加简单的方法。</p>
<p>为了寻找最优的解决方案，我们将让用户选择，是从标准输入中获取数据，还是从文本文件中获取数据。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将完成一个单行统计函数，其可以对输入的数据进行计数，数据源的具体方式我们可以让用户来选择。</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>wordcount</code>函数能接受一个输入流，例如<code>cin</code>。其能创建一个<code>std::input_iterator</code>迭代器，其能对输出字符进行标记，然后交由<code>std::distance</code>进行计算。<code>distance</code>接受两个迭代器作为参数，并确定从一个迭代器到另一个迭代器要用多少步(距离)。对于随机访问迭代器，因为有减法操作符的存在，所以实现起来非常简单。其迭代器如同指针一样，可以直接进行减法，计算出两点的距离。不过<code>istream_iterator</code>就不行，因为其是前向迭代器，只能向前读取，直至结束。最后所需要的步数也就是单词的数量：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
size_t <span class="token function">wordcount</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>is<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token function">distance</span><span class="token punctuation">(</span>istream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>is<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们会让用户来选择输入源：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	size_t wc<span class="token punctuation">;</span>
</pre></li>
<li>
<p>如果用户选择使用文件进行输入(例如：<code>./count_all_words some_textfile.txt</code>)，我们可以通过<code>argv</code>获取命令行中的文件名称，并将文件打开，读取数据，从而对其文本进行单词统计：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		ifstream ifs <span class="token punctuation">{</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
		wc <span class="token operator">=</span> <span class="token function">wordcount</span><span class="token punctuation">(</span>ifs<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>如果用户没有传入任何参数，就认为用户要使用标准输入流输入数据：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
		wc <span class="token operator">=</span> <span class="token function">wordcount</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	
</pre></li>
<li>
<p>然后只需要将统计出的单词数量保存在变量<code>wc</code>中即可：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"There are "</span> <span class="token operator">&lt;&lt;</span> wc <span class="token operator">&lt;&lt;</span> <span class="token string">" words\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>编译并运行程序。首先，从标准输入中进行输入。我们可以这里通过echo命令将字符串，通过管道传递给程序。当然，我们也可以直接进行输入，并使用<code>Ctrl+D</code>来结束输入：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ echo <span class="token string">"foo bar baz"</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>count_all_words
There are <span class="token number">3</span> words
</pre></li>
<li>
<p>这次我们使用文件作为输入源，并对其中单词数量进行统计：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>count_all_words count_all_words<span class="token punctuation">.</span>cpp
There are <span class="token number">61</span> words
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节也没有什么好多说的；实现很短，难度很低。需要提及的可能就是我们对<code>std::cin</code>和<code>std::ifstream</code>的实例进行了互换。<code>cin</code>是<code>std::istream</code>的类型之一，并且<code>std::ifstream</code>继承于<code>std::istream</code>。可以回顾一下本章开头的类型继承表。这两种类型即使在运行时，都能进行互换。</p>
<blockquote>
<p>Note：</p>
<p>使用流来保持代码的模块性，这有助于减少代码的耦合性。因为其可以匹配任意类型的流对象，所以更容易对代码进行测试。</p>
</blockquote>
</div></div><div id="ebook-heading-x683cx5f0fx5316x8f93x51fa" ebook-toc-level-2="" heading="格式化输出"><div><h1 class="mume-header" id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA">格式化输出</h1>

<p>很多情况下，仅打印字符串和数字是不够的。数字通常都以十进制进行打印，有时我们需要使用十六进制或八进制进行打印。并且在打印十六进制的时候，我们希望看到以<code>0x</code>为前缀的十六进制的数字，但有时却不希望看到这个前缀。</p>
<p>当对浮点数进行打印的时候，也需要注意很多。以何种精度进行打印？要将数中的所有内容进行打印吗？或者是如何打印科学计数法样式的数？</p>
<p>除了数值表示方面的问题外，还需要规范我们打印的格式。有时我们要以表格的方式进行打印，以确保打印数据的可读性。</p>
<p>这所有的一切都与输出流有关，对输入流的解析也十分重要。本节中，我们将来感受一下格式化输出。有些显示也会比较麻烦，不过我们会对其进行解释。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>为了让大家熟悉格式化输出，本节我们将使用各种各样的格式进行打印：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;locale&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>接下来，定义一个辅助函数，其会以不同的方式打印出一个数值。其能接受使用一种字符对宽度进行填充，其默认字符为空格：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">print_aligned_demo</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> val<span class="token punctuation">,</span>
                        size_t width<span class="token punctuation">,</span>
                        <span class="token keyword keyword-char">char</span> fill_char <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
</pre></li>
<li>
<p>使用<code>setw</code>，我们可以设置打印数字的最小字符数输出个数。当我们要将123的输出宽度设置为6时，我们会得到"abc   "或"   abc"。我们也可以使用<code>std::left</code>, <code>std::right</code>和<code>std::internal</code>控制从哪边进行填充。当我们以十进制的方式对数字进行输出，<code>internal</code>看起来和<code>right</code>的作用一样。不过，当打印<code>0x1</code>时，打印宽度为6时，<code>internal</code>会得到"0x  6"。<code>setfill</code>控制符可以用来定义填充字符。我么可以尝试使用使用以下方式进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"================\n"</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">setfill</span><span class="token punctuation">(</span>fill_char<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> left <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span>width<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> right <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span>width<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> internal <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span>width<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们使用已经实现的函数。首先，打印数字12345，其宽度为15。我们进行两次打印，不过第二次时，将填充字符设置为'_'：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">print_aligned_demo</span><span class="token punctuation">(</span><span class="token number">123456</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_aligned_demo</span><span class="token punctuation">(</span><span class="token number">123456</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token string">'_'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>随后，我们将打印<code>0x123abc</code>，并使用同样的宽度。不过，打印之前需要使用的是<code>std::hex</code>和<code>std::showbase</code>告诉输出流对象<code>cout</code>输出的格式，并且添加<code>0x</code>前缀，看起来是一个十六进制数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> hex <span class="token operator">&lt;&lt;</span> showbase<span class="token punctuation">;</span>
	<span class="token function">print_aligned_demo</span><span class="token punctuation">(</span><span class="token number">0x123abc</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>对于八进制我们也可以做同样的事：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> oct<span class="token punctuation">;</span>
	<span class="token function">print_aligned_demo</span><span class="token punctuation">(</span><span class="token number">0123456</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>通过<code>hex</code>和<code>uppercase</code>，我们可以将<code>0x</code>中的x转换成大写字母。<code>0x123abc</code>中的<code>abc</code>同样也转换成大写：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A hex number with upper case letters: "</span>
		<span class="token operator">&lt;&lt;</span> hex <span class="token operator">&lt;&lt;</span> uppercase <span class="token operator">&lt;&lt;</span> <span class="token number">0x123abc</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>	
</pre></li>
<li>
<p>如果我们要以十进制打印100，我们需要将输出从<code>hex</code>切换回<code>dec</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A number: "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">100</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> dec<span class="token punctuation">;</span>
    
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Oops. now in decimal again: "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">100</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们可以对布尔值的输出进行配置，通常，true会打印出1，false为0。使用<code>boolalpha</code>，我们就可以得到文本表达：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"true/false values: "</span>
		<span class="token operator">&lt;&lt;</span> <span class="token boolean">true</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">false</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> boolalpha
		<span class="token operator">&lt;&lt;</span> <span class="token string">"true/false values: "</span>
		<span class="token operator">&lt;&lt;</span> <span class="token boolean">true</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">false</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在让我们来一下浮点型变量<code>float</code>和<code>double</code>的打印。当我们有一个数12.3，那么打印也应该是12.3。当我们有一个数12.0，打印时会将小数点那一位进行丢弃，不过我们可以通过<code>showpoint</code>来控制打印的精度。使用这个控制符，就能显示被丢弃的一位小数了：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"doubles: "</span>
        <span class="token operator">&lt;&lt;</span> <span class="token number">12.3</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>
        <span class="token operator">&lt;&lt;</span> <span class="token number">12.0</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>
        <span class="token operator">&lt;&lt;</span> showpoint <span class="token operator">&lt;&lt;</span> <span class="token number">12.0</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><ol start="11">
<li>
<p>可以使用科学计数法或固定浮点的方式来表示浮点数。<code>scientific</code>会将浮点数归一化成一个十进制的小数，并且其后面的位数使用10的幂级数表示，其需要进行乘法后才能还原成原始的浮点数。比如，300.0科学计数法就表示为"3.0E2"，因为300 = 3.0 x <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">10^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>。<code>fixed</code>将会恢复普通小数的表达方式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"scientific double: "</span> <span class="token operator">&lt;&lt;</span> scientific
		<span class="token operator">&lt;&lt;</span> <span class="token number">123000000000.123</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"fixed double: "</span> <span class="token operator">&lt;&lt;</span> fixed
		<span class="token operator">&lt;&lt;</span> <span class="token number">123000000000.123</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>除此之外，我们也能对打印的精度进行控制。我们先创建一个特别小的浮点数，并对其小数点后的位数进行控制：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Very precise double: "</span>
		<span class="token operator">&lt;&lt;</span> <span class="token function">setprecision</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0.0000000001</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Less precise double: "</span>
		<span class="token operator">&lt;&lt;</span> <span class="token function">setprecision</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0.0000000001</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就会得到如下的输出。前四个块都是有打印辅助函数完成，其使用<code>setw</code>对字符串进行了不同方向的填充。此外，我们也进行了数字的进制转换、布尔数表示和浮点数表示。通过实际操作，我们会对其更加熟悉：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>formatting
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>
<span class="token number">123456</span>         
         <span class="token number">123456</span>
         <span class="token number">123456</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>
<span class="token number">123456</span>_________
_________123456
_________123456
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>
<span class="token number">0x123abc</span>       
       <span class="token number">0x123abc</span>
<span class="token number">0</span>x       <span class="token number">123</span>abc
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>
<span class="token number">0123456</span>        
        <span class="token number">0123456</span>
        <span class="token number">0123456</span>
A hex number with upper <span class="token keyword keyword-case">case</span> letters<span class="token operator">:</span> <span class="token number">0X123ABC</span>
A number<span class="token operator">:</span> <span class="token number">0X64</span>
Ooop<span class="token punctuation">.</span> now in decimal again<span class="token operator">:</span> <span class="token number">100</span>
<span class="token boolean">true</span><span class="token operator">/</span><span class="token boolean">false</span> values<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span>
<span class="token boolean">true</span><span class="token operator">/</span><span class="token boolean">false</span> values<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
doubles<span class="token operator">:</span> <span class="token number">12.3</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">12.0000</span>
scientific <span class="token keyword keyword-double">double</span><span class="token operator">:</span> <span class="token number">1.230000E+12</span>
fixed <span class="token keyword keyword-double">double</span><span class="token operator">:</span> <span class="token number">1230000000000.123047</span>
Very precise <span class="token keyword keyword-double">double</span><span class="token operator">:</span> <span class="token number">0.0000000001</span>
Less previse <span class="token keyword keyword-double">double</span><span class="token operator">:</span> <span class="token number">0.0</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>例程看起来有些长，并且<code>&lt;&lt; foo &lt;&lt; bar</code>的方式对于初级读者来说会感觉到困惑。因此，让我们来看一下格式化修饰符的表。其都是用<code>input_stream &gt;&gt; modifier</code>或<code>output_stream &lt;&lt; modifier</code>来对之后的输入输出进行影响：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/setprecision">setprecision(int)</a></td>
<td>打印浮点数时，决定打印小数点后的位数。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/showpoint">showpoint / noshowpoint</a></td>
<td>启用或禁用浮点数字小数点的打印，即使没有小数位。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/fixed">fixed /scientific / hexfloat /defaultfloat</a></td>
<td>数字可以以固定格式和科学表达式的方式进行打印。<code>fixed</code>和<code>scientific</code>代表了相应的打印模式。<code>hexfloat</code>将会同时激活这两种模式，用十六进制浮点表示法格式化浮点数。<code>defaultfloat</code>则会禁用这两种模式。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/showpos">showpos / noshowpos</a></td>
<td>启用或禁用使用'+'来标志正浮点数。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/setw">setw(int n)</a></td>
<td>设置打印的宽度<code>n</code>。在读取的时候，这种设置会截断输入。当打印位数不够时，其会使用填充字符将输出填充到<code>n</code>个字符。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/setfill">setfill(char c)</a></td>
<td>当我们<code>setw</code>时，会涉及填充字符的设置。<code>setfill</code>可以将填充字符设置为<code>c</code>。其默认填充字符为空格。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/left">internal / left / right</a></td>
<td><code>left</code>和<code>right</code>控制填充的方向。<code>internal</code>会将填充字符放置在数字和符号之间，这对于十六进制打印和一些金融数字来说，十分有用。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/hex">dec / hex / oct</a></td>
<td>整数打印的类型，十进制、十六进制和八进制。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/setbase">setbase(int n)</a></td>
<td>数字类型的同义函数，当<code>n</code>为<code>10/16/8</code>时，与<code>dec / hex / oct</code>完全相同。当传入0时，则会恢复默认输出，也就是十进制，或者使用数字的前缀对输入进行解析。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/quoted">quoted(string)</a></td>
<td>将带有引号的字符串的引号去掉，对其实际字符进行打印。这里<code>string</code>的类型可以是<code>string</code>类的实例，也可以是一个C风格的字符串。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/boolalpha">boolalpha / noboolalpha</a></td>
<td>打印布尔变量，是打印字符形式的，还是数字形式的。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/showbase">showbase / noshowbase</a></td>
<td>启用或禁用基于前缀的数字解析。对于<code>hex</code>来说就是<code>0x</code>，对于<code>octal</code>来说就是<code>0</code>。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/uppercase">uppercase / nouppercase</a></td>
<td>启用或禁用将浮点数中的字母或十六进制中的字符进行大写输出。</td>
</tr>
</tbody>
</table>
<p>看起来很多，想要熟悉这些控制符的最好方式，还是尽可能多的使用它们。</p>
<p>在使用中会发现，其中有一些控制符具有粘性，另一些没有。这里的粘性是说其会持续影响接下来的所有输入或输出，直到对控制符进行重置。表格中没有粘性的为<code>setw</code>和<code>quoted</code>控制符。其只对下一次输入或输入有影响。了解这些非常重要，当我们要持续使用一个格式进行打印时，对于有粘性的控制符我们设置一次即可，其余的则在需要是进行设置。这些对输入解析同样适用，不过错误的设置了控制符则会得到错误的输入信息。</p>
<p>下面的一些控制符我们没有使用它们，因为他们对于格式化没有任何影响，但出于完整性的考量我们在这里也将这些流状态控制符列出来：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/skipws">skipws / noskipws</a></td>
<td>启用或禁用输入流对空格进行略过的特性。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/unitbuf">unitbuf / nounitbuf</a></td>
<td>启用或禁用在进行任何输出操作后，就立即对输出缓存进行刷新。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/ws">ws</a></td>
<td>从输入流舍弃前导空格。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/ends">ends</a></td>
<td>向流中输入一个终止符<code>\0</code>。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/flush">flush</a></td>
<td>对输出缓存区进行刷新。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/io/manip/endl">endl</a></td>
<td>向输出流中插入<code>\n</code>字符，并且刷新输出缓存区。</td>
</tr>
</tbody>
</table>
<p>这些控制符中，只有<code>skipws / noskipws</code>和<code>unitbuf / nounitbuf</code>是具有粘性的。</p>
</div></div><div id="ebook-heading-x4f7fx7528x8f93x5165x6587x4ef6x521dx59cbx5316x590dx6742x5bf9x8c61" ebook-toc-level-2="" heading="使用输入文件初始化复杂对象"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1">使用输入文件初始化复杂对象</h1>

<p>将整型、浮点型和字符串分开读取不是困难，因为流操作符<code>&gt;&gt;</code>对于基础类型有重载的版本，并且输入流会将输入中的空格去除。</p>
<p>不过，对于更加复杂的结构体来说，我们应该如何将其从输入流中读取出来，并且当我们的字符串中需要多个单词的时候应该怎么做呢(在空格处不断开)？</p>
<p>对于任意类型，我们都可以对输入流<code>operator&gt;&gt;</code>操作符进行重载，接下来我们就要看下如何做这件事：</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将定义一个数据结构，并从标准输入中获取数据：</p>
<ol>
<li>
<p>包含必要的头文件和声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>创建一个复杂的对象，我们定义了一个名为<code>city</code>的结构体。城市需要有名字，人口数量和经纬坐标。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">city</span> <span class="token punctuation">{</span>
    string name<span class="token punctuation">;</span>
    size_t population<span class="token punctuation">;</span>
    <span class="token keyword keyword-double">double</span> latitude<span class="token punctuation">;</span>
    <span class="token keyword keyword-double">double</span> longitude<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了从输入流中读取一个城市的信息，这时我们就需要对<code>operator&gt;&gt;</code>进行重载。对于操作符来说，会跳过<code>ws</code>开头的所有空格，我们不希望空格来污染城市的名称。然后，会对一整行的文本进行读取。这样类似于从输入文件中读取一整行，行中只包含城市的信息。然后，我们就可以用空格将人口，经纬度进行区分：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">istream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> city <span class="token operator">&amp;</span>c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    is <span class="token operator">&gt;&gt;</span> ws<span class="token punctuation">;</span>
    <span class="token function">getline</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> c<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    is <span class="token operator">&gt;&gt;</span> c<span class="token punctuation">.</span>population
        <span class="token operator">&gt;&gt;</span> c<span class="token punctuation">.</span>latitude
        <span class="token operator">&gt;&gt;</span> c<span class="token punctuation">.</span>longitude<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> is<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们创建一个<code>vector</code>，其包含了若干城市元素，使用<code>std::copy</code>将其进行填充。我们会将输入的内容拷贝到<code>istream_iterato</code>中。通过给定的<code>city</code>结构体作为模板参数，其会使用重载过的<code>operator&gt;&gt;</code>进行数据的读取：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span>city<span class="token operator">&gt;</span> l<span class="token punctuation">;</span>
    
    <span class="token function">copy</span><span class="token punctuation">(</span>istream_iterator<span class="token operator">&lt;</span>city<span class="token operator">&gt;</span><span class="token punctuation">{</span>cin<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    	<span class="token function">back_inserter</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>为了了解城市信息是否被正确解析，我们会将其进行打印。使用格式化输出<code>left &lt;&lt; setw(15) &lt;&lt;</code>，城市名称左边必有很多的空格，这样我们的输出看起来就很漂亮：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">   <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>name<span class="token punctuation">,</span> pop<span class="token punctuation">,</span> lat<span class="token punctuation">,</span> lon<span class="token punctuation">]</span> <span class="token operator">:</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       cout <span class="token operator">&lt;&lt;</span> left <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> name
           <span class="token operator">&lt;&lt;</span> <span class="token string">" population="</span> <span class="token operator">&lt;&lt;</span> pop
           <span class="token operator">&lt;&lt;</span> <span class="token string">" lat="</span> <span class="token operator">&lt;&lt;</span> lat
           <span class="token operator">&lt;&lt;</span> <span class="token string">" lon="</span> <span class="token operator">&lt;&lt;</span> lon <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</pre></li>
<li>
<p>例程中所用到的文件内容如下。我们将四个城市的信息写入文件：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">Braunschweig
<span class="token number">250000</span> <span class="token number">52.268874</span> <span class="token number">10.526770</span>
Berlin
<span class="token number">4000000</span> <span class="token number">52.520007</span> <span class="token number">13.404954</span>
New York City
<span class="token number">8406000</span> <span class="token number">40.712784</span> <span class="token operator">-</span><span class="token number">74.005941</span>
Mexico City
<span class="token number">8851000</span> <span class="token number">19.432608</span> <span class="token operator">-</span><span class="token number">99.133208</span>
</pre></li>
<li>
<p>编译并运行程序，将会得到如下输入。我们在输入文件中为城市名称前添加一些不必要的空白，以查看空格是如何被过滤掉的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ cat cities<span class="token punctuation">.</span>txt<span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>initialize_complex_objects
Braunschweig    population <span class="token operator">=</span> <span class="token number">250000</span> lat <span class="token operator">=</span> <span class="token number">52.2689</span> lon <span class="token operator">=</span> <span class="token number">10.5268</span>
Berlin          population <span class="token operator">=</span> <span class="token number">4000000</span> lat <span class="token operator">=</span> <span class="token number">52.52</span> lon <span class="token operator">=</span> <span class="token number">13.405</span>
New York City   population <span class="token operator">=</span> <span class="token number">8406000</span> lat <span class="token operator">=</span> <span class="token number">40.7128</span> lon <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">74.0059</span>
Mexico City     population <span class="token operator">=</span> <span class="token number">8851000</span> lat <span class="token operator">=</span> <span class="token number">19.4326</span> lon <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">99.1332</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节也非常短。我们只是创建了一个新的结构体<code>city</code>，我们对<code>std::istream</code>迭代器的<code>operator&gt;&gt;</code>操作符进行重载。这样也就允许我们使用<code>istream_iterator&lt;city&gt;</code>对数据进行反序列化。</p>
<p>关于错误检查则是一个开放性的问题。我们现在再来看下<code>operator&gt;&gt;</code>实现：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">istream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> city <span class="token operator">&amp;</span>c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    is <span class="token operator">&gt;&gt;</span> ws<span class="token punctuation">;</span>
    <span class="token function">getline</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> c<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    is <span class="token operator">&gt;&gt;</span> c<span class="token punctuation">.</span>population <span class="token operator">&gt;&gt;</span> c<span class="token punctuation">.</span>latitude <span class="token operator">&gt;&gt;</span> c<span class="token punctuation">.</span>longitude<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> is<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>我们读取了很多不同的东西。读取数据发生了错误，下一个应该怎么办？这是不是意味着我们有可能读取到错误的数据？不会的，这不可能发生。即便是其中一个元素没有被输入流进行解析，那么输入流对象则会置于错误的状态，并且拒绝对剩下的输入进行解析。这样就意味着，如果<code>c.population</code>或<code>c.latitude</code>没有被解析出来，那么对应的输入数据将会被丢弃，并且我们可以看到反序列了一半的<code>city</code>对象。</p>
<p>站在调用者的角度，我们需要注意这句<code>if(input_stream &gt;&gt; city_object)</code>。这也就表面流表达式将会被隐式转换成一个布尔值。当其返回false时，输入流对象则处于错误状态。如果出现错误，就需要采取相应的措施对流进行重置。</p>
<p>本节中没有使用<code>if</code>判断，因为我们让<code>std::istream_iterator&lt;city&gt;</code>进行反序列化。<code>operator++</code>在迭代器的实现中，会在解析时对其状态进行检查。当遇到错误时，其将会停止之后的所有迭代。当前迭代器与<code>end</code>迭代器比较返回true时，将终止<code>copy</code>算法的执行。如此，我们的代码就很安全了。</p>
</div></div><div id="ebook-heading-x8fedx4ee3x5668x586bx5145x5bb9x5668x2014x2014stdistream" ebook-toc-level-2="" heading="迭代器填充容器——std::istream"><div><h1 class="mume-header" id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A1%AB%E5%85%85%E5%AE%B9%E5%99%A8stdistream">迭代器填充容器——std::istream</h1>

<p>上节中，我们学习了如何从输入流中向数据结构中读入数据，然后用这些数据填充列表或向量。</p>
<p>这次，我们将使用标准输入来填充<code>std::map</code>。问题在于我们不能将一个结构体进行填充，然后从后面推入到线性容器中，例如<code>lis</code>t和<code>vector</code>，因为<code>map</code>的负载分为键和值两部分。</p>
<p>完成本节后，我们会了解到如何从字符流中将复杂的数据结构进行序列化和反序列化。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们会定义一个新的结构体，不过这次将其放入<code>map</code>中，这会让问题变得复杂，因为容器中使用键值来表示所有值。</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们会引用网络上的一些梗。这里的梗作为一个名词，我们记录其描述和诞生年份。我们会将这些梗放入<code>std::map</code>，其名称为键，包含在结构体中的其他信息作为值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">meme</span> <span class="token punctuation">{</span>
    string description<span class="token punctuation">;</span>
    size_t year<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们暂时先不去管键，我们先来实现结构体<code>meme</code>的流操作符<code>operator&gt;&gt;</code>。我们假设相关梗的描述由双引号括起来，后跟对应年份。举个栗子，<code>"some description" 2017</code>。通过使用<code>is &gt;&gt; quoted(m.description)</code>，双引号会被当做限定符，直接被丢弃。这就非常的方便。然后我们继续读取年份即可：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">istream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span> meme <span class="token operator">&amp;</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> is <span class="token operator">&gt;&gt;</span> <span class="token function">quoted</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>description<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> m<span class="token punctuation">.</span>year<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>OK，现在将梗的名称作为键插入<code>map</code>中。为了实现插入<code>map</code>，需要一个<code>std::pair&lt;key_type, value_type&gt;</code>实例。<code>key_type</code>为<code>string</code>，那么<code>value_type</code>就是<code>meme</code>了。名字中允许出现空格，所以可以使用<code>quoted</code>对名称进行包装。<code>p.first</code>是名称，<code>p.second</code>代表的是相关<code>meme</code>结构体变量。可以使用<code>operator&gt;&gt;</code>实现直接对其进行赋值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">istream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span> <span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span>
				    pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> meme<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> is <span class="token operator">&gt;&gt;</span> <span class="token function">quoted</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在来写主函数，创建一个<code>map</code>实例，然后对其进行填充。因为对流函数<code>operator&gt;&gt;</code>进行了重载，所以可以直接对<code>istream_iterator</code>类型直接进行处理。我们将会从标准输入中解析出更多的信息，然后使用<code>inserter</code>迭代器将其放入<code>map</code>中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> meme<span class="token operator">&gt;</span> m<span class="token punctuation">;</span>
    
    <span class="token function">copy</span><span class="token punctuation">(</span>istream_iterator<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> meme<span class="token operator">&gt;&gt;</span><span class="token punctuation">{</span>cin<span class="token punctuation">}</span><span class="token punctuation">,</span>
   		<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    	<span class="token function">inserter</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>对梗进行打印前，先在<code>map</code>中找到名称最长的梗吧。可以对其使用<code>std::accumulate</code>。累加的初始值为0u(u为无符号类型)，然后逐个访问<code>map</code>中的元素，将其进行合并。使用<code>accumulate</code>合并，就意味着叠加。例子中，并不是对数值进行叠加，而是对最长字符串的长度进行进行累加。为了得到长度，我们为<code>accumulate</code>提供了一个辅助函数<code>max_func</code>，其会将当前最大的变量与当前梗的名字长度进行比较(这里两个数值类型需要相同)，然后找出这些值中最大的那个。这样<code>accumulate</code>函数将会返回当前梗中，名称最长的梗：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">max_func</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t old_max<span class="token punctuation">,</span>
    				 <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">max</span><span class="token punctuation">(</span>old_max<span class="token punctuation">,</span> b<span class="token punctuation">.</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    size_t width <span class="token punctuation">{</span><span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span>
    					    <span class="token number">0u</span><span class="token punctuation">,</span> max_func<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，对<code>map</code>进行遍历，然后打印其中每一个元素。使用<code>&lt;&lt; left &lt;&lt; setw(width)</code>打印出漂亮的“表格”：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>meme_name<span class="token punctuation">,</span> meme_desc<span class="token punctuation">]</span> <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>desc<span class="token punctuation">,</span> year<span class="token punctuation">]</span> <span class="token operator">=</span> meme_desc<span class="token punctuation">;</span>
        
        cout <span class="token operator">&lt;&lt;</span> left <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span>width<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> meme_name
             <span class="token operator">&lt;&lt;</span> <span class="token string">" : "</span> <span class="token operator">&lt;&lt;</span> desc
             <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> year <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在需要一些梗的数据，我们写了一些梗在文件中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token string">"Doge"</span> <span class="token string">"Very Shiba Inu. so dog. much funny. wow."</span> <span class="token number">2013</span>
<span class="token string">"Pepe"</span> <span class="token string">"Anthropomorphic frog"</span> <span class="token number">2016</span>
<span class="token string">"Gabe"</span> <span class="token string">"Musical dog on maximum borkdrive"</span> <span class="token number">2016</span>
<span class="token string">"Honey Badger"</span> <span class="token string">"Crazy nastyass honey badger"</span> <span class="token number">2011</span>
<span class="token string">"Dramatic Chipmunk"</span> <span class="token string">"Chipmunk with a very dramatic look"</span> <span class="token number">2007</span>
</pre></li>
<li>
<p>编译并运行程序，将文件作为数据库进行输入：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ cat memes<span class="token punctuation">.</span>txt <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>filling_containers
Doge<span class="token operator">:</span> Very Shiba Inu<span class="token punctuation">.</span> so dog<span class="token punctuation">.</span> much funny<span class="token punctuation">.</span> wow<span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">2013</span>
Dramatic Chipmunk <span class="token operator">:</span> Chipmunk with a very dramatic look<span class="token punctuation">,</span> <span class="token number">2007</span>
Gabe<span class="token operator">:</span> Musical dog on maximum borkdrive<span class="token punctuation">,</span> <span class="token number">2016</span>
Honey Badger<span class="token operator">:</span> Crazy nastyass honey badger<span class="token punctuation">,</span> <span class="token number">2011</span>
Pepe<span class="token operator">:</span> Anthropomorphic frog<span class="token punctuation">,</span> <span class="token number">2016</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节有三点需要注意。第一，没有选择<code>vector</code>或<code>list</code>比较简单的结构，而是选择了<code>map</code>这样比较复杂的结构。第二，使用了<code>quoted</code>控制符对输入流进行处理。第三，使用<code>accumulate</code>来找到最长的键值。</p>
<p>我们先来看一下<code>map</code>，结构体<code>meme</code>只包含一个<code>description</code>和<code>year</code>。因为我们将梗的名字作为键，所以没有将其放入结构体中。可以将<code>std::pair</code>实例插入<code>map</code>中，首先实现了结构体<code>meme</code>的流操作符<code>operator&gt;&gt;</code>，然后对<code>pair&lt;string, meme&gt;</code>做同样的事。最后，使用<code>istream_iterator&lt;pair&lt;string, meme&gt;&gt;{cin}</code>从标准输入中获取每个元素的值，然后使用<code>inserter(m, end(m))</code>将组对插入<code>map</code>中。</p>
<p>当我们使用流对<code>meme</code>元素进行赋值时，允许梗的名称和描述中带有空格。我们使用引号控制符，很轻易的将问题解决，得到的信息类似于这样，<code>"Name with spaces" "Description with spaces" 123</code>。</p>
<p>当输入和输出都对带有引号的字符串进行处理时，<code>std::quoted</code>就能帮助到我们。当有一个字符串<code>s</code>，使用<code>cout &lt;&lt; quoted(s)</code>对其进行打印，将会使其带引号。当对流中的信息进行解析时，<code>cin &gt;&gt; quoted(s)</code>其就能帮助我们将引号去掉，保留引号中的内容。</p>
<p>叠加操作是对<code>max_func</code>的调用看起来很奇怪：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">max_func</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t old_max<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token function">max</span><span class="token punctuation">(</span>old_max<span class="token punctuation">,</span> b<span class="token punctuation">.</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

size_t width <span class="token punctuation">{</span><span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0u</span><span class="token punctuation">,</span> max_func<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>实际上，<code>max_func</code>能够接受一个<code>size_t</code>和一个<code>auto</code>类型的参数，这两个参数将转换成一个<code>pair</code>，从而就能插入<code>map</code>中。这看起来很奇怪，因为二元函数会将两个相同类型的变量放在一起操作，例如<code>std::plus</code>。我们会从每个组对中获取键值的长度，将当前元素的长度值与之前的最长长度相对比。</p>
<p>叠加调用会将<code>max_func</code>的返回值与0u值进行相加，然后作为左边参数的值与下一个元素进行比较。第一次左边的参数为0u，所以就可以写成<code>max(0u, string_length)</code>，这时返回的值就作为之前最大值，与下一个元素的名称长度进行比较，以此类推。</p>
</div></div><div id="ebook-heading-x8fedx4ee3x5668x8fdbx884cx6253x5370x2014x2014stdostream" ebook-toc-level-2="" heading="迭代器进行打印——std::ostream"><div><h1 class="mume-header" id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8D%B0stdostream">迭代器进行打印——std::ostream</h1>

<p>使用输出流进行打印是一件很容易的事情，STL中的大多数基本类型都对<code>operator&lt;&lt;</code>操作符进行过重载。所以使用<code>std::ostream_iterator</code>类，就可以将数据类型中所具有的的元素进行打印，我们已经在之前的章节中这样做了。</p>
<p>本节中，我们将关注如何将自定义的类型进行打印，并且可以通过模板类进行控制。对于调用者来说，无需写太多的代码。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将对一个新的自定义的类使用<code>std::ostream_iterator</code>，并且看起来其具有隐式转换的能力，这就能帮助我们进行打印：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token double-colon punctuation">::</span>string_literals<span class="token punctuation">;</span>
</pre></li>
<li>
<p>让我们实现一个转换函数，其会将数字和字符串相对应。比如输入1，就会返回“one”；输入2，就会返回“two”，以此类推：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">string <span class="token function">word_num</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</pre></li>
<li>
<p>将会对哈希表进行填充，我们后续可以对它进行访问：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	unordered_map<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span> m <span class="token punctuation">{</span>
        <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"five"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">//...</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在可以使用哈希表的<code>find</code>成员函数，通过传入相应的键值，返回对应的值。如果<code>find</code>函数找不到任何东西，我们就会得到一个"unknown"字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">match</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>match <span class="token operator">==</span> <span class="token function">end</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token string">"unknown"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> match<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>接下来我们就要定义一个结构体<code>bork</code>。其仅包含一个整型成员，其可以使用一个整型变量进行隐式构造。其具有<code>print</code>函数，其能接受一个输出流引用，通过<code>borks</code>结构体的整型成员变量，重复打印"bork"字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">bork</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> borks<span class="token punctuation">;</span>
    
    <span class="token function">bork</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> borks<span class="token punctuation">{</span>i<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
        <span class="token function">fill_n</span><span class="token punctuation">(</span>ostream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>os<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        	   borks<span class="token punctuation">,</span> <span class="token string">"bork!"</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了能够更方便的对<code>bork</code>进行打印，对<code>operator&lt;&lt;</code>进行了重载，当通过输出流对<code>bork</code>进行输出时，其会自动的调用<code>bork::print</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">ostream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> bork <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> os<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在来实现主函数，先来初始化一个<code>vector</code>:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-const">const</span> vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>ostream_iterator</code>需要一个模板参数，其能够表述哪种类型的变量我们能够进行打印。当使用<code>ostream_iterator&lt;T&gt;</code>时，其会使用<code>ostream&amp; operator(ostream&amp;, const T&amp;)</code>进行打印。这也就是之前在<code>bork</code>类型中重载的输出流操作符。我们这次只对整型数字进行打印，所以使用<code>ostream_iterator&lt;int&gt;</code>。使用<code>cout</code>进行打印，并可以将其作为构造参数。我们使用循环对<code>vector</code>进行访问，并且对每个输出迭代器<code>i</code>进行解引用。这也就是在STL算法中流迭代器的用法：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> oit <span class="token punctuation">{</span>cout<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">*</span>oit <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>使用的输出迭代器还不错，不过其打印没有任何分隔符。当需要空格分隔符对所有打印的元素进行分隔时，我们可以将空格作为第二个参数传入输出流构造函数中。这样，其就能打印"1, 2, 3, 4, 5, "，而非"12345"。不过，不能在打印最后一个数字的时候将“逗号-空格”的字符串丢弃，因为迭代器并不知道哪个数字是最后一个：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> oit_comma <span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
	<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">*</span>oit_comma <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了将其进行打印，我们将值赋予一个输出流迭代器。这个方法可以和算法进行结合，其中最简单的方式就是<code>std::copy</code>。我们可以通过提供<code>begin</code>和<code>end</code>迭代器来代表输入的范围，在提供输出流迭代器作为输出迭代器。其将打印<code>vector</code>中的所有值。这里我们会将两个输出循环进行比较：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> oit<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

	<span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> oit_comma<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><ol start="11">
<li>
<p>还记得<code>word_num</code>函数吗？其会将数字和字符串进行对应。我们也可以使用进行打印。我们只需要使用一个输出流操作符，因为我们不需要对整型变量进行打印，所以这里使用的是<code>string</code>的特化版本。使用<code>std::transfrom</code>替代<code>std::copy</code>，因为需要使用转换函数将输入范围内的值转换成其他值，然后拷贝到输出中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">transform</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>
    		 ostream_iterator<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">}</span><span class="token punctuation">,</span> word_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>程序的最后一行会对<code>bork</code>结构体进行打印。可以直接使用，也并不需要为<code>std::transform</code>函数提供任何转换函数。另外，可以创建一个输出流迭代器，其会使用<code>bork</code>进行特化，然后再调用<code>std::copy</code>。<code>bork</code>实例可以通过输入范围内的整型数字进行隐式创建。然后，将会得到一些有趣的输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>
    	 ostream_iterator<span class="token operator">&lt;</span>bork<span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就会得到以下输出。前两行和第三四行的结果非常类似。然后，会得到数字对应的字符串，然后就会得到一堆<code>bork!</code>字符串。其会打印很多行，因为我们使用换行符替换了空格：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>ostream_printing
<span class="token number">12345</span>
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span>
<span class="token number">12345</span>
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span>
one two three four five
bork<span class="token operator">!</span>
bork<span class="token operator">!</span> bork<span class="token operator">!</span>
bork<span class="token operator">!</span> bork<span class="token operator">!</span> bork<span class="token operator">!</span>
bork<span class="token operator">!</span> bork<span class="token operator">!</span> bork<span class="token operator">!</span> bork<span class="token operator">!</span>
bork<span class="token operator">!</span> bork<span class="token operator">!</span> bork<span class="token operator">!</span> bork<span class="token operator">!</span> bork<span class="token operator">!</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>作为一个语法黑客，我们应知道<code>std::ostream_iterator</code>可以用来对数据进行打印，其在语法上为一个迭代器，对这个迭代器进行累加是无效的。对其进行解引用会返回一个代理对象，这些赋值操作符会将这些数字转发到输出流中。</p>
<p>输出流迭代器会对类型T进行特化(<code>ostream_iterator&lt;T&gt;</code>)，对于所有类型的<code>ostream&amp; operator&lt;&lt;(ostream&amp;, const T&amp;)</code>来说，都需要对其进行实现。</p>
<p><code>ostream_iterator</code>总是会调用<code>operator&lt;&lt;</code>，通过模板参数，我们已经对相应类型进行了特化。如果类型允许，这其中会发生隐式转换。当A可以隐式转换为B时，我们可以对A类型的元素进行迭代，然后将这些元素拷贝到<code>output_iterator&lt;B&gt;</code>的实例中。我们会对<code>bork</code>结构体做同样的事情：<code>bork</code>实例也可以隐式转换为一个整数，这也就是我们能够很容易的在终端输出一堆<code>bork!</code>的原因。</p>
<p>如果不能进行隐式转换，可使用<code>std::treansform</code>和<code>word_num</code>函数相结合，对元素类型进行转换。</p>
<blockquote>
<p>Note：</p>
<p>通常，对于自定义类型来说，隐式转换是一种不好的习惯，因为这是一个常见的Bug源，并且这种Bug非常难找。例子中，隐式构造函数有用程度要超过其危险程度，因为相应的类只是进行打印。</p>
</blockquote>
</div></div><div id="ebook-heading-x4f7fx7528x7279x5b9ax4ee3x7801x6bb5x5c06x8f93x51fax91cdx5b9ax5411x5230x6587x4ef6" ebook-toc-level-2="" heading="使用特定代码段将输出重定向到文件"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%B0%86%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E6%96%87%E4%BB%B6">使用特定代码段将输出重定向到文件</h1>

<p><code>std::cout</code>为我们提供了一种非常方便的打印方式，使用起来也十分方便，易于扩展，并可全局访问。即使我们想打印对应的信息时，比如错误信息，我们可以使用错误输出<code>std::cerr</code>进行输出，其和<code>cout</code>的用法一样，只不过一个从标准通道进行输出，另一个从错误通道进行输出。</p>
<p>当我们要打印比较复杂的日志信息时。比如，要将函数的输出重定向到一个文件中，或者将函数的打印输出处于静默状态，而不需要对函数进行任何修改。或许这个函数为一个库函数，我们没有办法看到其源码。可能，这个函数并没有设计为写入到文件的函数，但是我们还是想将其输出输入到文件中。</p>
<p>这里可以重定向输出流对象的输出。本节中，我们将看到如何使用一种简单并且优雅地方式来完成输出流的重定向。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将实现一个辅助类，其能在构造和析构阶段，帮助我们完成流的重定向，以及对流的定向进行恢复。然后，我们来看其是怎么使用的：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们实现了一个类，其具有一个文件输出流对象和一个指向流内部缓冲区的指针。<code>cout</code>作为流对象，其内部具有一个缓冲区，其可以用来进行数据交换，我们可以保存我们之前做过的事情，这样就很方便进行对后续修改的撤销。我们可以在C++手册中查询对其返回类型的解释，也可以使用<code>decltype</code>对<code>cout.rdbuf()</code>所返回的类型进行查询。这并不是一个很好的体验，在我们的例子中，其就是一个指针类型：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">redirect_cout_region</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-using">using</span> buftype <span class="token operator">=</span> <span class="token keyword keyword-decltype">decltype</span><span class="token punctuation">(</span>cout<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    ofstream ofs<span class="token punctuation">;</span>
    buftype buf_backup<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>类的构造函数接受一个文件名字符串作为输入参数。这个字符串用来初始化文件流成员<code>ofs</code>。对其进行初始化后，可以将其输入到<code>cout</code>作为一个新的流缓冲区。<code>rdbuf</code>在接受一个新缓冲区的同时，会将旧缓冲区以指针的方式进行返回，这样当需要对缓冲区进行恢复时，就可以直接使用了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-explicit">explicit</span>
    <span class="token function">redirect_cout_region</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>filename<span class="token punctuation">)</span>
    <span class="token operator">:</span> ofs<span class="token punctuation">{</span>filename<span class="token punctuation">}</span>
	<span class="token punctuation">,</span> buf_backup<span class="token punctuation">{</span>cout<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span>ofs<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre></li>
<li>
<p>默认构造函数和其他构造函数做的事情几乎一样。其区别在于，默认构造函数不会打开任何文件。默认构造的文件流会直接替换<code>cout</code>的流缓冲，这样会导致<code>cout</code>的一些功能失效。其会丢弃一些要打印的东西。这在某些情况下是非常有用的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token function">redirect_cout_region</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> ofs<span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">,</span>buf_backup<span class="token punctuation">{</span>cout<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span>ofs<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
</pre></li>
<li>
<p>析构函数会对重定向进行恢复。当类在运行过程中超出了范围，可以使用原始的<code>cout</code>流缓冲区对其进行还原：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token operator">~</span><span class="token function">redirect_cout_region</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span>buf_backup<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>让我们模拟一个有很多输出的函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">my_output_heavy_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"some output\n"</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"this function does really heavy work\n"</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"... and lots of it...\n"</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们先会进行一次标准打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Readable from normal stdout\n"</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在进行重定向，首先使用一个文本文件名对类进行实例化。文件流会使用读取和写入模式作为默认模式，所以其会创建一个文件。所以即便是后续使用<code>cout</code>进行打印，其输出将会重定向到这个文件中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token punctuation">{</span>
        redirect_cout_region _ <span class="token punctuation">{</span><span class="token string">"output.txt"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Only visible in output.txt\n"</span><span class="token punctuation">;</span>
        <span class="token function">my_output_heavy_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</pre></li>
<li>
<p>离开这段代码后，文件将会关闭，打印输出也会重归标准输出。我们再开启一个代码段，并使用默认构造函数对类进行构造。这样后续的打印信息将无法看到，都会被丢弃：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">{</span>
        redirect_cout_region _<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"This output will "</span>
                <span class="token string">"completely vanish\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>离开这段代码后，我们的标准输出将再度恢复，并且将程序的最后一行打印出来：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Readable from normal stdout again\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><ol start="11">
<li>
<p>编译并运行这个程序，其输出和我们期望的一致。我们只看到了第一行和最后一行输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>log_regions
Readable from normal <span class="token constant">stdout</span>
Readable from normal <span class="token constant">stdout</span> again
</pre></li>
<li>
<p>我们可以将新文件output.txt打开，其内容如下：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ cat output<span class="token punctuation">.</span>txt
Only visible in output<span class="token punctuation">.</span>txt
some output
<span class="token keyword keyword-this">this</span> function does really heavy work
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">and</span> lots of it<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>每个流对象都有一个内部缓冲区，这样的缓冲区可以进行交换。当我们有一个流对象<code>s</code>时，我们将其缓冲区存入到变量<code>a</code>中，并且为流对象换上了一个新的缓冲区<code>b</code>，这段代码就可以完成上述的过程:<code>a = s.rdbuf(b)</code>。需要恢复的时候只需要执行<code>s.rdbuf(a)</code>。</p>
<p>这就如同我们在本节所做的。另一件很酷的事情是，可以将这些<code>redirect_cout_region</code>辅助函数放入堆栈中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"print to standard output\n"</span><span class="token punctuation">;</span>
    
    redirect_cout_region la <span class="token punctuation">{</span><span class="token string">"a.txt"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"print to a.txt\n"</span><span class="token punctuation">;</span>
    
    redirect_cout_region lb <span class="token punctuation">{</span><span class="token string">"b.txt"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"print to b.txt\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"print to standard output again\n"</span><span class="token punctuation">;</span>
</pre><p>这也应该好理解，通常析构的顺序和构造的顺序是相反的。这种模式是将对象的构造和析构进行紧耦合，其也称作为<strong>资源获得即初始化(RAII)</strong>。</p>
<p>这里有一个很重要的点需要注意——<code>redirect_cout_region</code>类中成员变量的初始化顺序：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">redirect_cout_region</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-using">using</span> buftype <span class="token operator">=</span> <span class="token keyword keyword-decltype">decltype</span><span class="token punctuation">(</span>cout<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ofstream ofs<span class="token punctuation">;</span>
    buftype buf_backup<span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-explicit">explicit</span>
    <span class="token function">redirect_cout_region</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>filename<span class="token punctuation">)</span>
    <span class="token operator">:</span> ofs<span class="token punctuation">{</span>filename<span class="token punctuation">}</span><span class="token punctuation">,</span>
    buf_backup<span class="token punctuation">{</span>cout<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span>ofs<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</pre><p>我们可以看到，成员<code>buf_backup</code>的初始化需要依赖成员<code>ofs</code>进行。有趣的是，这些成员初始化的顺序，不会按照初始化列表中给定元素的顺序进行初始化。这里初始化的顺序值与成员变量声明的顺序有关！</p>
<blockquote>
<p>Note：</p>
<p>当一成员变量需要在另一个成员变量之后进行初始化，其需要在类声明的时候以相应的顺序进行声明。初始化列表中的顺序，对于构造函数来说没有任何影响。</p>
</blockquote>
</div></div><div id="ebook-heading-x901ax8fc7x96c6x6210stdchar_traitsx521bx5efax81eax5b9ax4e49x5b57x7b26x4e32x7c7b" ebook-toc-level-2="" heading="通过集成std::char_traits创建自定义字符串类"><div><h1 class="mume-header" id="%E9%80%9A%E8%BF%87%E9%9B%86%E6%88%90stdchar_traits%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB">通过集成std::char_traits创建自定义字符串类</h1>

<p>我们知道<code>std::string</code>非常好用。不过，对于一些朋友来说他们需要对自己定义的字符串类型进行处理。</p>
<p>使用它们自己的字符串类型显然不是一个好主意，因为对于字符串的安全处理是很困难的。幸运的是，<code>std::string</code>是<code>std::basic_string</code>类型的一个特化版本。这个类中包含了所有复杂的内存处理，不过其对字符串的拷贝和比较没有添加任何条件。所以我们可以基于<code>basic_string</code>，将其所需要包含的自定义类作为一个模板参数传入。</p>
<p>本节中，我们将来看下如何传入自定义类型。然后，在不实现任何东西的情况下，如何对自定义字符串进行创建。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将实现两个自定义字符串类：<code>lc_string</code>和<code>ci_string</code>。第一个类将通过输入创建一个全是小写字母的字符串。另一个字符串类型不会对输入进行任何变化，不过其会对字符串进行大小写不敏感的比较：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后要对<code>std::tolower</code>函数进行实现，其已经定义在头文件<code>&lt;cctype&gt;</code>中。其函数也是现成的，不过其不是<code>constexpr</code>类型。C++17中一些<code>string</code>函数可以声明成<code>constexpr</code>类型，但是还要使用自定义的类型。所以对于输入字符串，只将大写字母转换为小写，而其他字符则不进行修改：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-constexpr">constexpr</span> <span class="token keyword keyword-char">char</span> <span class="token function">tolow</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-switch">switch</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-case">case</span> <span class="token string">'A'</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.'</span>Z<span class="token string">': return c - '</span>A<span class="token string">' + '</span>a<span class="token number">'</span><span class="token punctuation">;</span> <span class="token comment">// 读者自行将case展开</span>
    <span class="token keyword keyword-default">default</span><span class="token operator">:</span> 	    <span class="token keyword keyword-return">return</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p><code>std::basic_string</code>类可以接受三个模板参数：字符类型、字符特化类和分配器类型。本节中我们只会修改字符特化类，因为其定义了字符串的行为。为了重新实现与普通字符串不同的部分，我们会以<code>public</code>方式继承标准字符特化类：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">lc_traits</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword keyword-public">public</span> <span class="token class-name">char_traits</span><span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
</pre><ol start="4">
<li>
<p>我们类能接受输入字符串，并将其转化成小写字母。这里有一个函数，其是字符级别的，所以我们可以对其使用<code>tolow</code>函数。我们的这个函数为<code>constexpr</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-constexpr">constexpr</span>
	<span class="token keyword keyword-void">void</span> <span class="token function">assign</span><span class="token punctuation">(</span>char_type<span class="token operator">&amp;</span> r<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> char_type<span class="token operator">&amp;</span> a <span class="token punctuation">)</span> <span class="token punctuation">{</span>
		r <span class="token operator">=</span> <span class="token function">tolow</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</pre></li>
<li>
<p>另一个函数将整个字符串拷贝到我们的缓冲区内。使用<code>std::transform</code>将所有字符从源字符串中拷贝到内部的目标字符串中，同时将每个字符与其小写版本进行映射：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-static">static</span> char_type<span class="token operator">*</span> <span class="token function">copy</span><span class="token punctuation">(</span>char_type<span class="token operator">*</span> dest<span class="token punctuation">,</span>
   						 <span class="token keyword keyword-const">const</span> char_type<span class="token operator">*</span> src<span class="token punctuation">,</span>
    					 size_t count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token function">transform</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> src <span class="token operator">+</span> count<span class="token punctuation">,</span> dest<span class="token punctuation">,</span> tolow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword keyword-return">return</span> dest<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>上面的特化类可以帮助我们创建一个字符串类，其能有效的将字符串转换成小写。接下来我们在实现一个类，其不会对原始字符串进行修改，但是其能对字符串做大小写敏感的比较。其继承于标准字符串特征类，这次将对一些函数进行重新实现：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">ci_traits</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword keyword-public">public</span> <span class="token class-name">char_traits</span><span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
</pre></li>
<li>
<p><code>eq</code>函数会告诉我们两个字符是否相等。我们也会实现一个这样的函数，但是我们只实现小写字母的版本。这样'A'与'a'就是相等的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-constexpr">constexpr</span> <span class="token keyword keyword-bool">bool</span> <span class="token function">eq</span><span class="token punctuation">(</span>char_type a<span class="token punctuation">,</span> char_type b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">tolow</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">tolow</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p><code>lt</code>函数会告诉我们两个字符在字母表中的大小情况。这里使用了逻辑操作符，并继续对两个字符使用转换成小写的函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-constexpr">constexpr</span> <span class="token keyword keyword-bool">bool</span> <span class="token function">lt</span><span class="token punctuation">(</span>char_type a<span class="token punctuation">,</span> char_type b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">tolow</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token function">tolow</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>	
</pre></li>
<li>
<p>最后两个函数都是字符级别的函数，接下来两个函数都为字符串级别的函数。<code>compare</code>函数与<code>strncmp</code>函数差不多。当两个字符串的长度<code>count</code>相等，那么就返回0。如果不相等，会返回一个负数或一个正数，返回值就代表了其中哪一个在字母表中更小。并计算两个字符串中所有字符之间的距离，当然这些都是在小写情况下进行的操作。C++14后，这个函数可以声明成<code>constexpr</code>类型：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"> 	<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-constexpr">constexpr</span> <span class="token keyword keyword-int">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> char_type<span class="token operator">*</span> s1<span class="token punctuation">,</span>
    						   <span class="token keyword keyword-const">const</span> char_type<span class="token operator">*</span> s2<span class="token punctuation">,</span>
    						   size_t count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> count<span class="token punctuation">;</span> <span class="token operator">++</span>s1<span class="token punctuation">,</span> <span class="token operator">++</span>s2<span class="token punctuation">,</span> <span class="token operator">--</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-const">const</span> char_type <span class="token function">diff</span> <span class="token punctuation">(</span><span class="token function">tolow</span><span class="token punctuation">(</span><span class="token operator">*</span>s1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">tolow</span><span class="token punctuation">(</span><span class="token operator">*</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>diff <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
            <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>diff <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    	<span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们所需要实现的最后一个函数就是大小写不敏感的<code>find</code>函数。对于给定输入字符串<code>p</code>，其长度为<code>count</code>，我们会对某个字符<code>ch</code>的位置进行查找。然后，其会返回一个指向第一个匹配字符位置的指针，如果没有找到则返回<code>nullptr</code>。这个函数比较过程中我们需要使用<code>tolow</code>函数将字符串转换成小写，以匹配大小写不敏感的查找。不幸的是，我们不能使用<code>std::find_if</code>来做这件事，因为其是非<code>constexpr</code>函数，所以我们需要自己去写一个循环：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-constexpr">constexpr</span>
    <span class="token keyword keyword-const">const</span> char_type<span class="token operator">*</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> char_type<span class="token operator">*</span> p<span class="token punctuation">,</span>
                          size_t count<span class="token punctuation">,</span>
                          <span class="token keyword keyword-const">const</span> char_type<span class="token operator">&amp;</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> char_type find_c <span class="token punctuation">{</span><span class="token function">tolow</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> count <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>count<span class="token punctuation">,</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>find_c <span class="token operator">==</span> <span class="token function">tolow</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    	<span class="token keyword keyword-return">return</span> <span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>OK，所有自定义类都完成了。这里我们可以定义两种新字符串类的类型。<code>lc_string</code>代表小写字符串，<code>ci_string</code>代表大小写不敏感字符串。这两种类型与<code>std::string</code>都有所不同：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> lc_string <span class="token operator">=</span> basic_string<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token punctuation">,</span> lc_traits<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> ci_string <span class="token operator">=</span> basic_string<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token punctuation">,</span> ci_traits<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了能让输出流接受新类，我们需要对输出流操作符进行重载：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">ostream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> lc_string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

ostream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> ci_string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在我们来对主函数进行编写。先让我们创建一个普通字符串、小写字符串和大小写不敏感字符串的实例，然后直接将其进行打印。其在终端上看起来都很正常，不过小写字符串将所有字符转换成了小写：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">" string: "</span>
        <span class="token operator">&lt;&lt;</span> string<span class="token punctuation">{</span><span class="token string">"Foo Bar Baz"</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">"lc_string: "</span>
        <span class="token operator">&lt;&lt;</span> lc_string<span class="token punctuation">{</span><span class="token string">"Foo Bar Baz"</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">"ci_string: "</span>
        <span class="token operator">&lt;&lt;</span> ci_string<span class="token punctuation">{</span><span class="token string">"Foo Bar Baz"</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了测试大小写不敏感字符串，可以实例化两个字符串，这两个字符串只有在大小写方面有所不同。当我们将这两个字符串进行比较时，其应该是相等的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	ci_string user_input <span class="token punctuation">{</span><span class="token string">"MaGiC PaSsWoRd!"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	ci_string password <span class="token punctuation">{</span><span class="token string">"magic password!"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>之后，对其进行比较，然后将匹配的结果进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>user_input <span class="token operator">==</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Passwords match: \""</span> <span class="token operator">&lt;&lt;</span> user_input
        	 <span class="token operator">&lt;&lt;</span> <span class="token string">"\" == \""</span> <span class="token operator">&lt;&lt;</span> password <span class="token operator">&lt;&lt;</span> <span class="token string">"\"\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，其输出和我们期望的相符。开始的三行并未对输入进行修改，除了<code>lc_string</code>将所有字符转换成了小写。最后的比较，在大小写不敏感的前提下，也是相等的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>custom_string
string<span class="token operator">:</span> Foo Bar Baz
lc_string<span class="token operator">:</span> foo bar baz
ci_string<span class="token operator">:</span> Foo Bar Baz
Passwords match<span class="token operator">:</span> <span class="token string">"MaGiC PaSsWoRd!"</span> <span class="token operator">==</span> <span class="token string">"magic password!"</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>我们完成的所有子类和函数实现，在新手看来十分的不可思议。这些函数签名都来自于哪里？为什么我们为了函数签名，就要对相关功能性的函数进行重新实现呢？</p>
<p>首先，来看一下<code>std::string</code>的类声明：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span>
    <span class="token keyword keyword-class">class</span> <span class="token class-name">CharT</span><span class="token punctuation">,</span>
    <span class="token keyword keyword-class">class</span> <span class="token class-name">Traits</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>char_traits<span class="token operator">&lt;</span>CharT<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token keyword keyword-class">class</span> <span class="token class-name">Allocator</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>CharT<span class="token operator">&gt;</span>
    <span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">basic_string</span><span class="token punctuation">;</span>
</pre><p>可以看出<code>std::string</code>其实就是一个<code>std::basic_string&lt;char&gt;</code> 类，并且其可以扩展为<code>std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;</code>。OK，这是一个非常长的类型描述，不过其意义何在呢？这就表示字符串可以不限于有符号类型<code>char</code>，也可以是其他类型。其对于字符串类型都是有效的，这样就不限于处理ASCII字符集。当然，这不是我们的关注点。</p>
<p><code>char_traits&lt;char&gt;</code>类包含<code>basic_string</code>所需要的算法。<code>char_traits&lt;char&gt;</code>可以进行字符串间的比较、查找和拷贝。</p>
<p><code>allocator&lt;char&gt;</code>类也是一个特化类，不过其运行时给字符串进行空间的分配和回收。这对于现在的我们来说并不重要，我们只使用其默认的方式就好。</p>
<p>当我们想要一个不同的字符串类型是，可以尝试对<code>basic_string</code>和<code>char_traits</code>类中提供的方法进行复用。我们实现了两个<code>char_traits</code>子类：<code>case_insentitive</code>和<code>lower_caser</code>类。我们可以将这两个字符串类替换标准<code>char_traits</code>类型。</p>
<blockquote>
<p>Note：</p>
<p>为了探寻<code>basic_string</code>适配的可能性，我们需要查询C++ STL文档中关于<code>std::char_traits</code>的章节，然后去了解还有那些函数需要重新实现。</p>
</blockquote>
</div></div><div id="ebook-heading-x4f7fx7528x6b63x5219x8868x8fbex5f0fx5e93x6807x8bb0x8f93x5165" ebook-toc-level-2="" heading="使用正则表达式库标记输入"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%93%E6%A0%87%E8%AE%B0%E8%BE%93%E5%85%A5">使用正则表达式库标记输入</h1>

<p>当我们需要使用一些较为复杂的方式解析或转换字符串时，正则表达式是个不错的选择。因为非常好用，很多编程语言中都会内置正则表达式。</p>
<p>如果你还对正则表达式不太了解，可以去维基百科的相关页面进行了解。我相信其会扩展你的视野，正则表达式对于文本解析来说十分好用。正则表达式能用来检查一个电子邮件或IP地址是否合法，也能从长字符串中找到对应的子字符串等等。</p>
<p>本节中，我们将提取HTML文件中的链接，并且将这些链接为使用者罗列出来。因为正则表达式在C++11标准中正式加入C++ STL，所以例程很短。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将定义一个正则表达式来检测链接，并且将其作用于一个HTML文件，并将获得的链接打印出来：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;regex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>在后面将会生成一段可迭代器的区间，这个区间中只包含字符串。这里会以链接地址字符串和链接描述字符串配对出现。因此，我们也要写一个辅助函数来打印这些字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">InputIt</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span>InputIt it<span class="token punctuation">,</span> InputIt end_it<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</pre></li>
<li>
<p>每次循环中，我们对迭代器增加了两次，这是因为要对链接地址和链接描述进行拷贝。两个迭代器解引用间，我们添加了一个if条件，为了保证程序的安全，这个条件句会检查迭代器是否过早的到达了最后：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">		<span class="token keyword keyword-const">const</span> string link <span class="token punctuation">{</span><span class="token operator">*</span>it<span class="token operator">++</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> end_it<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
		<span class="token keyword keyword-const">const</span> string desc <span class="token punctuation">{</span><span class="token operator">*</span>it<span class="token operator">++</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们就可以对链接和其描述进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        cout <span class="token operator">&lt;&lt;</span> left <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> desc
        	<span class="token operator">&lt;&lt;</span> <span class="token string">" : "</span> <span class="token operator">&lt;&lt;</span> link <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们将从标准输入中获取所要读取的数据。这样，需要将全部标准输入通过一个输入流迭代器构造为一个字符串。为了避免符号化，为了确保我们所得到的输入与用户输入的一样，我们使用了<code>noskipws</code>控制符。这个控制符将会禁用空格跳过和符号化：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cin <span class="token operator">&gt;&gt;</span> noskipws<span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>string in <span class="token punctuation">{</span>
        istream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cin<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们需要定义一个正则表达式，来对HTML文件进行查找。小括号在正在表达式中代表的是组，这里我们要获取我们想要访问的链接——其为URL地址，并且还要获取其描述：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-const">const</span> regex link_re <span class="token punctuation">{</span>
		<span class="token string">"&lt;a href=\"([^\"]*)\"[^&lt;]*&gt;([^&lt;]*)&lt;/a&gt;"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>sregex_token_iterator</code>类具有相同的功能，并且能对<code>istream_iterator</code>直接操作。我们将可迭代的输入范围和刚刚定义的正则表达式传给它。不过，这里还有第三个参数<code>{1, 2}</code>。其表示我们想要表达式组1和组2中的结果：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	sregex_token_iterator it <span class="token punctuation">{</span>
		<span class="token function">begin</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">,</span> link_re<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><ol start="8">
<li>
<p>现在我们有一个迭代器，如果找到了连接，其会返回连接地址和相应的描述。这里对第二个参数直接进行初始化，其类型与第一个参数类型相同，然后传入我们之前实现的<code>print</code>函数中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运次那个程序，就会得到如下的输出。我们使用curl获取ISO C++首页的信息，其会将HTML页面直接从网上下载下来。当然，这里也能写成<code>cat some_html_file.html | ./link_extraction</code>。正则表达式可以很方便对硬编码进行解析，通过HTML固定的格式对其进行解析。当然，你可以让其变得更加通用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ curl <span class="token operator">-</span>s <span class="token string">"https://isocpp.org/blog"</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>link_extraction
Sign In <span class="token operator">/</span> Suggest an Article <span class="token operator">:</span> https<span class="token operator">:</span><span class="token comment">//isocpp.org/member/login</span>
Register <span class="token operator">:</span> https<span class="token operator">:</span><span class="token comment">//isocpp.org/member/register</span>
Get Started<span class="token operator">!</span> <span class="token operator">:</span> https<span class="token operator">:</span><span class="token comment">//isocpp.org/get-started</span>
Tour <span class="token operator">:</span> https<span class="token operator">:</span><span class="token comment">//isocpp.org/tour</span>
C<span class="token operator">++</span> Super<span class="token operator">-</span>FAQ<span class="token operator">:</span> https<span class="token operator">:</span><span class="token comment">//isocpp.org/faq</span>
Blog <span class="token operator">:</span> https<span class="token operator">:</span><span class="token comment">//isocpp.org/blog</span>
Forums <span class="token operator">:</span> https<span class="token operator">:</span><span class="token comment">//isocpp.org/forums</span>
Standardization<span class="token operator">:</span> https<span class="token operator">:</span><span class="token comment">//isocpp.org/std</span>
About<span class="token operator">:</span> https<span class="token operator">:</span><span class="token comment">//isocpp.org/about</span>
Current ISO C<span class="token operator">++</span> status <span class="token operator">:</span> https<span class="token operator">:</span><span class="token comment">//isocpp.org/std/status</span>
<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">and</span> many more<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>正则表达式非常有用，看起来好像特别神秘，但值得学习。一个短小的表达式就能节省对我们多行的代码进行手动匹配的时间。</p>
<p>本节中，我们第一次实例化了一个正则类型的对象。我们使用一个用于描述的字符串对正则表达式进行构造。最简单的正则表达式是"."，其会对每个字符进行匹配，因为它是正则表达式的通配符。表达式为"a"时，其就只会对'a'字符进行匹配。表达式为"ab*"时，其表示"只有一个a，和零个或若干个b"，以此类推。正则表达式本身是一个很大的主题，维基百科和一些教学网站，还有一些学术论文中，对其都有非常详尽的描述。</p>
<p>让我们来看一下本节中的正则表达式，是如何对HTML连接进行匹配的。一个简单HTML连接可写为<code>&lt;a href="some_url.com/foo"&gt;A great link&lt;/a&gt;</code>。我们只需要<code>some_url.com/foo</code>和<code>A great link</code>部分。所以，我们可以使用如下的正则表达式进行匹配，其会将字符串对应每个组，从而分解成多个字符串：</p>
<p><img src="./C++17 STL Cook book_files/7-12-1.png" alt=""></p>
<p>字符串本身为<strong>第0组</strong>，也就是整个字符串。引号中<code>href</code>的URL地址部分分在<strong>第1组</strong>中。正则表达式中，使用小括号来定义组，所以这个表达式中有两个组。另一个组则获取的是连接描述。</p>
<p>有很多STL函数可以接受正则对象，不过直接使用一个正则字符迭代器适配器，其是对使用<code>std::regex_search</code>进行自动化匹配的高阶抽象。我们可用如下的代码对其进行实例化：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">sregex_token_iterator it <span class="token punctuation">{</span><span class="token function">begin</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">,</span> link_re<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>开始和结束部分表示我们的输入字符串，正则迭代器则在该字符串上进行迭代，并匹配所有链接。<code>link_re</code>则为用于匹配连接的正则表达式，<code>{1, 2}</code>可用来表示我们需要的部分。其第一组匹配的是我们想要的连接，进行自增后，就到了第二组，匹配的则是我们想要的连接描述，依次循环。其能非常智能的帮助我们对多行数据进行处理。</p>
<p>让我们来看另一个例子，以确保我们明白了上面的内容。让我们创建一个正则表达式<code>"a(b*)(c*)"</code>。其会对具有一个'a'字符，之后有或没有'b'字符，再之后有或没有'c'字符的字符串进行匹配：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-const">const</span> string s <span class="token punctuation">{</span><span class="token string">" abc abbccc "</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-const">const</span> regex re <span class="token punctuation">{</span><span class="token string">"a(b*)(c*)"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

sregex_token_iterator it <span class="token punctuation">{</span>
    <span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> re<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">print</span><span class="token punctuation">(</span> <span class="token operator">*</span>it <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints b</span>
<span class="token operator">++</span>it<span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span> <span class="token operator">*</span>it <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints c</span>
<span class="token operator">++</span>it<span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span> <span class="token operator">*</span>it <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints bb</span>
<span class="token operator">++</span>it<span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span> <span class="token operator">*</span>it <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints ccc</span>
</pre><p>当然也可以使用<code>std::regex_iterator</code>类，其会将匹配的子字符串进行直接输出。</p>
</div></div><div id="ebook-heading-x7b80x5355x6253x5370x4e0dx540cx683cx5f0fx7684x6570x5b57" ebook-toc-level-2="" heading="简单打印不同格式的数字"><div><h1 class="mume-header" id="%E7%AE%80%E5%8D%95%E6%89%93%E5%8D%B0%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%95%B0%E5%AD%97">简单打印不同格式的数字</h1>

<p>之前的章节中，我们已经了解如何打印出带格式的输出，同时也意识到了两点：</p>
<ul>
<li>输入输出控制符是有粘性的，所以当我们要临时使用的时候，需要在用完之后进行还原。</li>
<li>其控制符和较少的要打印的对象相比，会显得很冗长。</li>
</ul>
<p>这些原因导致一些开发者使用C++的时候，还是依旧使用<code>printf</code>进行打印输出。</p>
<p>本节，我们将来看一下如何不用太多代码就能进行很好的类型打印。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们会先来实现一个类<code>format_guard</code>，其会自动的将打印格式进行恢复。另外，我们添加了一个包装类型，其可以包含任意值，当对其进行打印时，其能使用相应的格式进行输出，而无需添加冗长的控制符：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>辅助类在调用<code>format_guard</code>时，其会对输出流的格式进行清理。其构造函数保存了格式符，也就是在这里对<code>std::cout</code>进行设置。析构函数会将这些状态进行去除，这样就不会后续的打印有所影响：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">format_guard</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-decltype">decltype</span><span class="token punctuation">(</span>cout<span class="token punctuation">.</span><span class="token function">flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> f <span class="token punctuation">{</span>cout<span class="token punctuation">.</span><span class="token function">flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
	<span class="token operator">~</span><span class="token function">format_guard</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout<span class="token punctuation">.</span><span class="token function">flags</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>定义另一个辅助类<code>scientific_type</code>。因为其是一个模板类，所以其能拥有任意类型的成员变量。这个类没有其他任何作用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">scientific_type</span> <span class="token punctuation">{</span>
	T value<span class="token punctuation">;</span>
    
	<span class="token keyword keyword-explicit">explicit</span> <span class="token function">scientific_type</span><span class="token punctuation">(</span>T val<span class="token punctuation">)</span> <span class="token operator">:</span> value<span class="token punctuation">{</span>val<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>封装成<code>scientific_type</code>之后，可以对任意类型进行自定义格式设置，当对<code>operator&gt;&gt;</code>进行重载后，输出流就会在执行时，运行完全不同的代码。这样就能在使用科学计数法表示浮点数时，以大写的格式，并且其为正数时，数字前添加'+'号。我们也会在跳出函数时，使用<code>format_guard</code>类对打印格式进行清理：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
ostream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> scientific_type<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    format_guard _<span class="token punctuation">;</span>
    os <span class="token operator">&lt;&lt;</span> scientific <span class="token operator">&lt;&lt;</span> uppercase <span class="token operator">&lt;&lt;</span> showpos<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> os <span class="token operator">&lt;&lt;</span> w<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们将使用到<code>format_guard</code>类。我们会创建一段新的代码段，首先对类进行实例化，并且对<code>std::cout</code>进行输出控制符的设置：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        format_guard _<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> hex <span class="token operator">&lt;&lt;</span> scientific <span class="token operator">&lt;&lt;</span> showbase <span class="token operator">&lt;&lt;</span> uppercase<span class="token punctuation">;</span>
        
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Numbers with special formatting:\n"</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token number">0x123abc</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token number">0.123456789</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>使用控制符对这些数字进行打印后，跳出这个代码段。这时<code>format_guard</code>的析构函数会将格式进行清理。为了对清理结果进行测试，会再次打印相同的数字。其将会输出不同的结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Same numbers, but normal formatting again:\n"</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token number">0x123abc</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token number">0.123456789</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在使用<code>scientific_type</code>，将三个浮点数打印在同一行。我们将第二个数包装成<code>scientific_type</code>类型。这样其就能按照我们指定的风格进行打印，不过在之前和之后的输出都是以默认的格式进行。与此同时，我们也避免了冗长的格式设置代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Mixed formatting: "</span>
        <span class="token operator">&lt;&lt;</span> <span class="token number">123.0</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span>
        <span class="token operator">&lt;&lt;</span> scientific_type<span class="token punctuation">{</span><span class="token number">123.0</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span>
        <span class="token operator">&lt;&lt;</span> <span class="token number">123.456</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就会得到如下的输出。前两行按照我们的设定进行打印。接下来的两行则是以默认的方式进行打印。这样就证明了我们的<code>format_guard</code>类工作的很好。最后三个数在一行上，也是和我们的期望一致。只有中间的数字是<code>scientific_type</code>类型的，前后两个都是默认类型：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>pretty_print_on_the_fly
Numbers with special formatting<span class="token operator">:</span>
<span class="token number">0X123ABC</span>
<span class="token number">1.234568E-01</span>
Same numbers<span class="token punctuation">,</span> but normal formatting again<span class="token operator">:</span>
<span class="token number">1194684</span>
<span class="token number">0.123457</span>
Mixed formatting<span class="token operator">:</span> <span class="token number">123</span> <span class="token operator">+</span><span class="token number">1.230000E+02</span> <span class="token number">123.456</span>
</pre></li>
</ol>
</div></div><div id="ebook-heading-x4ecestdiostreamx9519x8befx4e2dx83b7x53d6x53efx8bfbx5f02x5e38" ebook-toc-level-2="" heading="从std::iostream错误中获取可读异常"><div><h1 class="mume-header" id="%E4%BB%8Estdiostream%E9%94%99%E8%AF%AF%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%8F%AF%E8%AF%BB%E5%BC%82%E5%B8%B8">从std::iostream错误中获取可读异常</h1>

<p>本书之前的章节中，我们还没对异常进行过捕获。不过对于流对象不会抛出异常，所以很容易使用。当我们想要解析10个数，不过解析过程在中途失败了，那么流对象将会将自身设置为失败状态，并且不会继续对数字进行解析。这样，我们就不会让程序处于危险当中。我们可以将解析过程转换为一个条件变量，比如<code>if (cin &gt;&gt; foo &gt;&gt; bar &gt;&gt; ...)</code>。如果这个判断失败了，那我们将对输入进行处理。所以，这里并不会出现<code>try-catch</code>代码块。</p>
<p>实际上，之前的C++输入输出流是会抛出异常的。异常这个特性是不是一开始就有的，所以这也可能是流对象库并不是第一个支持异常特性的原因。</p>
<p>为了对流使用异常，我们必须对每个流对象单独进行配置，让其在失败的时候抛出一个异常。不幸的是，我们可以对对象的异常进行捕获，但是这步并没有标准化。这就导致我们无法获得有效的错误信息，我们将在后续的实例中看到。如果我们很想对流对象使用异常，那么可以使用C库中有关文件系统错误状态，来获取更多的信息。</p>
<p>本节中，我们将会通过不同的方式，让程序运行失败，然后来处理这些异常，并且了解如何获取更多的有效信息。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将会让程序打开一个文件(这个过程可能会失败)，并且将会从文件中读取一个整型数字(也可能会失败)。我们可以通过激活异常的方式来发现错误，然后再来看如何对这些错误进行处理：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;system_error&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>  
</pre></li>
<li>
<p>当我们要将流对象和异常一起使用时，首先需要启动异常。为了获取一个文件流对象，在指定文件并不存在时，抛出一个异常；或是在解析错误时，我们需要将对应的失败原因设置到异常掩码的对应位上。当执行失败的时候，将触发一个异常。并通过激活的<code>failbit</code>和<code>badbit</code>，我们能让文件系统的错误抛出异常，并对这个错误进行解析：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	ifstream f<span class="token punctuation">;</span>
	f<span class="token punctuation">.</span><span class="token function">exceptions</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>failbit <span class="token operator">|</span> f<span class="token punctuation">.</span>badbit<span class="token punctuation">)</span><span class="token punctuation">;</span>	
</pre></li>
<li>
<p>现在可以使用<code>try</code>块进行对文件的访问。文件打开成功，那我们将继续读取文件中的整型数字。并且，只有在读取数字成功的情况下，我们才会对数字进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span>
        f<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"non_existant.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
        f <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">;</span>
        
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"integer has value: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>对于可能发生的两种错误，一个<code>std::ios_base::failure</code>实例将会抛出。这个对象有一个<code>what()</code>成员函数，其会为我们解释触发了哪种异常。不幸的是，并不存在标准化的信息，所以我们不会得到太多有用的信息。不过，我们至少可以区分，触发异常的是一个文件系统问题，还是一个格式解析问题。全局变量<code>errno</code>，其在C++诞生前就存在，其会设置为一个错误值，可供我们进行查看。<code>strerror</code>函数会将一个错误值，翻译为我们可以读懂的字符串。当<code>errno</code>是0时，就代表文件系统没有任何错误：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span>ios_base<span class="token double-colon punctuation">::</span>failure<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Caught error: "</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>errno<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cerr <span class="token operator">&lt;&lt;</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
            cerr <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，两种错误可能都会在运行时发生。当文件不存在时，我们就不可能从文件中获取数值，所以我们会得到一个<code>iostream_category</code>错误信息：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>readable_error_msg
Caught error<span class="token operator">:</span> ios_base<span class="token double-colon punctuation">::</span>clear<span class="token operator">:</span> unspecified iostream_category
</pre></li>
<li>
<p>如果文件不存在， <code>strerror(errno)</code>将会返回不同的错误信息：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>readable_error_msg
Caught error<span class="token operator">:</span> No such file <span class="token operator">or</span> directory
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>我们可以通过<code>s.exceptions(s.failbit | s.badbit)</code>使能流对象s抛出异常的能力。不过，这也就意味着有些情况无法使用异常，例如<code>std::ifstream</code>的实例需要打开一个文件进行构造，所以我们不能在之后对异常进行设置。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">ifstream f <span class="token punctuation">{</span><span class="token string">"non_existant.txt"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
f<span class="token punctuation">.</span><span class="token function">exceptions</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// too late for an exception</span>
</pre><p>这就十分遗憾了，因为异常处理与原始C风格的方式进行对比，无需被<code>if</code>困扰，其每一步都是在处理异常。</p>
<p>当我们使用各种方法让流处于失败的状态，就会发现抛出的这些异常并没有什么区别。这样只需要了解何时捕获错误，而非捕获了什么错误(对于流是这样，而对于STL中的其他类型就不是了)，这也就是为什么我们要对<code>errno</code>的值进行检查的原因。这个全局变量在C++和异常诞生之前，就已经存在了。</p>
<p>如果有任何与系统相关的函数发生了错误，其会将<code>errno</code>设置为除0之外的其他值(0代表没有错误)，然后调用者可以通过对<code>errno</code>值的查询，来了解到底出现了什么问题。这个问题我们在多线程程序会经常遇到，并且所有线程都会对一个全局变量进行修改，那么当出现错误了，是哪个线程造成的呢？幸运的是，这个设计已经在C++11中进行了修改，每个线程都只能看到属于自己的<code>erron</code>变量。</p>
<p>对于原始的错误处理方式，我们就不进行详细的描述了，不过其能为我们提供额外有用的信息，比如流对象触发了基于系统的异常。异常会告诉我们发生了什么，而<code>erron</code>则会告诉我们会发生哪种级别的错误。</p>
</div></div><div id="ebook-heading-x7b2c8x7ae0-x5de5x5177x7c7b" ebook-toc-level-1="" heading="第8章 工具类"><div><h1 class="mume-header" id="%E7%AC%AC8%E7%AB%A0-%E5%B7%A5%E5%85%B7%E7%B1%BB">第8章 工具类</h1>

<p>本章将关注工具类，这些类能帮助我们很快地解决一些特定的任务。有些工具类我们将会在本书后续的章节中经常使用。</p>
<p>前两节与时间测量有关，我们将了解到如何在两种不同的时间单位间互相转换，并如何确定两个时间点。</p>
<p>然后，我了解一下<code>optional</code>、<code>variant</code>和<code>any</code>类型(都是在C++14和C++17中添加的新类)，在接下来的5节中，我们将介绍有关<code>tuple</code>的内容。</p>
<p>C++11之后，C++中添加了新的智能指针类型，分别为：<code>unique_ptr</code>，<code>shared_ptr</code>和<code>weak_ptr</code>，因为智能指针方便对内存的管理，所以给智能指针设置了5节内容。</p>
<p>最后，将从大体上浏览一下STL中有关于随机数生成的部分。除了学习STL中随机数引擎的特性之外，还将了解到如何在实际应用中选择合适的随机数分布。</p>
</div></div><div id="ebook-heading-x8f6cx6362x4e0dx540cx7684x65f6x95f4x5355x4f4dx2014x2014stdratio" ebook-toc-level-2="" heading="转换不同的时间单位——std::ratio"><div><h1 class="mume-header" id="%E8%BD%AC%E6%8D%A2%E4%B8%8D%E5%90%8C%E7%9A%84%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8Dstdratio">转换不同的时间单位——std::ratio</h1>

<p>C++11之后，STL具有了很多用来测量和显示时间的新类型和函数。STL这部分内容放在<code>std::chrono</code>命名空间中。</p>
<p>本节我们将关注测量时间，以及如何对两种不同的时间单位进行转换，比如：秒到毫秒和微秒的转换。STL已经提供了现成的工具，我们可以自定义时间单位，并且可以无缝的在不同的时间单位间进行转换。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们写一个小游戏，会让用户输入一个单词，然后记录用户打字的速度，并以不同的时间单位显示所用时间：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ratio&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;optional&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p><code>chrono::duration</code>经常用来表示所用时间的长度，其为秒的倍数或小数，所有STL的程序都由整型类型进行特化。本节中，将使用<code>double</code>进行特化。本节之后，我们更多的会关注已经存在于STL的时间单位：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> seconds <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>1毫秒为1/1000秒，可以用这个单位来定义秒。<code>ratio_multiply</code>模板参数可以使用STL预定义的<code>milli</code>用来表示<code>seconds::period</code>，其会给我们相应的小数。<code>ratio_multiply</code>为基本时间的倍数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> milliseconds <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>
	<span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> ratio_multiply<span class="token operator">&lt;</span>seconds<span class="token double-colon punctuation">::</span>period<span class="token punctuation">,</span> milli<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>对于微秒来说也是一样的。可以使用<code>micro</code>表示：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> microseconds <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>
	<span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> ratio_multiply<span class="token operator">&lt;</span>seconds<span class="token double-colon punctuation">::</span>period<span class="token punctuation">,</span> micro<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们实现一个函数，会用来从用户的输入中读取一个字符串，并且统计用户输入所用的时间。这个函数没有参数，在返回用户输入的同时，返回所用的时间，我们用一个组对(pair)将这两个数进行返回：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> seconds<span class="token operator">&gt;</span> <span class="token function">get_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	string s<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们需要从用户开始输入时计时，记录一个时间点的方式可以写成如下方式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">tic</span> <span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在可以来获取用户的输入了。当我们没有获取成功，将会返回一个默认的元组对象。这个元组对象中的元素都是空：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>成功获取输入后，我们会打上下一个时间戳。然后，返回用户的输入和输入所用的时间。注意这里获取的都是绝对的时间戳，通过计算这两个时间戳的差，我们得到了打印所用的时间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">toc</span> <span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	<span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span>s<span class="token punctuation">,</span> toc <span class="token operator">-</span> tic<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</pre></li>
<li>
<p>现在让我们来实现主函数，使用一个循环获取用户的输入，直到用户输入正确的字符串为止。在每次循环中，我们都会让用户输入"C++17"，然后调用<code>get_input</code>函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please type the word \"C++17\" as"</span>
    			<span class="token string">" fast as you can.\n&gt; "</span><span class="token punctuation">;</span>
        
    	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token punctuation">[</span>user_input<span class="token punctuation">,</span> diff<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">get_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后对输入进行检查。当输入为空，程序会终止：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">		<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>user_input <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre><ol start="11">
<li>
<p>当用户正确的输入"C++17"，我们将会对用户表示祝贺，然后返回其输入所用时间。<code>diff.count()</code>函数会以浮点数的方式返回输入所用的时间。当我们使用STL原始的<code>seconds</code>时间类型时，将会得到一个已舍入的整数，而不是一个小数。通过使用以毫秒和微秒为单位的计时，我们将获得对应单位的计数，然后通过相应的转换方式进行时间单位转换：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>user_input <span class="token operator">==</span> <span class="token string">"C++17"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Bravo. You did it in:\n"</span>
                <span class="token operator">&lt;&lt;</span> fixed <span class="token operator">&lt;&lt;</span> <span class="token function">setprecision</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
                <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> diff<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token operator">&lt;&lt;</span> <span class="token string">" seconds.\n"</span>
                <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token function">milliseconds</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token operator">&lt;&lt;</span> <span class="token string">" milliseconds.\n"</span>
                <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token function">microseconds</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token operator">&lt;&lt;</span> <span class="token string">" microseconds.\n"</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>如果用户输入有误时，我们会提示用户继续输入：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Sorry, your input does not match."</span>
           			<span class="token string">" You may try again.\n"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就会得到如下的输出。第一次输入时，会有一个错误，程序会让我们重新进行输入。在正确输入之后，我们就会得到输入所花费的时间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>ratio_conversion
Please type the word <span class="token string">"C++17"</span> as fast as you can<span class="token punctuation">.</span>
<span class="token operator">&gt;</span> c<span class="token operator">+</span><span class="token number">17</span>
Sorry<span class="token punctuation">,</span> your input does <span class="token operator">not</span> match<span class="token punctuation">.</span> You may <span class="token keyword keyword-try">try</span> again<span class="token punctuation">.</span>
Please type the word <span class="token string">"C++17"</span> as fast as you can<span class="token punctuation">.</span>
<span class="token operator">&gt;</span> C<span class="token operator">++</span><span class="token number">17</span>
Bravo<span class="token punctuation">.</span> You did it in<span class="token operator">:</span> 
        <span class="token number">2.82</span> seconds<span class="token punctuation">.</span>
     <span class="token number">2817.95</span> milliseconds<span class="token punctuation">.</span>
  <span class="token number">2817948.40</span> microseconds<span class="token punctuation">.</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节中对不同时间单位进行转换是，我们需要先选择三个可用的时钟对象的一个。其分别为<code>system_clock</code>，<code>steady_clock</code>和<code>high_resolution_clock</code>，这三个时钟对象都在<code>std::chrono</code>命名空间中。他们有什么区别呢？让我们来看一下：</p>
<table>
<thead>
<tr>
<th>时钟类型</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/chrono/system_clock">system_clock</a></td>
<td>表示系统级别的实时挂钟。想要获取本地时间的话，这是个正确的选择。</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/chrono/steady_clock">steady_clock</a></td>
<td>表示单调型的时间。这个时间是不可能倒退的，而时间倒退可能会在其他时钟上发生，比如：其最小精度不同，或是在冬令时和夏令时交替时。</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/chrono/high_resolution_clock">high_resolution_clock</a></td>
<td>STL中可统计最细粒度时钟周期的时钟。</td>
</tr>
</tbody>
</table>
<p>当我们要衡量时间的“距离”，或者计算两个时间点的绝对间隔。即便时钟是112年，5小时，10分钟，1秒(或其他)之后或之前的时间，这都不影响两个时间点间的相对距离。这里我们唯一关注的就是打的两个时间点<code>toc</code>和<code>tic</code>，时钟需要是微秒级别的(许多系统都使用这样的时钟)，因为不同的时钟对于我们的测量有一定的影响。对于这样的需求，<code>steady_clock</code>无疑是最佳的选择。其能根据处理器的时间戳计数器进行实现，只要该时钟开始计数(系统开始运行)就不会停止。</p>
<p>OK，现在来对合适的时间对象进行选择，可以通过<code>chrono::steady_clock::now()</code>对时间点进行保存。<code>now</code>函数会返回一个<code>chrono::time_point&lt;chrono::steady_clock&gt;</code>类的值。两个点之间的差就是所用时间间隔，或<code>chrono::duration</code>类型的时间长度。这个类型是本节的核心类型，其看起来有点复杂。让我们来看一下<code>duration</code>模板类的签名：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span>
    <span class="token keyword keyword-class">class</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span>
    <span class="token keyword keyword-class">class</span> <span class="token class-name">Period</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>ratio<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;</span> <span class="token keyword keyword-class">class</span> <span class="token class-name">duration</span><span class="token punctuation">;</span>
</pre><p>我们需要改变的参数类为<code>Rep</code>和<code>Period</code>。<code>Rep</code>很容易解释：其只是一个数值类型用来保存时间点的值。对于已经存在的STL时间单位，都为<code>long long int</code>型。本节中，我们选择了<code>double</code>。因为我们的选择，保存的时间描述也可以转换为毫秒或微秒。当<code>chrono::seconds</code>类型记录的时间为1.2345秒时，其会舍入成一个整数秒数。这样，我们就能使用<code>chrono::microseconds</code>来保存<code>tic</code>和<code>toc</code>之间的时间，并且将其转化为粒度更加大的时间。正因为选择<code>double</code>作为<code>Rep</code>传入，可以对计时的精度在丢失较少精度的情况下，进行向上或向下的调整。</p>
<p>对于我们的计时单位，我们采取了<code>Rep = double</code>方式，所以会在<code>Period</code>上有不同的选择：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> seconds <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> milliseconds <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span>
	ratio_multiply<span class="token operator">&lt;</span>seconds<span class="token double-colon punctuation">::</span>period<span class="token punctuation">,</span> milli<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> microseconds <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span>
	ratio_multiply<span class="token operator">&lt;</span>seconds<span class="token double-colon punctuation">::</span>period<span class="token punctuation">,</span> micro<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
</pre><p><code>seconds</code>是最简单的时间单位，其为<code>Period = ratio&lt;1&gt;</code>，其他的时间单位就只能进行转换。1毫秒是千分之一秒，所以我们将使用<code>milli</code>特化的<code>seconds::period</code>转化为秒时，就要使用<code>std::ratio&lt;1, 1000&gt;</code>类型(<code>std::ratio&lt;a, b&gt;</code>表示分数值a/b)。<code>ratio_multiply</code>类型是一个编译时函数，其表示对应类型的结果是多个<code>ratio</code>值累加。</p>
<p>可能这看起来非常复杂，那就让我们来看一个例子吧：<code>ratio_multiply&lt;ratio&lt;2, 3&gt;, ratio&lt;4, 5&gt;&gt;</code>的结果为<code>ratio&lt;8, 15&gt;</code>，因为<code>(2/3) * (4/5) = 8/15</code>。</p>
<p>我们结果类型定义等价情况如下：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> seconds <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> ratio<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> milliseconds <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> ratio<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> microseconds <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> ratio<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1000000</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
</pre><p>上面列出的类型，很容易的就能进行转换。当我们具有一个时间间隔<code>d</code>，其类型为<code>seconds</code>，我们就能将其转换成<code>milliseconds</code>。转换只需要通过构造函数就能完成——<code>milliseconds(d)</code>。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>其他教程和书籍中，你可以会看到使用<code>duration_cast</code>的方式对时间进行转换。当我们具有一个时间间隔类<code>chrono::milliseconds</code>和要转换成的类型<code>chrono::hours</code>时，就需要转换为<code>duration_cast&lt;chrono::hours&gt;(milliseconds_value)</code>，因为这些时间单位都是整型。从一个细粒度的时间单位，转换成一个粗粒度的时间单位，将会带来时间精度的损失，这也是为什么我们使用<code>duration_cast</code>的原因。基于<code>double</code>和<code>float</code>的时间间隔类型不需要进行强制转换。</p>
</div></div><div id="ebook-heading-x8f6cx6362x7eddx5bf9x65f6x95f4x548cx76f8x5bf9x65f6x95f4x2014x2014stdchrono" ebook-toc-level-2="" heading="转换绝对时间和相对时间——std::chrono"><div><h1 class="mume-header" id="%E8%BD%AC%E6%8D%A2%E7%BB%9D%E5%AF%B9%E6%97%B6%E9%97%B4%E5%92%8C%E7%9B%B8%E5%AF%B9%E6%97%B6%E9%97%B4stdchrono">转换绝对时间和相对时间——std::chrono</h1>

<p>C++11之前，想要获取时间并对其打印是有些困难的，因为C++并没有标准时间库。想要对时间进行统计就需要调用C库，并且我们要考虑这样的调用是否能很好的封装到我们的类中。</p>
<p>C++11之后，STL提供了<code>chrono</code>库，其让对时间的操作更加简单。</p>
<p>本节，我们将会使用本地时间，并对本地时间进行打印，还会给时间加上不同的偏移，这些操作很容易使用<code>std::chrono</code>完成。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将会对当前时间进行保存，并对其进行打印。另外，我们的程序还会为已经保存的时间点添加不同的偏移，并且打印偏移之后的时间：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>我们将打印绝对时间点。使用<code>chrono::time_point</code>模板类型来获取，因此需要对输出流操作符进行重载。对时间点的打印方式有很多，我们将会使用<code>%c</code>来表示标准时间格式。当然，可以只打印时间、日期或是我们需要的信息。调用<code>put_time</code>之前对不同类型的变量进行转换的方式看起来有些笨拙，不过这里只这么做一次：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">ostream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span>
	<span class="token keyword keyword-const">const</span> chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">tt</span> <span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">to_time_t</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">loct</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">localtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> os <span class="token operator">&lt;&lt;</span> <span class="token function">put_time</span><span class="token punctuation">(</span>loct<span class="token punctuation">,</span> <span class="token string">"%c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>STL已经定义了<code>seconds</code>，<code>minutes</code>，<code>hours</code>等时间类型，所以我们只需要为其添加<code>days</code>类型就好。这很简单，只需要对<code>chrono::duration</code>模板类型进行特化，将hours类型乘以24，就表示一天具有24个小时：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> days <span class="token operator">=</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>
    chrono<span class="token double-colon punctuation">::</span>hours<span class="token double-colon punctuation">::</span>rep<span class="token punctuation">,</span>
    ratio_multiply<span class="token operator">&lt;</span>chrono<span class="token double-colon punctuation">::</span>hours<span class="token double-colon punctuation">::</span>period<span class="token punctuation">,</span> ratio<span class="token operator">&lt;</span><span class="token number">24</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了用很有优雅的方式表示很多天，我们定义属于<code>days</code>类型的字面值操作符。现在我们程序中写<code>3_days</code>就代表着3天：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-constexpr">constexpr</span> days <span class="token keyword keyword-operator">operator</span> <span class="token string">""</span><span class="token function">_days</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-long">long</span> d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> days<span class="token punctuation">{</span>d<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>实际程序中，我们将会对时间点进行记录，然后就会对这个时间点进行打印。因为已经对操作符进行了重载，所以完成这样的事情就变得很简单：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">now</span> <span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The current date and time is "</span> <span class="token operator">&lt;&lt;</span> now <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>我们使用<code>now</code>函数来获得当前的时间点，并可以为这个时间添加一个偏移，然后再对其进行打印。为当前的时间添加12个小时，其表示的为12个小时之后的时间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	chrono<span class="token double-colon punctuation">::</span>hours chrono_12h <span class="token punctuation">{</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"In 12 hours, it will be "</span>
		<span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>now <span class="token operator">+</span> chrono_12h<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>这里将使用<code>chrono_literals</code>命名空间中的函数，声明使用这个命名空间会解锁小时、秒等等时间类型的间隔字面值类型。这样我们就能很优雅的对12个小时15分之前的时间或7天之前的时间进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> chrono_literals<span class="token punctuation">;</span>
    
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"12 hours and 15 minutes ago, it was "</span>
        <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> <span class="token number">12</span>h <span class="token operator">-</span> <span class="token number">15</span>min<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">"1 week ago, it was "</span>
        <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> <span class="token number">7</span>_days<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</pre></li>
<li>
<p>编译并运行程序，我们将会获得如下的输出。因为使用<code>%c</code>格式对时间进行打印，所以得到还不错的时间输出格式。通过对不同格式的的字符串进行操作，我们可以获得想要的格式。要注意的是，这里的时间格式并不是以12小时AM/PM方式表示，因为程序运行在欧洲操作系统上，所以使用24小时表示的方式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>relative_absolute_times
The current date <span class="token operator">and</span> time is Fri May <span class="token number">5</span> <span class="token number">13</span><span class="token operator">:</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">38</span> <span class="token number">2017</span>
In <span class="token number">12</span> hours<span class="token punctuation">,</span> it will be Sat May6 <span class="token number">01</span><span class="token operator">:</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">38</span> <span class="token number">2017</span>
<span class="token number">12</span> hours <span class="token operator">and</span> <span class="token number">15</span> minutes ago<span class="token punctuation">,</span> it was Fri May5 <span class="token number">01</span><span class="token operator">:</span><span class="token number">05</span><span class="token operator">:</span><span class="token number">38</span> <span class="token number">2017</span>
<span class="token number">1</span> week ago<span class="token punctuation">,</span> it was Fri Apr <span class="token number">28</span> <span class="token number">13</span><span class="token operator">:</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">38</span> <span class="token number">2017</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>我们可以通过<code>std::chrono::system_clock</code>来获取当前时间点。这个STL时钟类是唯一一个能将时间点的值转换成一个时间结构体的类型，其能将时间点以能够看懂的方式进行输出。</p>
<p>为了打印这样的时间点，我们可以对<code>operator&lt;&lt;</code>操作符进行重载：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">ostream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span>
				   <span class="token keyword keyword-const">const</span> chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">tt</span> <span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">to_time_t</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">loct</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">localtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> os <span class="token operator">&lt;&lt;</span> <span class="token function">put_time</span><span class="token punctuation">(</span>loct<span class="token punctuation">,</span> <span class="token string">"%c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>首先，将<code>chrono::time_point&lt;chrono::system_clock&gt;</code>转换为<code>std::time_t</code>。然后，使用<code>std::localtime</code>将这个时间值进行转换，这样就能获取到一个本地时钟的相对时间值。这个函数会给我们返回一个转换后的指针(对于这个指针背后的内存不用我们多操心，因为其是一个静态对象，并不是从堆上分配的内存)，这样我们就能完成最终的打印。</p>
<p><code>std::put_time</code>函数接受一个流对象和一个时间格式字符串。<code>%c</code>表示标准时间格式字符串，例如<code>Sun Mar 12 11:33:40 2017</code>。我们也可以写成<code>%m/%d/%y</code>；之后，时间就会按照这个格式进行打印，比如<code>03/12/17</code>。时间格式符的描述很长，想要了解其具体描述的最好方式就是去查看C++参考手册。</p>
<p>除了打印，我们也会为我们的时间点添加偏移。这也很简单，比如：12小时15分钟就可以表示为<code>12h+15min</code>。<code>chrono_literals</code>命名空间为我们提供了字面类型：<code>hours(h), minutes(min), seconds(s), milliseconds(ms), microseconds(us), nanoseconds(ns)</code>。</p>
<p>通过对两个时间间隔的相加，我们会得到一个新的时间点。要实现这样的操作就需要对左加<code>operator+</code>和左减<code>operator-</code>操作符进行重载，这样对时间偏移的操作就会变得非常简单。</p>
</div></div><div id="ebook-heading-x5b89x5168x7684x6807x8bc6x5931x8d25x2014x2014stdoptional" ebook-toc-level-2="" heading="安全的标识失败——std::optional"><div><h1 class="mume-header" id="%E5%AE%89%E5%85%A8%E7%9A%84%E6%A0%87%E8%AF%86%E5%A4%B1%E8%B4%A5stdoptional">安全的标识失败——std::optional</h1>

<p>当程序与外界的联系只依赖于一些变量时，那么各种失败都可能发生。</p>
<p>也就是，我们写了一个函数，其会返回一个值，但是当函数接口进行变更后，可能就无法获取这个返回值了。我们来看下对一个返回字符串的函数，怎样的接口会容易出现失败的情况：</p>
<ul>
<li>使用引用值作为返回值：<code>bool get_string(string&amp;);</code></li>
<li>返回一个可以被设置为nullptr的指针(或智能指针)：<code>string* get_string();</code></li>
<li>当函数出错时，直接抛出异常：<code>string get_string();</code></li>
</ul>
<p>以上的方式有缺点，也有优点。在C++17之后，我们会使用一种新类型来解决这个问题：<code>std::optional</code>。可选值的概念来自于纯函数式编程语言(在纯函数式语言中，这个类型为Maybe类型)，并且可以让代码看上去很优雅。</p>
<p>我们可以将<code>optional</code>包装到我们的类型中，其可以表示空值或错误值。本节中，我们就会来学习怎么使用这个类型。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将实现一个程序用于从用户输入中读取整型数，然后将这些数字加起来。因为不确定用户会输入什么，所以我们会使用<code>optional</code>进行错误处理：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;optional&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>定义一个整型类型，其可能会包含一个值，使用<code>std::optional</code>类型来完成这件事。将目标类型包装进<code>optional</code>，我们会给其一个附加状态，其表示当前对象中没有值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> oint <span class="token operator">=</span> optional<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>使用包装后的整型类型，我们用其来表示函数返回失败的情况。当从用户输入中获取一个整数时，这个函数可能会失败，因为用户可能输入的就不是我们想要的东西，返回可选整型就能很好的解决这个问题。当成功的读取一个整数，我们会将其放入<code>optional&lt;int&gt;</code>的构造函数中。否则，我们将返回一个默认构造的<code>optional</code>，其代表没有获取成功：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">oint <span class="token function">read_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span>i<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>除了获取整数，我们还能做的更多。那怎么使用两个可选整数进行相加呢？如果两个可选整数中具有相应的整数值，那么使用实际的数值直接相加。存在有空的可选变量时，我们会返回一个空的可选变量。这个函数需要简单的来解释一下：通过隐式转换，将<code>optional&lt;int&gt;</code>变量a和b转化成一个布尔表达式(写成!a和!b)，这就能让我们确定可选变量中是否有值。如果其中有值，我们将对其使用指针或是迭代器的方式，对a和b直接解引用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">oint <span class="token keyword keyword-operator">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>oint a<span class="token punctuation">,</span> oint b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>a <span class="token operator">||</span> <span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token operator">*</span>a <span class="token operator">+</span> <span class="token operator">*</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>重载加法操作，可以直接和一个普通整数进行相加：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">oint <span class="token keyword keyword-operator">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>oint a<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token operator">*</span>a <span class="token operator">+</span> b<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在来完成主函数部分，我们会让用户输入两个数值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please enter 2 integers.\n&gt; "</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-auto">auto</span> a <span class="token punctuation">{</span><span class="token function">read_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> b <span class="token punctuation">{</span><span class="token function">read_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>然后，将获取的数值进行相加，并再与10进行相加。这里<code>a</code>和<code>b</code>为可选整型类变量，<code>sum</code>也为可选整型类变量：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">sum</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>当<code>a</code>和/或<code>b</code>中不包含一个值时，<code>sum</code>就也不包含任何值。可选整型可依然我们不必显式的对<code>a</code>和<code>b</code>进行检查。当遇到空值的时，我们定义的操作符能很完美的处理这样的情况。这样，我们只需要对结果可选整型变量进行检查即可。如果包含一个值，那就可以安全的对这个值进行访问，并将其进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>a <span class="token operator">&lt;&lt;</span> <span class="token string">" + "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>b <span class="token operator">&lt;&lt;</span> <span class="token string">" + 10 = "</span>
		<span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sum <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>当用户输入了非数字内容，我们将会输出错误信息：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sorry, the input was "</span>
        		<span class="token string">"something else than 2 numbers.\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>完成了！编译并运行程序，我们将会得到如下输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>optional
Please enter <span class="token number">2</span> integers<span class="token punctuation">.</span>
<span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token number">2</span>
<span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">=</span> <span class="token number">13</span>
</pre></li>
<li>
<p>当输入中包含非数字元素，我们将会得到如下输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>optional
Please enter <span class="token number">2</span> integers<span class="token punctuation">.</span>
<span class="token operator">&gt;</span> <span class="token number">2</span> z
sorry<span class="token punctuation">,</span> the input was something <span class="token keyword keyword-else">else</span> than <span class="token number">2</span> numbers<span class="token punctuation">.</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>optional</code>非常简单易用。其可以帮助我们对错误的情况进行处理，当我们所需要的类型为T时，可以将其特化<code>std::optional&lt;T&gt;</code>版本类型进行封装。</p>
<p>当需要从一些地方获取一些值时，我们可以用其来检查我们是否成功的获取了对应的数值。<code>bool optional::has_value()</code>可以帮助我们完成这件事。当其包含值时，其会返回true，我们就能直接对数值进行访问，对可选类型的值访问也可以通过函数<code>T&amp; optional::value()</code>进行。</p>
<p>例子中，使用<code>if (x) {...}</code>和<code>*x</code>来替代<code>if (x.has_value()) {...}</code>和<code>x.value()</code>。<code>std::optonal</code>类型可以隐式的转换成<code>bool</code>类型，并且使用解引用操作符的方式和普通指针差不多。</p>
<p>另一个方便辅助操作符就是对<code>optional</code>的<code>operator-&gt;</code>操作符进行重载。当有一个结构体<code>struct Foo { int a; string b; }</code>类型，并且我们想要通过一个<code>optional&lt;Foo&gt;</code>来访问其成员变量x，那么就可以写成<code>x-&gt;a</code>或<code>x-&gt;b</code>。当然，需要对x和b进行检查，确定其是否有值。</p>
<p>当可选变量中没有值时，我们还要对其进行访问，其就会抛出一个<code>std::logic_error</code>异常。这样，就可以对大量的可选值在不进行检查的情况下进行使用。<code>try-catch</code>块的代码如下：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please enter 3 numbers:\n"</span><span class="token punctuation">;</span>

<span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Sum: "</span>
		<span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">read_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token operator">*</span><span class="token function">read_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token operator">*</span><span class="token function">read_int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>bad_optional_access <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Unfortunately you did not enter 3 numbers\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p><code>std::optional</code>具有一个有趣的<code>optional::value_or</code>操作。当我们想要在失败的时候，可选变量包含一个默认值进行返回时，这个操作就很有用了。<code>x = optional_var.value_or(123)</code>就能将123作为可选变量失败时的默认数值。</p>
</div></div><div id="ebook-heading-x5bf9x5143x7ec4x4f7fx7528x51fdx6570" ebook-toc-level-2="" heading="对元组使用函数"><div><h1 class="mume-header" id="%E5%AF%B9%E5%85%83%E7%BB%84%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0">对元组使用函数</h1>

<p>C++11中，STL添加了<code>std::tuple</code>，这种类型可以用来将多个不同类型的值捆绑在一起。元组这种类型已经存在与很多编程语言中，本书的一些章节已经在使用这种类型，这种类型的用途很广泛。</p>
<p>不过，我们有时会将一些值捆绑在一个元组中，然后我们需要调用函数来获取其中每一个元素。对于元素的解包的代码看起来非常的冗长(并且易于出错)。其冗长的方式类似这样：<code>func(get&lt;0&gt;(tup), get&lt;1&gt;(tup), get&lt;2&gt;(tup), ...);</code>。</p>
<p>本节中，你将了解如何使用一种优雅地方式对元组进行打包和解包。调用函数时，你无需对元组特别地了解。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将实现一个程序，其能对元组值进行打包和解包。然后，我们将看到在不了解元组中元素的情况下，如何使用元组：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tuple&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>首先定义一个函数，这个函数能接受多个参数，其描述的是一个学生，并将学生的相关信息进行打印。其和C风格的函数看起来差不多：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">print_student</span><span class="token punctuation">(</span>size_t id<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> gpa<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Student "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">quoted</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">", ID: "</span> <span class="token operator">&lt;&lt;</span> id
        <span class="token operator">&lt;&lt;</span> <span class="token string">", GPA: "</span> <span class="token operator">&lt;&lt;</span> gpa <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，将对一种元组类型进行别名，然后将具体学生的信息填入到这种类型的实例中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-using">using</span> student <span class="token operator">=</span> tuple<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> string<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    student john <span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">"John Doe"</span>s<span class="token punctuation">,</span> <span class="token number">3.7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了打印这种类型的实例，我们将会对元组中的元素进行分解，然后调用<code>print_student</code>函数将这些值分别进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token punctuation">{</span>
        <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> gpa<span class="token punctuation">]</span> <span class="token operator">=</span> john<span class="token punctuation">;</span>
        <span class="token function">print_student</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> gpa<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"-----\n"</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后，我们来创建一个以元组为基础类型的多个学生：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> arguments_for_later <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">234</span><span class="token punctuation">,</span> <span class="token string">"John Doe"</span>s<span class="token punctuation">,</span> <span class="token number">3.7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">345</span><span class="token punctuation">,</span> <span class="token string">"Billy Foo"</span>s<span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">456</span><span class="token punctuation">,</span> <span class="token string">"Cathy Bar"</span>s<span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>这里，我们依旧可以通过对元素进行分解，然后对其进行打印。当要写这样的代码时，我们需要在函数接口变化时，对代码进行重构：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> gpa<span class="token punctuation">]</span> <span class="token operator">:</span> arguments_for_later<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   		<span class="token function">print_student</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> gpa<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"-----\n"</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>当然可以做的更好，我们无需知道<code>print_student</code>的参数的个数，或学生元组中元素的个数，我们使用<code>std::apply</code>对直接将元组应用于函数。这个函数能够接受一个函数指针或一个函数对象和一个元组，然后会将元组进行解包，然后与函数参数进行对应，并传入函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">apply</span><span class="token punctuation">(</span>print_student<span class="token punctuation">,</span> john<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"-----\n"</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>循环中可以这样用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>args <span class="token operator">:</span> arguments_for_later<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token function">apply</span><span class="token punctuation">(</span>print_student<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"-----\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就能得到如下的输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>apply_functions_on_tuples
Student <span class="token string">"John Doe"</span><span class="token punctuation">,</span> ID<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> GPA<span class="token operator">:</span> <span class="token number">3.7</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
Student <span class="token string">"John Doe"</span><span class="token punctuation">,</span> ID<span class="token operator">:</span> <span class="token number">234</span><span class="token punctuation">,</span> GPA<span class="token operator">:</span> <span class="token number">3.7</span>
Student <span class="token string">"Billy Foo"</span><span class="token punctuation">,</span> ID<span class="token operator">:</span> <span class="token number">345</span><span class="token punctuation">,</span> GPA<span class="token operator">:</span> <span class="token number">4</span>
Student <span class="token string">"Cathy Bar"</span><span class="token punctuation">,</span> ID<span class="token operator">:</span> <span class="token number">456</span><span class="token punctuation">,</span> GPA<span class="token operator">:</span> <span class="token number">3.5</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
Student <span class="token string">"John Doe"</span><span class="token punctuation">,</span> ID<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> GPA<span class="token operator">:</span> <span class="token number">3.7</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
Student <span class="token string">"John Doe"</span><span class="token punctuation">,</span> ID<span class="token operator">:</span> <span class="token number">234</span><span class="token punctuation">,</span> GPA<span class="token operator">:</span> <span class="token number">3.7</span>
Student <span class="token string">"Billy Foo"</span><span class="token punctuation">,</span> ID<span class="token operator">:</span> <span class="token number">345</span><span class="token punctuation">,</span> GPA<span class="token operator">:</span> <span class="token number">4</span>
Student <span class="token string">"Cathy Bar"</span><span class="token punctuation">,</span> ID<span class="token operator">:</span> <span class="token number">456</span><span class="token punctuation">,</span> GPA<span class="token operator">:</span> <span class="token number">3.5</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>std::apply</code>是一个编译时辅助函数，可以帮助我们处理不确定的类型参数。</p>
<p>试想，我们有一个元组<code>t</code>，其有元素<code>(123, "abc"s, 456.0)</code>。那么这个元组的类型为<code>tuple&lt;int, string, double&gt;</code>。另外，有一个函数<code>f</code>的签名为<code>int f(int, string, double)</code>(参数类型也可以为引用)。</p>
<p>然后，我们就可以这样调用函数<code>x = apply(f, t)</code>，其和<code>x = f(123, "abc"s, 456.0)</code>等价。<code>apply</code>方法还是会返回<code>f</code>的返回值。</p>
</div></div><div id="ebook-heading-x4f7fx7528x5143x7ec4x5febx901fx6784x6210x6570x636ex7ed3x6784" ebook-toc-level-2="" heading="使用元组快速构成数据结构"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E5%85%83%E7%BB%84%E5%BF%AB%E9%80%9F%E6%9E%84%E6%88%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">使用元组快速构成数据结构</h1>

<p>我们已经在上一节中了解元组的基本使用方法。现在我们使用一个结构体，对一些变量进行捆绑：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> a<span class="token punctuation">;</span>
  string b<span class="token punctuation">;</span>
  <span class="token keyword keyword-float">float</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>之前的章节中，为了替代定义结构体，我们可以定义一个元组：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> Foo <span class="token operator">=</span> tuple<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> string<span class="token punctuation">,</span> <span class="token keyword keyword-float">float</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre><p>我们可以根据类型列表中的索引，从而获取相应变量的具体值。如要访问元组他的第一个类型变量，可以使用<code>std::get&lt;0&gt;(t)</code>，第二个类型变量为<code>std::get&lt;1&gt;(t)</code>，以此类推。如果索引值过大，编译器会在编译时进行报错。</p>
<p>之前的章节中已经展示了C++17对元组的分解能力，允许我们使用如下的方式快速分解元素，并能对单独元素进行访问：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> some_tuple
</pre><p>绑定和分解单个数据结构，只是元组能力之一。我们也可以想尽办法对元组进行连接和分割。本节中，我们将学习如何完成这样的任务。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，我们将完成对任意元组进行打印的任务。另外，我们将完成一个函数，可以对元组进行zip操作：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tuple&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们对要处理的元组中的内容非常感兴趣，所以想要对其内容进行展示。因此，将实现一个非常通用的函数，能对任意具有可打印变量的元组进行打印。这个函数能接受一个输出流引用<code>os</code>和一个可变的参数列表，其中具有元组中的所有成员。为了解析这些参数，我们将一个参数放在<code>v</code>中，其余的放在参数包<code>vs...</code>中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">print_args</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> T <span class="token operator">&amp;</span>v<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> Ts <span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>vs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	os <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后，我们就对参数包vs进行处理，其会使用逗号将<code>initializer_list</code>中的元素进行隔开。你可以回看一下第4章的<a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/content/chapter8/content/chapter4/chapter4-5-chinese.md">使用同一输入调用多个函数</a>，了解下如何使用Lambda表达式来完成这个操作：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">(</span>os <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> vs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在就可以对任意的变量进行打印了，例如：<code>print_args(cout, 1, 2, "foo", 3, "bar")</code>。不过，依旧无法对元组进行处理。为了实现打印元组的功能，我们会对输出操作符<code>&lt;&lt;</code>进行重载，通过实现一个模板函数来匹配任意元组类型：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
ostream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> tuple<span class="token operator">&lt;</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p>接下来会有些复杂。首先，使用Lambda表达式来接收任意多个参数。当调用Lambda表达式时，启用<code>os</code>参数就会传入<code>print_args</code>函数中组成新的参数列表。这也就意味着，对<code>capt_tup(...some parameters...)</code>的调用，会形成对<code>print_args(os, ...some parameters...)</code>的调用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">print_to_os</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>os<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">print_args</span><span class="token punctuation">(</span>os<span class="token punctuation">,</span> xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在就可以来完成对元组解包的工作了。使用<code>std::apply</code>对元组进行解包，所有值将会解析成单独的变量，然后传入到所调用的函数中。当元组t为<code>(1, 2, 3)</code>时，调用<code>apply(capt_tup, t)</code>等价于<code>capt_tup(1, 2, 3)</code>的调用，随后就会调用<code>print_args(os, 1, 2, 3)</code>。最后，我们用小括号来包围所要打印的信息：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    os <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span>
    <span class="token function">apply</span><span class="token punctuation">(</span>print_to_os<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> os <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>Okay，现在已经完成打印元组代码的编写，这将让后续的工作会变得更容易。不过，需要为元组做更多的事情。例如，编写一个可以接受迭代范围的函数。这个函数可以帮助对对应范围进行迭代，然后返回这段范围中所有值的加和，并且找到这个范围内的最小值和最大值，还要能对所有值求平均。并将这四个值打包入一个元组中，我们可以不添加任何新的结构体类型类，来获取其中每一个成员的值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
tuple<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span>
<span class="token function">sum_min_max_avg</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> T <span class="token operator">&amp;</span>range<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p><code>std::minmax_element</code>会返回一对迭代器，其分别表示输入范围内的最小值和最大值。<code>std::accumulate</code>将会返回输入范围内所有值的加和。这样就能获得我们元组中的所有元素了！</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">min_max</span> <span class="token punctuation">(</span><span class="token function">minmax_element</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>range<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>range<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">sum</span> <span class="token punctuation">(</span><span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>range<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>range<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span>sum<span class="token punctuation">,</span> <span class="token operator">*</span>min_max<span class="token punctuation">.</span>first<span class="token punctuation">,</span> <span class="token operator">*</span>min_max<span class="token punctuation">.</span>second<span class="token punctuation">,</span>
    		sum <span class="token operator">/</span> range<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>实现主函数之前，我们将实现最后一个神奇辅助函数。为什么说这个函数神奇呢？因为这个函数看起来非常复杂，但当了解工作原理后，你就能理解了，这个函数会对两个元组进行zip操作。也就是说，当传入两个元组<code>(1, 2, 3)</code>和<code>('a', 'b', 'c')</code>时，函数将会返回一个值为<code>(1, 'a', 2, 'b', 3, 'c')</code>的元组：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">zip</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> T1 <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> T2 <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p>接下来，我们将会看到本节中最为复杂的几行代码。我们会创建一个函数对象<code>z</code>，其能接受任意数量的参数。其会返回另一个函数对象，返回的函数对象将获取的所有参数打包成<code>xs</code>，不过其也能接受任意数量的参数。其内部的函数对象可以对参数列表包<code>xs</code>和<code>ys</code>进行访问。现在就让我们看一下，如何对这两个参数列表包进行操作。<code>make_tuple(xs, ys)...</code>会将参数分组。当<code>xs = 1, 2, 3</code>并且<code>ys = 'a', 'b', 'c'</code>时，我们将会返回一个新的参数包<code>(1, 'a'), (2, 'b'), (3, 'c')</code>。三个元组中，用逗号来对每个成员进行区分。为了获取分组后的元组，我们使用了<code>std::tuple_cat</code>，其能接受任意数量的元组，并且将其解包后放入一个元组中。这样我们就可以获得一个新元组<code>(1, 'a', 2, 'b', 3, 'c')</code>：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">z</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span>xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ys<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> <span class="token function">tuple_cat</span><span class="token punctuation">(</span><span class="token function">make_tuple</span><span class="token punctuation">(</span>xs<span class="token punctuation">,</span> ys<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><ol start="11">
<li>
<p>最后一步就是将所有输入元组中的成员解包出来，也就是将<code>a</code>和<code>b</code>进行解包后放入<code>z</code>中。<code>apply(z, a)</code>就表示将<code>a</code>中的所有值放入<code>xs</code>中，<code>apply(..., b)</code>就表示将<code>b</code>中的所有值放入<code>ys</code>中。最后的结果元组就是zip后的一个非常大的元组，其会返回给调用者：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-return">return</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token function">apply</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</pre></li>
<li>
<p>我们写了非常多的辅助代码。现在，我们就来使用这些辅助函数。首先，构造出一些元组。<code>student</code>类型包括ID，名字，和<a href="https://zh.wikipedia.org/wiki/%E6%88%90%E7%B8%BE%E5%B9%B3%E5%9D%87%E7%A9%8D%E9%BB%9E">GPA</a>分数。<code>student_desc</code>使用人类可读的格式对学生进行介绍。<code>std::make_tuple</code>是一个非常不错的工厂函数，因为其能通过传入的参数，自适应的生成对应的元组类型：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">student_desc</span> <span class="token punctuation">(</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token string">"ID"</span><span class="token punctuation">,</span> <span class="token string">"Name"</span><span class="token punctuation">,</span> <span class="token string">"GPA"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">student</span> <span class="token punctuation">(</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">123456</span><span class="token punctuation">,</span> <span class="token string">"John Doe"</span><span class="token punctuation">,</span> <span class="token number">3.7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>我们对这些信息进行打印。因为已经对输出流操作符进行过重载，所以打印并不是什么难事：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> student_desc <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span>
		<span class="token operator">&lt;&lt;</span> student <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们也可以通过<code>std::tuple_cat</code>将所有元组进行连接，然后进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token function">tuple_cat</span><span class="token punctuation">(</span>student_desc<span class="token punctuation">,</span> student<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们有可以通过我们的zip函数创建新的元组：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">zipped</span> <span class="token punctuation">(</span><span class="token function">zip</span><span class="token punctuation">(</span>student_desc<span class="token punctuation">,</span> student<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> zipped <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>别忘记<code>sum_min_max_avg</code>函数。我们将初始化列表中具有一些数字，并且会将这些数字传入这个函数中。创建了另一个同等大小的元组，其包含了一些描述字符串，这可能会让程序变得复杂一些。通过zip这些元组，并将这些元组交错的存储在了一起：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> numbers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">zip</span><span class="token punctuation">(</span>
            <span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token string">"Sum"</span><span class="token punctuation">,</span> <span class="token string">"Minimum"</span><span class="token punctuation">,</span> <span class="token string">"Maximum"</span><span class="token punctuation">,</span> <span class="token string">"Average"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">sum_min_max_avg</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就会得到如下输出。前两行是<code>student</code>和<code>student_desc</code>元组的打印结果。第3行是使用<code>tuple_cat</code>组合后的输出结果。第4行是将学生元组进行<code>zip</code>后的结果。最后一行我们将会看到对应数字列表的和值、最小值、最大值和均值。因为有<code>zip</code>操作，我们可以清楚地了解这些数字的意义：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span><span class="token function">tuple</span>
<span class="token punctuation">(</span>ID<span class="token punctuation">,</span> Name<span class="token punctuation">,</span> GPA<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">123456</span><span class="token punctuation">,</span> John Doe<span class="token punctuation">,</span> <span class="token number">3.7</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>ID<span class="token punctuation">,</span> Name<span class="token punctuation">,</span> GPA<span class="token punctuation">,</span> <span class="token number">123456</span><span class="token punctuation">,</span> John Doe<span class="token punctuation">,</span> <span class="token number">3.7</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>ID<span class="token punctuation">,</span> <span class="token number">123456</span><span class="token punctuation">,</span> Name<span class="token punctuation">,</span> John Doe<span class="token punctuation">,</span> GPA<span class="token punctuation">,</span> <span class="token number">3.7</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>Sum<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> Minimum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Maximum<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> Average<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节的有些代码的确比较复杂。我们对元组的<code>operator&lt;&lt;</code>操作符进行了重载实现，这样看起来比较复杂，但是这样就能对元组中的成员进行打印。然后我们实现<code>sum_min_max_avg</code>函数，其会返回一个元组。另外，<code>zip</code>应该是个比较复杂的函数。</p>
<p>这里最简单的函数是<code>sum_min_max_avg</code>。当我们定义一个函数<code>tuple&lt;Foo, Bar, Baz&gt; f()</code>时，我们可以将返回语句写成<code>return {foo_instance, bar_instance, baz_instance};</code>，这样函数将会自动的构建一个元组进行返回。如果你对<code>sum_min_max_avg</code>中所使用的STL函数有疑问，那可以回看一下第5章，其中有一些STL的基本函数操作。</p>
<p>其他较为复杂的部分，就是一些辅助函数：</p>
<p><strong>operator&lt;&lt; for tuples</strong></p>
<p>使用<code>operator&lt;&lt;</code>对输出流进行输出时，我们实现了<code>print_args</code>函数。其可以接受任意个参数，不过第一个参数必须是一个<code>ostream</code>实例：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">print_args</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> T <span class="token operator">&amp;</span>v<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> Ts <span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>vs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	os <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">;</span>
    
	<span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">(</span>os <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> vs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>这个函数打印的第一个元素是<code>v</code>，然后会将参数包<code>vs</code>中的元素进行打印。我们将第一个元素单独拎出来的原因是要使用逗号将所有元素进行分隔，但是我们不确定哪个参数是头或是尾(也就是要打印成“1, 2, 3”或是“,1, 2, 3”)。我们在第4章了解到使用Lambda表达式对<code>initializer_list</code>进行扩展，也就是<a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/content/chapter8/content/chapter4/chapter4-5-chinese.md">使用同一输入调用多个函数</a>这一节。这个函数，就能帮我们对元组进行打印。<code>operator&lt;&lt;</code>实现如下所示：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
ostream<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> tuple<span class="token operator">&lt;</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">capt_tup</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>os<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token function">print_args</span><span class="token punctuation">(</span>os<span class="token punctuation">,</span> xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    os <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span>
    <span class="token function">apply</span><span class="token punctuation">(</span>capt_tup<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> os <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>首先我们定义了一个函数对象<code>capt_tup</code>。当我们调用<code>capt_tup(foo, ar, whatever)</code>时，其实际调用的是print_args(<strong>os</strong>, foo, bar, whatever)。这个函数只会做一件事，就是将可变列表中的参数输出到输出流对象<code>os</code>中。</p>
<p>之后，我们使用<code>std::apply</code>对元组<code>t</code>进行解包。如果这步看起来很复杂，那么可以看一下前一节，以了解<code>std::apply</code>的工作原理。</p>
<p><strong>元素的zip函数</strong></p>
<p>zip函数能够接收两个元组，虽然其实现很清晰，但是看起来还是异常复杂：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">zip</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> T1 <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> T2 <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">z</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span>xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ys<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> <span class="token function">tuple_cat</span><span class="token punctuation">(</span><span class="token function">make_tuple</span><span class="token punctuation">(</span>xs<span class="token punctuation">,</span> ys<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token function">apply</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>为了能更好的了解这段代码，我们可以假设有两个元组，一个元组a为(1, 2, 3)，另一个元组b为('a', 'b', 'c')。</p>
<p>例程中，我们调用了<code>apply(z, a)</code>，也就相当于调用函数<code>z(1, 2, 3)</code>，其会构造一个哈数对象将这些参数捕获后进行返回，这样1，2，3就被放入参数包<code>xs</code>中了。这里会再次调用，<code>apply(z(1, 2, 3), b)</code>，会将'a', 'b', 'c'放入参数包<code>ys</code>中。</p>
<p>Okay，现在<code>xs = (1, 2, 3)</code>，<code>ys = ('a', 'b', 'c')</code>，然后会发生什么呢？<code>tuple_cat(make_tuple(xs, ys) ...)</code>就会完成下图所描述的过程：</p>
<p><img src="./C++17 STL Cook book_files/8-5-1.png" alt=""></p>
<p>首先，<code>xs</code>和<code>ys</code>中的成员将会被zip到一起，也就是交叉配对在一起。这个交叉配对发生在<code>make_tuple(xs, ys)...</code>部分，这会将两个元组组成一个元组。为了获得一个大元组，我们使用了<code>tuple_cat</code>，通过对元组的级联获取一个大的元组，其包含了所有元组中的成员，并进行了交叉配对。</p>
</div></div><div id="ebook-heading-x5c06codevoidcodex66ffx6362x4e3ax66f4x4e3ax5b89x5168x7684stdany" ebook-toc-level-2="" heading="将&lt;code&gt;void*&lt;/code&gt;替换为更为安全的std::any"><div><h1 class="mume-header" id="%E5%B0%86void%E6%9B%BF%E6%8D%A2%E4%B8%BA%E6%9B%B4%E4%B8%BA%E5%AE%89%E5%85%A8%E7%9A%84stdany">将<code>void*</code>替换为更为安全的std::any</h1>

<p>有时我们会需要将一个变量保存在一个未知类型中。对于这样的变量，我们通常会对其进行检查，以确保其是否包含一些信息，如果是包括，那我们将会去判别所包含的内容。以上的所有操作，都需要在一个类型安全的方法中进行。</p>
<p>以前，我们会将可变对象存与<code>void*</code>指针当中。void类型的指针无法告诉我们其所指向的对象类型，所以我们需要将其进行手动转换成我们期望的类型。这样的代码看起来很诡异，并且不安全。</p>
<p>C++17在STL中添加了一个新的类型——<code>std::any</code>。其设计就是用来持有任意类型的变量，并且能提供类型的安全检查和安全访问。</p>
<p>本节中，我们将会来感受一下这种工具类型。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将实现一个函数，这个函数能够打印所有东西。其就使用<code>std::any</code>作为参数：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;any&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了减少后续代码中尖括号中的类型数量，我们对<code>list&lt;int&gt;</code>进行了别名处理：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> int_list <span class="token operator">=</span> list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>让我们实现一个可以打印任何东西的函数。其确定能打印任意类型，并以<code>std::any</code>作为其参数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">print_anything</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>any <span class="token operator">&amp;</span>a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
</pre></li>
<li>
<p>首先，要做的事就是对传入的参数进行检查，确定参数中是否包含任何东西，还是只是一个空实例。如果为空，那就没有必要再进行接下来的打印了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">.</span><span class="token function">has_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Nothing.\n"</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>当非空时，就要需要对其进行类型比较，直至匹配到对应类型。这里第一个类型为<code>string</code>，当传入的参数是一个<code>string</code>，我们可以使用<code>std::any_cast</code>将<code>a</code>转化成一个<code>string</code>类型的引用，然后对其进行打印。我们将双引号当做打印字符串的修饰：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword keyword-typeid">typeid</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It's a string: "</span>
        	<span class="token operator">&lt;&lt;</span> <span class="token function">quoted</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">any_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> string<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>当其不是<code>string</code>类型时，其也可能是一个<code>int</code>类型。当与之匹配是使用<code>any_cast&lt;int&gt;</code>将<code>a</code>转换成<code>int</code>型数值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword keyword-typeid">typeid</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It's an integer: "</span>
    		<span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">any_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>std::any</code>并不只对<code>string</code>和<code>int</code>有效。我们将<code>map</code>或<code>list</code>，或是更加复杂的数据结构放入一个<code>any</code>变量中。让我们输入一个整数列表看看，按照我们的预期，函数也将会打印出相应的列表：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword keyword-typeid">typeid</span><span class="token punctuation">(</span>int_list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token function">l</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">any_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword keyword-const">const</span> int_list<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It's a list: "</span><span class="token punctuation">;</span>
        <span class="token function">copy</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span>
        	ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>如果没有类型能与之匹配，那就不会进行猜测了。我们会放弃对类型进行匹配，然后告诉使用者，我们对输入毫无办法：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Can't handle this item.\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们能够对调用函数传入任何类型的值。我们可以使用大括号对来构建一个空的<code>any</code>变量，或是直接输入字符串“abc”，或是一个整数。因为<code>std::any</code>可以由任何类型隐式转换而成，这里并没有语法上的开销。我们也可以直接构造一个列表，然后丢入函数中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">print_anything</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_anything</span><span class="token punctuation">(</span><span class="token string">"abc"</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_anything</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_anything</span><span class="token punctuation">(</span>int_list<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>当我们想要传入的参数比较大，那么拷贝到<code>any</code>变量中就会花费很长的时间，这是可以使用立即构造的方式。<code>in_place_type_t&lt;int_list&gt;{}</code>表示一个空的对象，对于<code>any</code>来说其就能够知道应该如何去构建对象了。第二个参数为<code>{1,2,3}</code>其为一个初始化列表，其会用来初始化<code>int_list</code>对象，然后被转换成<code>any</code>变量。这样，我们就避免了不必要的拷贝和移动：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">print_anything</span><span class="token punctuation">(</span><span class="token function">any</span><span class="token punctuation">(</span>in_place_type_t<span class="token operator">&lt;</span>int_list<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们将得到如下的输入出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>any
Nothing<span class="token punctuation">.</span>
It<span class="token number">'</span>s a string<span class="token operator">:</span> <span class="token string">"abc"</span>
It<span class="token number">'</span>s an integer<span class="token operator">:</span> <span class="token number">123</span>
It<span class="token number">'</span>s a list<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span>
It<span class="token number">'</span>s a list<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>std::any</code>类型与<code>std::optional</code>类型很类似——具有一个<code>has_value()</code>成员函数，能告诉我们其是否携带一个值。不过这里，我们还需要对字面的数据进行保存，所以<code>any</code>要比<code>optional</code>类型复杂的多。</p>
<p>访问any变量的内容前，我们需要知道其所承载的类型，然后将<code>any</code>变量转换成那种类型。</p>
<p>这里，使用的比较方式为<code>x.type == typeid(T)</code>。如果比较结果匹配，那么就使用<code>any_cast</code>对其内容进行转换。</p>
<p>需要注意的是<code>any_cast&lt;T&gt;(x)</code>将会返回<code>x</code>中<code>T</code>值的副本。如果想要避免对复杂对象不必要的拷贝，那就需要使用<code>any_cast&lt;T&amp;&gt;(x)</code>。本节的代码中，我们使用引用的方式来获取<code>string</code>和<code>list&lt;int&gt;</code>对象的值。</p>
<blockquote>
<p>Note：</p>
<p>如果<code>any</code>变量转换成为一种错误的类型，其将会抛出<code>std::bad_any_cast</code>异常。</p>
</blockquote>
</div></div><div id="ebook-heading-x5b58x50a8x4e0dx540cx7684x7c7bx578bx2014x2014stdvariant" ebook-toc-level-2="" heading="存储不同的类型——std::variant"><div><h1 class="mume-header" id="%E5%AD%98%E5%82%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E5%9E%8Bstdvariant">存储不同的类型——std::variant</h1>

<p>C++中支持使用<code>struct</code>和<code>class</code>的方式将不同类型的变量进行包装。当我们想要使用一种类型来表示多种类型时，也可以使用<code>union</code>。不过<code>union</code>的问题在于我们无法知道，其是以哪种类型为基础进行的初始化。</p>
<p>看一下下面的代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-union">union</span> U <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token keyword keyword-float">float</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">func</span><span class="token punctuation">(</span>U u<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> u<span class="token punctuation">.</span>b <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>	
</pre><p>当我们调用<code>func</code>时，其会将已整型<code>a</code>为基础进行初始化的联合体<code>t</code>进行打印，当然也无法阻止我们对其他成员进行访问，就像使用字符串指针对成员<code>b</code>进行初始化了一样，这段代码会引发各种bug。当我们开始对联合体进行打包之前，有一种辅助变量能够告诉我们其对联合体进行的初始化是安全的，其就是<code>std::variant</code>，在C++17中加入STL。</p>
<p><code>variant</code>是一种新的类型，类型安全，并高效的联合体类型。其不使用堆上的内存，所以在时间和空间上都非常高效。基于联合体的解决方案，我们就不用自己再去进行实现了。其能单独存储引用、数组或<code>void</code>类型的成员变量。</p>
<p>本节中，我们将会了解一下由<code>vriant</code>带来的好处。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们实现一个程序，其中有两个类型：<code>cat</code>和<code>dog</code>。然后将猫狗混合的存储于一个列表中，这个列表并不具备任何运行时多态性：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;variant&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>接下来，我们将实现两个具有类似功能的类，不过两个类型之间并没有什么联系。第一个类型是<code>cat</code>。<code>cat</code>对象具有名字，并能喵喵叫：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">cat</span> <span class="token punctuation">{</span>
    string name<span class="token punctuation">;</span>
    
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">cat</span><span class="token punctuation">(</span>string n<span class="token punctuation">)</span> <span class="token operator">:</span> name<span class="token punctuation">{</span>n<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token keyword keyword-void">void</span> <span class="token function">meow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">" says Meow!\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>另一个类是<code>dog</code>。<code>dog</code>能汪汪叫：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">dog</span> <span class="token punctuation">{</span>
	string name<span class="token punctuation">;</span>
    
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
	<span class="token function">dog</span><span class="token punctuation">(</span>string n<span class="token punctuation">)</span> <span class="token operator">:</span> name<span class="token punctuation">{</span>n<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
	<span class="token keyword keyword-void">void</span> <span class="token function">woof</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span>
		cout <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">" says Woof!\n"</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们就可以来定义一个<code>animal</code>类型，其为<code>std::variant&lt;dog, cat&gt;</code>的别名类型。其和以前的联合体一样，同时具有<code>variant</code>的特性：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> animal <span class="token operator">=</span> variant<span class="token operator">&lt;</span>dog<span class="token punctuation">,</span> cat<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>编写主函数之前，我们再来实现两个辅助者。其中之一为动物判断谓词，通过调用<code>is_type&lt;cat&gt;(...)</code>或<code>is_type&lt;dog&gt;(...)</code>，可以判断动物实例中的动物为<code>cat</code>或<code>dog</code>。其实现只需要对<code>holds_alternative</code>进行调用即可，其为<code>variant</code>类型的一个通用谓词函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-bool">bool</span> <span class="token function">is_type</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> animal <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token generic-function"><span class="token function">holds_alternative</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>第二个辅助者为一个结构体，其看起来像是一个函数对象。其实际是一个双重函数对象，因为其<code>operator()</code>实现了两次。一种实现是接受<code>dog</code>作为参数输入，另一个实现是接受<code>cat</code>类型作为参数输入。对于两种实现，其会调用<code>woof</code>或<code>meow</code>函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">animal_voice</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> dog <span class="token operator">&amp;</span>d<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> d<span class="token punctuation">.</span><span class="token function">woof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> cat <span class="token operator">&amp;</span>c<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">meow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在让我们使用这些辅助者和类型。首先，定义一个<code>animal</code>变量的实例，然后对其进行填充：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	list<span class="token operator">&lt;</span>animal<span class="token operator">&gt;</span> l <span class="token punctuation">{</span>cat<span class="token punctuation">{</span><span class="token string">"Tuba"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> dog<span class="token punctuation">{</span><span class="token string">"Balou"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> cat<span class="token punctuation">{</span><span class="token string">"Bobby"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，我们会将列表的中内容打印三次，并且每次都使用不同的方式。第一种使用<code>variant::index()</code>。因为<code>animal</code>类型是<code>variant&lt;dog, cat&gt;</code>类型的别名，其返回值的0号索引代表了一个<code>dog</code>的实例。1号索引则代表了<code>cat</code>的实例。这里的关键是变量特化的顺序。<code>switch-cast</code>代码块中，可以通过<code>get&lt;T&gt;</code>的方式获取内部的<code>cat</code>或<code>dog</code>实例：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">   <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> animal <span class="token operator">&amp;</span>a <span class="token operator">:</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword keyword-switch">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword keyword-case">case</span> <span class="token number">0</span><span class="token operator">:</span>
           <span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>dog<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">woof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
       <span class="token keyword keyword-case">case</span> <span class="token number">1</span><span class="token operator">:</span>
           <span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>cat<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">meow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"-----\n"</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们也可以显示的使用类型作为其索引。<code>get_if&lt;dog&gt;</code>会返回一个指向<code>dog</code>类型的指针。如果没有<code>dog</code>实例在列表中，那么指针则为<code>null</code>。这样，我们可以尝试获取下一种不同类型的实例，直到成功为止：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> animal <span class="token operator">&amp;</span>a <span class="token operator">:</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">d</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">get_if</span><span class="token generic class-name"><span class="token operator">&lt;</span>dog<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	d<span class="token operator">-&gt;</span><span class="token function">woof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">c</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">get_if</span><span class="token generic class-name"><span class="token operator">&lt;</span>cat<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	c<span class="token operator">-&gt;</span><span class="token function">meow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"-----\n"</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>使用<code>variant::visit</code>是一种非常优雅的方式。这个函数能够接受一个函数对象和一个<code>variant</code>实例。函数对象需要对<code>variant</code>中所有可能类型进行重载。我们在之前已经对<code>operator()</code>进行了重载，所以这里可以直接对其进行使用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> animal <span class="token operator">&amp;</span>a <span class="token operator">:</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">visit</span><span class="token punctuation">(</span>animal_voice<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"-----\n"</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>最后，我们将回来数一下<code>cat</code>和<code>dog</code>在列表中的数量。<code>is_type&lt;T&gt;</code>的<code>cat</code>和<code>dog</code>特化函数，将会与<code>std::count_if</code>结合起来使用，用来返回列表中不同实例的个数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"There are "</span>
        <span class="token operator">&lt;&lt;</span> <span class="token function">count_if</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span> is_type<span class="token operator">&lt;</span>cat<span class="token operator">&gt;</span><span class="token punctuation">)</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">" cats and "</span>
        <span class="token operator">&lt;&lt;</span> <span class="token function">count_if</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span> is_type<span class="token operator">&lt;</span>dog<span class="token operator">&gt;</span><span class="token punctuation">)</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">" dogs in the list.\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就会看到打印三次的结果都是相同的。然后，可以看到<code>is_type</code>和<code>count_if</code>配合的很不错：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>variant
Tuba says Meow<span class="token operator">!</span>
Balou says Woof<span class="token operator">!</span>
Bobby says Meow<span class="token operator">!</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
Tuba says Meow<span class="token operator">!</span>
Balou says Woof<span class="token operator">!</span>
Bobby says Meow<span class="token operator">!</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
Tuba says Meow<span class="token operator">!</span>
Balou says Woof<span class="token operator">!</span>
Bobby says Meow<span class="token operator">!</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
There are <span class="token number">2</span> cats <span class="token operator">and</span> <span class="token number">1</span> dogs in the list<span class="token punctuation">.</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>std::variant</code>与<code>std::any</code>类型很相似，因为这两个类型都能持有不同类型的变量，并且我们需要在运行时对不同对象进行区分。</p>
<p>另外，<code>std::variant</code>有一个模板列表，需要传入可能在列表中的类型，这点与<code>std::any</code>截然不同。也就是说<code>std::variant&lt;A, B, C&gt;</code>必须是A、B或C其中一种实例。当然这也意味着其就不能持有其他类型的变量，除了列表中的类型<code>std::variant</code>没有其他选择。</p>
<p><code>variant&lt;A, B, C&gt;</code>的类型定义，与以下联合体定义类似：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-union">union</span> U <span class="token punctuation">{</span>
   A a<span class="token punctuation">;</span>
   B b<span class="token punctuation">;</span>
   C c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>当我们对<code>a</code>, <code>b</code>或<code>c</code>成员变量进行初始化时，联合体中对其进行构建机制需要我们自行区分。<code>std::variant</code>类型就没有这个问题。</p>
<p>本节的代码中，我们使用了三种方式来处理<code>variant</code>中成员的内容。</p>
<p>首先，使用了<code>variant</code>的<code>index()</code>成员函数。对变量类型进行索引，<code>variant&lt;A, B, C&gt;</code> 中，索引值0代表A类型，1为B类型，2为C类型，以此类推来访问复杂的<code>variant</code>对象。</p>
<p>下一种就是使用<code>get_if&lt;T&gt;</code>函数进行获取。其能接受一个<code>variant</code>对象的地址，并且返回一个类型<code>T</code>的指针，指向其内容。如果<code>T</code>类型是错误，那么返回的指针就为<code>null</code>指针。其也可能对<code>variant</code>变量使用<code>get&lt;T&gt;(x)</code>来获取对其内容的引用，不过当这样做失败时，函数将会抛出一个异常(使用get-系列函数进行转换之前，需要使用<code>holds_alternative&lt;T&gt;(x)</code>对其类型进行检查)。</p>
<p>最后一种方式就是使用<code>std::visit</code>函数来进行，其能接受一个函数对象和一个<code>variant</code>实例。<code>visit</code>函数会对<code>variant</code>中内容的类型进行检查，然后调用对应的函数对象的重载<code>operator()</code>操作符。</p>
<p>为了这个目的，我们实现为了<code>animal_voice</code>类型，将<code>visit</code>和<code>variant&lt;dog, cat&gt;</code>类型结合在了一起：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">animal_voice</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> dog <span class="token operator">&amp;</span>d<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> d<span class="token punctuation">.</span><span class="token function">woof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> cat <span class="token operator">&amp;</span>c<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">meow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>以<code>visit</code>的方式对<code>variant</code>进行访问看起来更加的优雅一些，因为使用这种方法就不需要使用硬编码的方式对<code>variant</code>内容中的类型进行判别。这就让我们的代码更加容易扩展。</p>
<blockquote>
<p>Note：</p>
<p><code>variant</code>类型不能为空的说法并不完全正确。将<a href="http://zh.cppreference.com/w/cpp/utility/variant/monostate">std::monostate</a>类型添加到其类型列表中，其就能持有空值了。</p>
</blockquote>
</div></div><div id="ebook-heading-x81eax52a8x5316x7ba1x7406x8d44x6e90x2014x2014stdunique_ptr" ebook-toc-level-2="" heading="自动化管理资源——std::unique_ptr"><div><h1 class="mume-header" id="%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90stdunique_ptr">自动化管理资源——std::unique_ptr</h1>

<p>C++11之后，STL提供了新的智能指针，能对动态内存进行跟踪管理。C++11之前，C++中也有一个智能指针<code>auto_ptr</code>，也能对内存进行管理，但是很容易被用错。</p>
<p>不过，使用C++11添加的智能指针的话，我们就很少需要使用到<code>new</code>和<code>delete</code>操作符。智能指针是自动化内存管理的一个鲜活的例子。当我们使用<code>unique_ptr</code>来动态分配对象，基本上不会遇到内存泄漏，因为在析构时会自动的为其所拥有内存使用<code>delete</code>操作。</p>
<p>唯一指针表达了其对对象指针的所有权，当对这段内存不在进行使用时，我们会将相关的对象所具有的内存进行释放。这个类将让我们永远远离内存泄漏(智能指针还有<code>shared_ptr</code>和<code>weak_ptr</code>，不过本节中，我们只关注于<code>unique_ptr</code>)。其不会多占用空间，并且不会影响运行时性能，这相较于原始的裸指针和手动内存管理来说十分便捷。(当我们对相应的对象进行销毁后，其内部的裸指针将会被设置为<code>nullptr</code>)。</p>
<p>本节中，我们将来看一下<code>unique_ptr</code>如何使用。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将创建一个自定义的类型，在构造和析构函数中添加一些调试打印信息，之后展示<code>unique_ptr</code>如何对内存进行管理。我们将使用<code>unique</code>指针，并使用动态分配的方式对其进行实例化：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将实现一个小类型，后面会使用<code>unque_ptr</code>对其实例进行管理。其构造函数和析构函数都会在终端上打印相应的信息，所以之后的自动删除中，我们会看到相应输出的打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    string name<span class="token punctuation">;</span>
    
    <span class="token function">Foo</span><span class="token punctuation">(</span>string n<span class="token punctuation">)</span>
    	<span class="token operator">:</span> name<span class="token punctuation">{</span><span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CTOR "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"DTOR "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了了解函数对唯一指针在作为参数传入函数的限制，我们可以实现一个这样的函数。其能处理一个<code>Foo</code>类型实例，并能将其名称进行打印。注意，<code>unique</code>指针是非常智能的，其无额外开销，并且类型安全，也可以为<code>null</code>。这就意味着我们仍然要在解引用之前，对指针进行检查：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">process_item</span><span class="token punctuation">(</span>unique_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Processing "</span> <span class="token operator">&lt;&lt;</span> p<span class="token operator">-&gt;</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们将开辟一个代码段，在堆上创建两个<code>Foo</code>对象，并且使用<code>unique</code>指针对内存进行管理。我们显式的使用<code>new</code>操作符创建第一个对象实例，并且将其用来创建<code>unique_ptr&lt;Foo&gt;</code>变量<code>p1</code>。我们通过<code>make_unique&lt;Foo&gt;</code>的调用来创建第二个<code>unique</code>指针<code>p2</code>，我们直接传入参数对<code>Foo</code>实例进行构建。这种方式更加的优雅，因为我们使用<code>auto</code>类型对类型进行推理，并且能在第一时间对对象进行访问，并且其已经使用<code>unique_ptr</code>进行管理：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        unique_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> p1 <span class="token punctuation">{</span><span class="token keyword keyword-new">new</span> Foo<span class="token punctuation">{</span><span class="token string">"foo"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">p2</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>离开这个代码段时，所创建的对象将会立即销毁，并且将内存进行释放。让我们来看一下<code>process_item</code>函数和如何使用<code>unique_ptr</code>。当创建一个新的<code>Foo</code>实例时，其就会被<code>unique_ptr</code>进行管理，然后参数的生命周期就在这个函数中。当<code>process_item</code>返回时，这个对象就会被销毁：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">process_item</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"foo1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>如将已经存在的对象传入<code>process_item</code>函数，就需要将指针的所有权进行转移，因为函数需要使用<code>unique_ptr</code>作为输入参数，这就会有一次拷贝。但是，<code>unique_ptr</code>是无法进行拷贝的，其只能移动。现在让我们来创建两个<code>Foo</code>对象，并且将其中一个移动到<code>process_item</code>函数中。通过对输出的查阅，我们可以了解到<code>foo2</code>在<code>process_item</code>返回时会被析构，因为其所有权已经被转移。<code>foo3</code>将会持续留存于主函数中，直到主函数返回时才进行析构：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">p1</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"foo2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">p2</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"foo3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">process_item</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"End of main()\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序。首先，我们将看到<code>foo</code>和<code>bar</code>的构造和析构的输出，离开代码段时就被销毁。我们要注意的是，销毁的顺序与创建的顺序相反。下一个构造的就是<code>foo1</code>，其在对<code>process_item</code>调用时进行创建。当函数返回时，其就会被立即销毁。然后，我们会创建<code>foo2</code>和<code>foo3</code>。因为之前转移了指针的所有权，<code>foo2</code>会在<code>process_item</code>函数调用返回时被立即销毁。另一个元素<code>foo3</code>将会在主函数返回时进行销毁：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>unique_ptr
CTOR foo
CTOR bar
DTOR bar
DTOR foo
CTOR foo1
Processing foo1
DTOR foo1
CTOR foo2
CTOR foo3
Processing foo2
DTOR foo2
End of <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
DTOR foo3
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>使用<code>std::unique_ptr</code>来处理堆上分配的对象非常简单。我们初始化<code>unique</code>指针之后，其就会指向对应的对象，这样程序就能自动的对其进行释放操作。</p>
<p>当我们将<code>unique</code>指针赋予一些新指针时，其就会先删除原先指向的对象，然后再存储新的指针。一个<code>unique</code>指针变量<code>x</code>，我们可以使用<code>x.reset()</code>将其目前所指向的对象进行销毁，然后在指向新的对象。另一种等价方式：<code>x = new_pointer</code>与<code>x.reset(new_pointer)</code>的方式等价。</p>
<blockquote>
<p>Note：</p>
<p>的确只有一种方式对<code>unique_ptr</code>所指向对象的内存进行释放，那就是使用成员函数<code>release</code>，但这种方式并不推荐使用。</p>
</blockquote>
<p>解引用之前，需要对指针进行检查，并且其能使用于裸指针相同的方式进行运算。条件语句类似于<code>if (p){...}</code>和<code>if (p != nullptr){...}</code>，这与我们检查裸指针的方式相同。</p>
<p>解引用一个<code>unique</code>指针可以通过<code>get()</code>函数完成，其会返回一个指向对应对象的裸指针，并且可以直接进行解引用。</p>
<p><code>unique_ptr</code>有一个很重要的特性——实例无法进行拷贝，只能移动。这就是我们会将已经存在的<code>unique</code>指针的所有权转移到<code>process_item</code>参数的原因。当我们想要拷贝<code>unique</code>指针时，就意味着两个<code>unique</code>指针指向相应的对象，这与该指针的设计理念不符，所以<code>unique</code>指针对其指向对象的所有权必须唯一。</p>
<blockquote>
<p>Note：</p>
<p>对于其他的数据类型，由于智能指针的存在，所以很少使用<code>new</code>和<code>delete</code>对其进行手动操作。尽可能的使用智能指针！特别是<code>unqiue_ptr</code>，其在运行时无任何额外开销。</p>
</blockquote>
</div></div><div id="ebook-heading-x5904x7406x5171x4eabx5806x5185x5b58x2014x2014stdshared_ptr" ebook-toc-level-2="" heading="处理共享堆内存——std::shared_ptr"><div><h1 class="mume-header" id="%E5%A4%84%E7%90%86%E5%85%B1%E4%BA%AB%E5%A0%86%E5%86%85%E5%AD%98stdshared_ptr">处理共享堆内存——std::shared_ptr</h1>

<p>上一节中，我们了解了如何使用<code>unique_ptr</code>。这个类型非常有用，能帮助我们管理动态分配的对象。不过，所有权只能让一个类型对象所有，不能让多个对象指向同一个动态分配的对象。</p>
<p>指针类型<code>shared_ptr</code>就是为了应对这种情况所设计的。共享指针可以随时进行拷贝，其内部有一个计数器，记录了有多少对象持有这个指针。只有当最后一个持有者被销毁时，才会对动态分配的对象进行删除。同样，其也不会让我们陷入内存泄漏的窘境，因为对象也会在使用之后进行自动删除。同时，需要确定对象没有过早的被删除，或是删除的过于频繁(每次对象的创建都要进行一次删除)。</p>
<p>本节中，你将了解到如何使用<code>shared_ptr</code>自动的对动态对象进行管理，并且能在多个所有者间共享动态对象，而后了解其与<code>unique_ptr</code>之间的区别：</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将完成一个与<code>unique_ptr</code>节类似的程序，以展示<code>shared_ptr</code>的用法：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>然后定义一个辅助类，其能帮助我们了解类何时创建和销毁。我们将会使用<code>shared_ptr</code>对内存进行管理：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    string name<span class="token punctuation">;</span>
    
    <span class="token function">Foo</span><span class="token punctuation">(</span>string n<span class="token punctuation">)</span>
    	<span class="token operator">:</span> name<span class="token punctuation">{</span><span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CTOR "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"DTOR "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>接下来，我们将实现一个函数<code>Foo</code>，其参数的类型为共享指针。接受共享指针作为参数的方式，要比引用有意思的多，因为这样我们不会进行拷贝，但是会改变共享这指针内部的计数器：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">f</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> sp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f: use counter at "</span>
    	<span class="token operator">&lt;&lt;</span> sp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中声明一个空的共享指针。通过默认构造方式对其进行构造，其实际上是一个<code>null</code>指针：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> fa<span class="token punctuation">;</span>
</pre></li>
<li>
<p>下一步，我们将创建一个代码段，并创建两个<code>Foo</code>对象。使用<code>new</code>操作符对第一个对象进行创建，然后使用构造函数在<code>shared_ptr</code>中创建这一对象。直接使用<code>make_shared&lt;Foo&gt;</code>对第二个实例进行创建，使用我们提供的参数创建一个<code>Foo</code>实例。这种创建的方式很优雅，使用<code>auto</code>进行类型推断，对象也算第一次访问。这里与<code>unique_ptr</code>很类似：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Inner scope begin\n"</span><span class="token punctuation">;</span>
        
        shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> f1 <span class="token punctuation">{</span><span class="token keyword keyword-new">new</span> Foo<span class="token punctuation">{</span><span class="token string">"foo"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">f2</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>当共享指针被共享时，需要记录有多少个指针共享了这个对象。这需要内部引用计数器或使用独立计数器完成，我们可以使用<code>use_count</code>将这个值进行输出。现在其值为1，因为其还没进行拷贝。我们可以<code>f1</code>拷贝到<code>fa</code>，其计数值将会为2。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f1's use counter at "</span> <span class="token operator">&lt;&lt;</span> f1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
	fa <span class="token operator">=</span> f1<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f1's use counter at "</span> <span class="token operator">&lt;&lt;</span> f1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>离开这个代码段时，共享指针<code>f1</code>和<code>f2</code>将会被销毁。<code>f1</code>变量引用计数将会减少1，现在只有<code>fa</code>拥有这个<code>Foo</code>实例。当<code>f2</code>被回收时，其引用计数将减为0。因此，<code>shared_ptr</code>指针将对对象进行销毁：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Back to outer scope\n"</span><span class="token punctuation">;</span>
    
	cout <span class="token operator">&lt;&lt;</span> fa<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，让我们用两种方式调用<code>f</code>函数。第一种，我们使用直接拷贝<code>fa</code>的方式。<code>f</code>函数将会将引用计数输出，值为2。在第二次对<code>f</code>的调用时，我们将指针移动到函数中。现在只有<code>f</code>函数对其指向的对象具有所有权：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first f() call\n"</span><span class="token punctuation">;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>fa<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"second f() call\n"</span><span class="token punctuation">;</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>fa<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>f</code>返回之后，<code>Foo</code>实例就被立即销毁，因为没有任何指针对其有所有权。因此，在主函数返回前，所有对象就都会被销毁：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end of main()\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序就会得到如下输出。起初，我们可以看到<code>foo</code>和<code>bar</code>被创建。然后指针的副本<code>f1</code>出现(其指向<code>foo</code>实例)，引用计数增加到2。当离开代码段时，因为没有任何指针在对指向<code>bar</code>实例的共享指针具有所有权，所以其会自动进行销毁。现在<code>fa</code>的引用计数为1，因为现在只有<code>fa</code>对<code>foo</code>对象具有所有权。之后，我们调用了两次<code>f</code>函数。第一次调用，我们对<code>fa</code>进行了拷贝，会再次将引用计数增为2。第二次调用时，我们将<code>fa</code>移动到<code>f</code>中，其对引用计数的数值并无影响。此外，因为<code>f</code>函数具有了<code>foo</code>对象指针的所有权，所以当<code>f</code>函数结束时，<code>foo</code>对象就自动销毁了。主函数打印出最后一行前，堆上分配的动态对象就会被全部销毁：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>shared_ptr
Inner scope begin
CTOR foo
CTOR bar
f1<span class="token number">'</span>s use counter at <span class="token number">1</span>
f1<span class="token number">'</span>s use counter at <span class="token number">2</span>
DTOR bar
Back to outer scope
<span class="token number">1</span>
first <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> call
f<span class="token operator">:</span> use counter at <span class="token number">2</span>
second <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> call
f<span class="token operator">:</span> use counter at <span class="token number">1</span>
DTOR foo
end of <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</pre><h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>shared_ptr</code>的工作方式与<code>unique_ptr</code>的类似。构造共享指针和唯一指针的方法也非常类似(使用<code>make_shared</code>函数创建共享对象的指针，使用<code>make_unique</code>创建<code>unique_pointer</code>)。</p>
<p><code>unique_ptr</code>和<code>shared_pointer</code>的最大区别在于可复制性上，因为共享指针内部具有一块控制区域(control block)，其中有用来管理对象的指针，还有一个计数器。当有N个<code>shared_ptr</code>实例指向某个对象时，其内部的计数器的值就为N。当<code>shared_ptr</code>实例销毁时，内部计数器会减1。当没有指针对对象具有所有权时，计数器的值即为0，对象就会被自动销毁。这样我们就不用担心内存泄漏了。</p>
<p>为了更加形象的说明，我们来看一下下面的图：</p>
<p><img src="./C++17 STL Cook book_files/8-9-1.png" alt=""></p>
<p>第1步中，我们具有两<code>shared_ptr</code>实例用于管理<code>Foo</code>类型的一个对象。所以其引用个数为2。然后，<code>shared_ptr2</code>被销毁，计数就会变为1。因为还有指针指向其实例，所以<code>Foo</code>对象并未被销毁。第3步中，最后一个共享指针也被销毁了，这就导致引用计数为0。第4步会很快在第3步之后发生，所有控制块和<code>Foo</code>实例都会被销毁，并且其内存也会在堆上释放。</p>
<p>了解了<code>shared_ptr</code>和<code>unique_ptr</code>，我们将能很容易的对动态分配的对象进行管理，并且不用担心出现内存泄漏。不过，这里有个忠告——共享指针避免在循环引用的指针间进行，这样会让计数器无法归零，导致内存泄漏。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>来看一下下面的代码。你能告诉我这段代码是否会发生内存泄漏吗？</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">function</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span><span class="token punctuation">,</span> shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// "function" is defined somewhere else</span>

<span class="token comment">// ...somewhere later in the code:</span>
<span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword keyword-new">new</span> B<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">other_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>你可能会反问我，“怎么可能有内存泄漏呢？”，A和B在分配后就放入<code>shared_ptr</code>类型中，并且其之后会进行释放，所以不会有内存泄漏。</p>
<p>你说的没错，当我们确定<code>shared_ptr</code>实例获取了对应的指针时，那么我们不会遇到内存泄漏。不过这个问题又好像有点琢磨不透。</p>
<p>我们调用函数<code>f(x(), y(), z())</code>时，编译器需要在f前找到<code>x</code>，<code>y</code>，<code>z</code>函数的定义，并先运行这些函数，然后将其返回值传入<code>f</code>函数中。结合我们上面的例子来说的话，对于编译器来说执行<code>x</code>，<code>y</code>和<code>z</code>函数的顺序并没有被规定。</p>
<p>回看下我们给出的例子，当编译器决定首先进行<code>new A{}</code>的操作，然后进行<code>other_function()</code>，再进行<code>new B{}</code>操作时，那么能确保这些操作的结果会传到<code>function</code>中吗？当<code>other_function()</code>抛出一个异常，因为没有使用<code>shared_ptr</code>对A进行管理，所以会造成内存泄漏。无论我们如何捕获这个异常，对这个对象的处理机会已经不在，我们无法将其删除。</p>
<p>这里有两种方法可以规避这个问题：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token comment">// 1.)</span>
<span class="token function">function</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">other_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2.)</span>
shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> ap <span class="token punctuation">{</span><span class="token keyword keyword-new">new</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> bp <span class="token punctuation">{</span><span class="token keyword keyword-new">new</span> B<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">function</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> bp<span class="token punctuation">,</span> <span class="token function">other_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>这样，对象在传入函数之前就被<code>shared_ptr</code>所保管，也就无所谓函数是否会在中途抛出异常了。</p>
</div></div><div id="ebook-heading-x5bf9x5171x4eabx5bf9x8c61x4f7fx7528x5f31x6307x9488" ebook-toc-level-2="" heading="对共享对象使用弱指针"><div><h1 class="mume-header" id="%E5%AF%B9%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%BC%B1%E6%8C%87%E9%92%88">对共享对象使用弱指针</h1>

<p>本节和<code>shared_ptr</code>有关，我们已经了解了如何使用共享指针。和<code>unique_ptr</code>一样，其提升了C++对动态分配对象的管理能力。</p>
<p>拷贝<code>shared_ptr</code>时，我们会将内部计数器加1。当持有共享指针的拷贝时，其指向的对象则不会被删除。但是，当使用某种弱指针时，其能像普通指针一样对指向对象进行操作，但依旧能让所指向对象被销毁？然而，销毁之后我们应该如何确定对象是否存在呢？</p>
<p>这种情况下<code>weak_ptr</code>就是我们最佳的选择。其相对于<code>unique_ptr</code>和<code>shared_ptr</code>来说有些复杂，但是在本节随后的内容中，我们将会对其进行使用。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将使用<code>shared_ptr</code>对一个实例进行管理，然后我们将<code>weak_ptr</code>混入其中，从而了解对<code>weak_ptr</code>的操作对智能指针的内存处理有何影响：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>接下来，我们将实现一个类，将在析构函数的实现中进行打印。当类型被析构时，我们可以从打印输出进行判断：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> value<span class="token punctuation">;</span>
    
    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> value<span class="token punctuation">{</span>i<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"DTOR Foo "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>让我们来实现一个函数用于对弱指针的信息进行打印，这样我们就可以了解弱指针不同指向时的状态。<code>expired</code>成员函数会告诉我们，弱指针指向的对象是否依旧存在，因为使用弱指针持有这个对象并无法让其生命周期延长！<code>use_count</code>计数器告诉我们，当前<code>shared_ptr</code>实例中对象的引用次数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">weak_ptr_info</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> weak_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---------"</span> <span class="token operator">&lt;&lt;</span> boolalpha
        <span class="token operator">&lt;&lt;</span> <span class="token string">"\nexpired: "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">"\nuse_count: "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">"\ncontent: "</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>当我们要访问一个实际对象时，需要调用<code>lock</code>函数，会返回一个指向对象的共享指针。当对象不存在时，返回的共享指针则是一个空指针。我们将对其进行检查，然后对其进行访问：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">sp</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> sp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> sp<span class="token operator">-&gt;</span>value <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&lt;null&gt;\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中实例化一个空的弱指针，并且对其内容进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    weak_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> weak_foo<span class="token punctuation">;</span>
    <span class="token function">weak_ptr_info</span><span class="token punctuation">(</span>weak_foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>新的代码段中，使用<code>Foo</code>类实例化了一个共享指针，再将其拷贝给弱指针。需要注意的是，这个操作并不会对共享指针的引用计数有任何影响。其引用计数依旧为1，因为只有共享指针对其具有所有权：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token punctuation">{</span>
		<span class="token keyword keyword-auto">auto</span> <span class="token function">shared_foo</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">1337</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		weak_foo <span class="token operator">=</span> shared_foo<span class="token punctuation">;</span>
</pre></li>
<li>
<p>离开代码段前，我们对弱指针的状态进行打印；离开时候，再打印一次。虽然弱指针依旧指向<code>Foo</code>的对象，但是<code>Foo</code>实例还是会在离开代码段时立即被销毁：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        <span class="token function">weak_ptr_info</span><span class="token punctuation">(</span>weak_foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">weak_ptr_info</span><span class="token punctuation">(</span>weak_foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就会看到<code>weak_ptr_info</code>函数的输出。第一次，是弱指针为空的时候。第二次，是其指向我们创建的<code>Foo</code>实例，并在弱指针锁定后对其进行解引用。第三次调用之前，我们离开了内部代码区域，会触发<code>Foo</code>类型的析构。之后，我们就无法通过弱指针获取已经删除的<code>Foo</code>对象，并且在这时弱指针也意识到，原先指向的对象已经不存在了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>weak_ptr
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
expired<span class="token operator">:</span> <span class="token boolean">true</span>
use_count<span class="token operator">:</span> <span class="token number">0</span>
content<span class="token operator">:</span> <span class="token operator">&lt;</span>null<span class="token operator">&gt;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
expired<span class="token operator">:</span> <span class="token boolean">false</span>
use_count<span class="token operator">:</span> <span class="token number">1</span>
content<span class="token operator">:</span> <span class="token number">1337</span>
DTOR Foo <span class="token number">1337</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
expired<span class="token operator">:</span> <span class="token boolean">true</span>
use_count<span class="token operator">:</span> <span class="token number">0</span>
content<span class="token operator">:</span> <span class="token operator">&lt;</span>null<span class="token operator">&gt;</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>弱指针为我们提供了一种指向共享指针对象，但不会增加其引用计数的方式。Okay，一个裸指针也可以做这样的事，不过裸指针无法告诉我们其是否处于悬垂的状态，而弱指针可以！</p>
<p>为了能更好的了解弱指针为共享指针添加的功能，我们画了一张图供大家参考：</p>
<p><img src="./C++17 STL Cook book_files/8-10-1.png" alt=""></p>
<p>流程与共享指针的图类似。第1步中，我们有两个共享指针和一个弱指针，都指向<code>Foo</code>类型的实例。虽然有三个指针指向这个对象，但是其共享指针引用数依旧为2，弱指针在控制块有属于自己的计数器。第2和3步中，共享指针的实例被销毁，这步将会让引用计数归0。第4步，<code>Foo</code>对象也被销毁了，不过控制块依旧存在。因为弱指针依旧需要控制块来对其是否悬垂进行判断。只有当最后一个指向对象的弱指针被销毁，那么控制块才会被销毁。</p>
<p>也可以说处于悬垂状态的弱指针是无效的。为了对这个属性进行检查，我们可以调用<code>weak_ptr</code>指针的<code>expired</code>成员函数，其将会为我们返回一个布尔值。当其返回true时，我们就不能对这个弱指针进行解引用，因为其说明这个对象已经不存在了。</p>
<p>为了对弱指针解引用，我们需要调用<code>lock()</code>函数。这是种安全和方便的方法，因为函数返回给我们一个共享指针。当持有这个共享指针时，我们对其进行了锁定，所以这时对象的计数器无法进行变化。<code>lock()</code>之后，对象被删除，我们将会得到一个空的共享指针。</p>
</div></div><div id="ebook-heading-x4f7fx7528x667ax80fdx6307x9488x7b80x5316x5904x7406x9057x7559api" ebook-toc-level-2="" heading="使用智能指针简化处理遗留API"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E5%8C%96%E5%A4%84%E7%90%86%E9%81%97%E7%95%99api">使用智能指针简化处理遗留API</h1>

<p>智能指针(<code>unique_ptr</code>，<code>shared_ptr</code>和<code>weak_ptr</code>)非常有用，并且对于开发者来说，可以使用其来代替手动分配和释放空间。</p>
<p>当有对象不能使用<code>new</code>操作进行创建，或不能使用<code>delete</code>进行释放呢？过去有很多库都有自己的分配和释放函数。这看起来好像是个问题，因为我么了解的智能指针都依赖于<code>new</code>和<code>delete</code>。那么如何在智能指针中，使用指定的工厂函数对特定类型的对象进行创建或是销毁呢？</p>
<p>这个问题一点都不难。本节中，我们将来了解一下如何为智能指针指定特定的分配器和销毁器。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将定义一种不能使用<code>new</code>创建的类型，并且也不能使用<code>delete</code>进行释放。对于这种限制，我们依旧选择直接使用智能指针，这里使用<code>unique_ptr</code>和<code>shared_ptr</code>实例来进行演示。</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>声明一个类，将其构造函数和析构函数声明为<code>private</code>。我们使用这样的方式来模拟无法直接和销毁对象实例的情况：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-class">class</span> <span class="token class-name">Foo</span>
<span class="token punctuation">{</span>
    string name<span class="token punctuation">;</span>
    
    <span class="token function">Foo</span><span class="token punctuation">(</span>string n<span class="token punctuation">)</span>
    	<span class="token operator">:</span> name<span class="token punctuation">{</span>n<span class="token punctuation">}</span>
    <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CTOR "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"DTOR "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</pre></li>
<li>
<p>然后，声明两个静态函数<code>create_foo</code>和<code>destroy_foo</code>，这两个函数用来对<code>Foo</code>实例进行创建和销毁，其会对裸指针进行操作。这是用来模拟使用旧C风格的API，这样我们就不能用之前的方式直接对<code>shared_ptr</code>指针进行使用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-static">static</span> Foo<span class="token operator">*</span> <span class="token function">create_foo</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token keyword keyword-new">new</span> Foo<span class="token punctuation">{</span><span class="token function">move</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">destroy_foo</span><span class="token punctuation">(</span>Foo <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-delete">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，我们用<code>shared_ptr</code>来对这样的对象进行管理。对于共享指针，我们可以通过<code>create_foo</code>函数来构造相应的对象。只有销毁的方式有些问题，因为<code>shared_ptr</code>默认的销毁方式会有问题。解决方法就是我们将自定义的销毁器给予<code>shared_ptr</code>。删除函数或删除可调用对象的函数签名需要需要与<code>destroy_foo</code>函数统一。当我们的删除函数非常复杂，那我们可以使用Lambda表达式对其进行包装：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> <span class="token function">make_shared_foo</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token class-name">Foo</span><span class="token double-colon punctuation">::</span><span class="token function">create_foo</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Foo<span class="token double-colon punctuation">::</span>destroy_foo<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>需要注意的是<code>make_shared_foo</code>函数，将会返回一个普通的<code>shared_ptr&lt;Foo&gt;</code>实例，因为设置了自定义的销毁器，并不会对其类型有所影响。从编程角度上，之前是因为<code>shared_ptr</code>调用了虚函数，将设置销毁器的步骤隐藏了。唯一指针(<code>unique_ptr</code>)不会带来任何额外开销，所以这种方式不适合唯一指针。目前，我们就需要对<code>unique_ptr</code>所持有的类型进行修改。我们将<code>void(*)(Foo*)</code>类型作为第二个模板参数传入，其也就是<code>destroy_foo</code>函数的类型：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> unique_ptr<span class="token operator">&lt;</span>Foo<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Foo<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">make_unique_foo</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token class-name">Foo</span><span class="token double-colon punctuation">::</span><span class="token function">create_foo</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Foo<span class="token double-colon punctuation">::</span>destroy_foo<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们直接使用函数对两个智能指针进行实例化。程序的输出中，我们将看到相应的对象会被创建，然后自动销毁：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">ps</span> <span class="token punctuation">(</span><span class="token function">make_shared_foo</span><span class="token punctuation">(</span><span class="token string">"shared Foo instance"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">pu</span> <span class="token punctuation">(</span><span class="token function">make_unique_foo</span><span class="token punctuation">(</span><span class="token string">"unique Foo instance"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就会得到如下输出，输出与我们的期望一致：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>legacy_shared_ptr
CTOR shared Foo instance
CTOR unique Foo instance
DTOR unique Foo instance
DTOR shared Foo instance
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>通常来说，当<code>unique_ptr</code>和<code>shared_ptr</code>要销毁其持有的对象时，只会对内部指针使用<code>delete</code>。本节中，我们的类无法使用C++常用的方式进行创建和销毁。<code>Foo::create_foo</code>函数会返回一个构造好的<code>Foo</code>指针，这对于智能指针来说没什么，因为指针指针也可以对裸指针进行管理。</p>
<p>其问题在于，当对象不能使用默认方式删除时，如何让<code>unique_ptr</code>和<code>shared_ptr</code>接触到对象的析构函数。</p>
<p>在这方面，两种智能指针有些不同。为了为<code>unique_ptr</code>设置一个自定义销毁器，我们需要对其类型进行修改。因为<code>Foo</code>的销毁函数为<code>void Foo::destroy_foo(Foo*);</code>，那么<code>unique_ptr</code>所是有<code>Foo</code>的类型必须为<code>unique_ptr&lt;Foo, void(*)(Foo*)&gt;</code>。现在，<code>unique_ptr</code>也就获取了<code>destroy_foo</code>的指针了，在<code>make_unique_foo</code>函数中其作为构造的第二个模板参数传入。</p>
<p><code>unique_ptr</code>为了自定义销毁器函数，需要对持有类型进行修改，那么为什么<code>shared_ptr</code>就不需要呢？我们也能向<code>shared_ptr</code>的第二个模板参数传入对应的类型的呀。为什么<code>shared_ptr</code>的操作就要比<code>unique_ptr</code>简单呢？</p>
<p>这是因为<code>shared_ptr</code>支持可调用删除器对象，而不用影响共享指针做指向的类型，这种功能在控制块中进行。共享指针的控制块是一个对象的虚函数。这也就意味着标准共享指针的控制块，与给定了自定义的销毁器的共享指针的控制块不同！当我们要让一个唯一指针使用一个自定义销毁器时，就需要改变唯一指针所指向的类型。当我们想让共享指针使用自定义销毁器时，只需要对内部控制块的类型进行修改即可，这种修改的过程对我们是不可见的，因为其不同隐藏在虚函数的函数接口中。</p>
<p>当然，我们可以手动的为<code>unique_ptr</code>做发生在<code>shared_ptr</code>上的事情，不过这会增加运行时的开销。这是我们所不希望看到的，因为<code>unique_ptr</code>能够保证在运行时无任何额外开销。</p>
</div></div><div id="ebook-heading-x5171x4eabx540cx4e00x5bf9x8c61x7684x4e0dx540cx6210x5458" ebook-toc-level-2="" heading="共享同一对象的不同成员"><div><h1 class="mume-header" id="%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8D%E5%90%8C%E6%88%90%E5%91%98">共享同一对象的不同成员</h1>

<p>试想我们在一个共享指针中持有一个组成非常复杂的动态分配对象，然后使用新的线程完成一些特别耗时的任务。当我们想要对共享指针所持有的对象进行释放时，线程很有可能仍旧会对这个对象进行访问。当然，我们并不想把这个非常复杂的对象交给线程，因为这样的设计有违我们的初衷。那么就意味着我们要手动对内存进行管理了么？</p>
<p>非也！这个问题可以由共享指针来解决，指向一个非常大的共享对象。另外，可以在初始化阶段就接管对对象的内存管理任务。</p>
<p>在这个例子中，我们将模拟这样一种情况(为了简单，不使用线程)，让我们来看一下<code>shared_ptr</code>是如何来解决这个问题的。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将定义一个结构体，其中包含了多个成员。然后，我们会使用共享指针来管理这个类型的动态分配实例。对于共享指针来说，不会直接指向这个对象的本身，而会指向其成员：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>定义一个类型，其中包含了不同的成员，将使用共享指针指向这些成员。为了能清晰的了解类型实例何时被创建与销毁，我们让构造和析构函数都打印一些信息：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">person</span> <span class="token punctuation">{</span>
    string name<span class="token punctuation">;</span>
    size_t age<span class="token punctuation">;</span>
    
    <span class="token function">person</span><span class="token punctuation">(</span>string n<span class="token punctuation">,</span> size_t a<span class="token punctuation">)</span>
    	<span class="token operator">:</span> name<span class="token punctuation">{</span><span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> age<span class="token punctuation">{</span>a<span class="token punctuation">}</span>
    <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CTOR "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token operator">~</span><span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"DTOR "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><ol start="3">
<li>
<p>再来创建几个共享指针，用于指向<code>person</code>类型实例中的<code>name</code>和<code>age</code>成员变量：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> shared_name<span class="token punctuation">;</span>
    shared_ptr<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> shared_age<span class="token punctuation">;</span>
</pre></li>
<li>
<p>接下来，创建一个新代码段，并创建一个<code>person</code>对象，并且用共享指针对其进行管理：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token punctuation">{</span>
		<span class="token keyword keyword-auto">auto</span> <span class="token function">sperson</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>person<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"John Doe"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>使用之前定义的两个共享指针，分别指向<code>name</code>和<code>age</code>成员。使用了<code>shared_ptr</code>的特定构造函数，其能接受一个共享指针和一个共享指针持有对象的成员变量。这样就能对整个对象进行管理，但不指向其本身！</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">		shared_name <span class="token operator">=</span> <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>sperson<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sperson<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
		shared_age <span class="token operator">=</span> <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>sperson<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sperson<span class="token operator">-&gt;</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</pre></li>
<li>
<p>离开代码段后，我们将会打印<code>person</code>的<code>name</code>和<code>age</code>的值。这个操作只是用来验证，对象是否依旧存在：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>shared_name
		<span class="token operator">&lt;&lt;</span> <span class="token string">"\nage: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>shared_age <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>	
</pre></li>
<li>
<p>编译并运行程序，我们就是会看到如下的输出。从析构函数的信息中，我们看到通过指向成员的智能指针，打印<code>person</code>的<code>name</code>和<code>age</code>时，对象依旧存在：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>shared_members
CTOR John Doe
name<span class="token operator">:</span> John Doe
age<span class="token operator">:</span><span class="token number">30</span>
DTOR John Doe
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节中，我们首先动态创建了一个<code>person</code>对象，交给共享指针进行管理。然后，我们创建两个智能指针，分别指向<code>person</code>对象的两个成员变量。</p>
<p>为了描述我们创建了一个什么样的情景，可以看一下下面的图：</p>
<p><img src="./C++17 STL Cook book_files/8-12-1.png" alt=""></p>
<p>注意<code>shared_ptr1</code>是直接指向<code>person</code>对象，而<code>shared_name</code>和<code>shared_age</code>则指向的是同一个对象的<code>name</code>和<code>age</code>成员变量。显然，这些指针管理着整个对象的生命周期。可能是因为内部控制块都指为同一个控制块，这样就无所谓是否仅指向对象的子对象了。</p>
<p>这种情况下，控制块中的使用计数为3。<code>person</code>对象在<code>shared_ptr1</code>销毁时，其对象也不会被销毁，因为还有其他指针指向它。</p>
<p>创建指向对象成员的指针的写法，看起来有些奇怪。为了让<code>shared_ptr&lt;string&gt;</code>指向<code>person</code>对象的<code>name</code>成员，我们的代码需要这样写：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">sperson</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>person<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"John Doe"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">sname</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>sperson<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sperson<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>为了得到指向共享对象成员的指针，我们使用成员的类型对共享指针进行特化，以便其能对成员进行访问。这也就是为什么我们在上面的代码中，创建智能指针的部分写成<code>shared_ptr&lt;string&gt;</code>的原因。构造函数中，我们提供了持有<code>person</code>对象的原始共享指针，第二个参数则是新共享指针所要指向对象的地址。</p>
</div></div><div id="ebook-heading-x9009x62e9x5408x9002x7684x5f15x64cex751fx6210x968fx673ax6570" ebook-toc-level-2="" heading="选择合适的引擎生成随机数"><div><h1 class="mume-header" id="%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%BC%95%E6%93%8E%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0">选择合适的引擎生成随机数</h1>

<p>有时我们在写程序的时候需要用随机数，C++11之前开发者通常会使用C函数<code>rand()</code>获取随机数。在C++11之后，STL中添加了一整套随机数生成器，每一个随机数生成器都有自己的特性。</p>
<p>这些生成器并非都是以自解释的方式命名，所以我们要在本节对它们进行了解。本节最后，我们会了解它们有什么不同，哪种情况下应该选择哪一个。不过，这么多生成器，我们不会全部用到。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将实现一个生产者，通过随机生成器画出漂亮的直方图。然后，我们将通过这个生成器运行STL中所有的随机值生成引擎，并且对其产生的结果进行了解。这个程序有很多重复的代码，所以你可以从本书的代码库中直接对源码进行拷贝，这样要比手动输入快得多。</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;random&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;limits&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后，实现一个辅助函数，其能帮助我们将各种类型的随机数生成引擎的结果进行统计。其接受两个参数：一个<code>partitions</code>数和一个<code>samples</code>数。随机生成器的类型是通过模板参数<code>RD</code>定义的。这个函数中做的第一件事，就是给结果数值类型进行别名。我们同样要保证至少要将所有数字分成10份：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">RD</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">histogram</span><span class="token punctuation">(</span>size_t partitions<span class="token punctuation">,</span> size_t samples<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-using">using</span> rand_t <span class="token operator">=</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">RD</span><span class="token double-colon punctuation">::</span>result_type<span class="token punctuation">;</span>
    partitions <span class="token operator">=</span> <span class="token generic-function"><span class="token function">max</span><span class="token generic class-name"><span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>partitions<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>接下来，我们将使用<code>RD</code>类型实例化一个生成器。然后，我们定义一个除数变量<code>div</code>。所有随机数引擎所产生的随机数都在<code>0</code>到<code>RD::max()</code>之间。函数参数<code>partitions</code>，允许我们将生成数分成几类。通过对可能的最大值进行分组，我们就能了解每一类的大小如何：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	RD rd<span class="token punctuation">;</span>
	rand_t <span class="token function">div</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-double">double</span><span class="token punctuation">(</span><span class="token class-name">RD</span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> partitions<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>接着，将使用一个<code>vector</code>对生成数进行计数，与我们类型的个数相同。然后，从随机引擎中获取很多随机值，其个数与<code>samples</code>数一致。<code>rd()</code>表达式会从生成器中得到一个随机数，并且调整内部状态以生成下一个随机数。每个随机数都会与<code>div</code>进行相除，这样我们就得到了其所在类的索引号，然后将<code>vector</code>对应位置的计数器进行加1：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	vector<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> <span class="token function">v</span> <span class="token punctuation">(</span>partitions<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> samples<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token operator">++</span>v<span class="token punctuation">[</span><span class="token function">rd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> div<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
</pre></li>
<li>
<p>现在就有了一个粗粒度的直方图。为了将其进行打印，就要知道实际计数器的值。可以使用<code>max_element</code>算法提取计数器的最大值。然后，将计数器的最大值除以100。这样就可以将所有计数器的值除以<code>max_div</code>，得到的结果就在0到100的范围内，我们要打印多少星号。当计数器最大值小于100时，因为我们采样的数量也不是很多，所以我们使用<code>max</code>函数将被除数的值设置为1：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    rand_t <span class="token function">max_elm</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    rand_t <span class="token function">max_div</span> <span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>max_elm <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token function">rand_t</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>将直方图打印在终端上，每个类都有自己的一行。通过对<code>max_div</code>的除法确定有多少<code>*</code>要进行打印，我们将会在终端上得到一段固定长度的直方图打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> partitions<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span>
        	<span class="token operator">&lt;&lt;</span> <span class="token function">string</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> max_div<span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在可以来完成主函数了。我们让用户来确定分成多少类，并对多少数进行采样：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Usage: "</span> <span class="token operator">&lt;&lt;</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        	<span class="token operator">&lt;&lt;</span> <span class="token string">" &lt;partitions&gt; &lt;samples&gt;\n"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>然后，就可以从命令行来获取这两个值。当然，从命令行获取到的是字符串，我们需要使用<code>std::stoull</code>将其转换成数字(stoull为“<strong>s</strong>tring <strong>to u</strong>nsigned <strong>l</strong>ong <strong>l</strong>ong”的缩写)：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	size_t partitions <span class="token punctuation">{</span><span class="token function">stoull</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	size_t samples <span class="token punctuation">{</span><span class="token function">stoull</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们就可以为STL提供的每种随机数引擎，使用我们的直方图辅助函数。这里就是本节代码最长的部分。你可以选择从代码库中直接拷贝代码过来。然后对程序的输出进行观察。我们从<code>random_device</code>开始。这个设备试图将所有随机值均匀分配：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"random_device"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
	<span class="token generic-function"><span class="token function">histogram</span><span class="token generic class-name"><span class="token operator">&lt;</span>random_device<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>partitions<span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>下一个随机引擎为<code>default_random_engine</code>，这种引擎的具体实现需要用实现来指定。其可能是后面任何一种随机引擎：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\ndefault_random_engine"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
	<span class="token generic-function"><span class="token function">histogram</span><span class="token generic class-name"><span class="token operator">&lt;</span>default_random_engine<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>partitions<span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><ol start="11">
<li>
<p>然后，我们将尝试其他引擎：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nminstd_rand0"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">histogram</span><span class="token generic class-name"><span class="token operator">&lt;</span>minstd_rand0<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>partitions<span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nminstd_rand"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">histogram</span><span class="token generic class-name"><span class="token operator">&lt;</span>minstd_rand<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>partitions<span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nmt19937"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">histogram</span><span class="token generic class-name"><span class="token operator">&lt;</span>mt19937<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>partitions<span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nmt19937_64"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">histogram</span><span class="token generic class-name"><span class="token operator">&lt;</span>mt19937_64<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>partitions<span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nranlux24_base"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">histogram</span><span class="token generic class-name"><span class="token operator">&lt;</span>ranlux24_base<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>partitions<span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nranlux48_base"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">histogram</span><span class="token generic class-name"><span class="token operator">&lt;</span>ranlux48_base<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>partitions<span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nranlux24"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">histogram</span><span class="token generic class-name"><span class="token operator">&lt;</span>ranlux24<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>partitions<span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nranlux48"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">histogram</span><span class="token generic class-name"><span class="token operator">&lt;</span>ranlux48<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>partitions<span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nknuth_b"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token generic-function"><span class="token function">histogram</span><span class="token generic class-name"><span class="token operator">&lt;</span>knuth_b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>partitions<span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就会得到我们想要的结果。我们将看到一段很长的打印信息，并且将看到所有引擎的不同特点。这里我们将类别分为10个，并对1000个数进行采样：</p>
<p><img src="./C++17 STL Cook book_files/8-13-1.png" alt=""></p>
</li>
<li>
<p>然后我们再次执行程序。这次我们仍旧分成10类，但是对1,000,000个数进行采样。其将会生成非常直观的直方图，能更加清晰表现各种引擎的不同点。所以，对于这个程序来说，观察很重要：</p>
<p><img src="./C++17 STL Cook book_files/8-13-2.png" alt=""></p>
</li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>通常，任何随机数生成器都需要在使用前进行实例化。生成的对象可以像函数一样调用，并无需传入参数，因为其对<code>operator()</code>操作符进行了重载。每一次调用都会产生一个新的随机数。其使用起来非常的简单。</p>
<p>本节中，我们写了一个比较复杂的程序，从而对各种随机数生成器进行了了解。可以使用我们的程序，在命令行传入不同的参数，得到如下的结论：</p>
<ul>
<li>我们进行的采样次数越多，计数器分布就越均匀。</li>
<li>各个引擎中，计数器的分布有很大差异。</li>
<li>进行大量的样本采样时，每个随机数引擎所表现出的性能也是不同的。</li>
<li>用少量的采样进行多次的执行。每个分布生成的图形，每次都是一样的——因为随机引擎在每一次重复时，都会生成同样的随机数，这就意味着其生成的不是真正的随机数。这样的引擎具有某种确定性，因为其生成的随机数可以进行预测。唯一的例外就是<code>std::random_device</code>。</li>
</ul>
<p>如同我们所看到的，这里有一些需要进行考量的特性。对于大多数标准应用来说，<code>std::default_random_engine</code>完全够用。对于密码学专家或是类似安全敏感的课题，都会有更加多的引擎可供选择。不过，对于一般开发者来说，这里的是否真正随机，对我们的影响并不大。</p>
<p>我们需要从本节总结出三个实际情况：</p>
<ol>
<li>通常，选择使用<code>std::default_random_engine</code>就够用了。</li>
<li>需要生成不确定的随机数时，我们可以使用<code>std::random_device</code>。</li>
<li>通过<code>std::random_device</code>(或从系统时钟获取的时间戳)对随机数引擎进行初始化，这是为了让其在每次调用时，生成不同的随机数。这种方式也叫做“设置种子”。</li>
</ol>
<blockquote>
<p>Note：</p>
<p>如果实际实现库对不确定的随机引擎不支持，那么<code>std::random_device</code>将退化成其他随机数引擎。</p>
</blockquote>
</div></div><div id="ebook-heading-x8ba9stlx4ee5x6307x5b9ax5206x5e03x65b9x5f0fx4ea7x751fx968fx673ax6570" ebook-toc-level-2="" heading="让STL以指定分布方式产生随机数"><div><h1 class="mume-header" id="%E8%AE%A9stl%E4%BB%A5%E6%8C%87%E5%AE%9A%E5%88%86%E5%B8%83%E6%96%B9%E5%BC%8F%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0">让STL以指定分布方式产生随机数</h1>

<p>上一节中，我们了解了STL中的随机数引擎。使用引擎或其他方式生成随机数，只是完成了一半的工作。</p>
<p>另一个问题就是，我们需要怎么样的随机数？如何以编码的方式进行掷硬币？通常都会使用<code>rand()%2</code>的方式进行，因为其结果为0或1，也就分别代表着硬币的正反面。很公平，不是么；这样就不需要任何多余的库(估计只有数学专业知道，这样的方式获取不到高质量随机数)。</p>
<p>如果我们想要做成一个模型要怎么弄？比如：写成<code>(rand() % 6) + 1</code>，这个就表示所要生成的结果。对于这样简单的任务，有没有库进行支持？</p>
<p>当我们想要表示某些东西，并明确其概率为66%呢？Okay，我们可以写一个公式出来<code>bool yesno = (rand() % 100 &gt; 66)</code>。(这里需要注意，是使用<code>&gt;=</code>合适？还是使用<code>&gt;</code>合适？)</p>
<p>如何设置一个不平等的模型，也就是生成数的概率完全不同呢？或是，让我们生成的随机数符合某种复杂的分布？有些问题会很快发展为一个科学问题。为了回到我们的关注点上，让我们了解一下STL所提供的具体工具。</p>
<p>STL有超过10种分布算法，能用来指定随机数的生成方式。本节中，我们将简单的了解一下这些分布，并且近距离了解一下其使用方法。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们生成随机数，对生成数进行统计，并且将其分布部分在终端上进行打印。我们将了解到，当想要以特定的分布获取随机值时，应该使用哪种方式：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;random&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>对于STL所提供的分布来说，我们将从打印出的直方图中看出每种分布的不同。随机采样时，可以将某种分布作为参数传入随机数生成器。然后，我们将实例化默认随机引擎和一个<code>map</code>。这个<code>map</code>将获取的值与其计数器进行映射，计数器表示这个数产生的频率。我们使用一个限定函数作为随机引擎的指定分布，然后通过随机引擎生成对应分布的随机值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">print_distro</span><span class="token punctuation">(</span>T distro<span class="token punctuation">,</span> size_t samples<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    default_random_engine e<span class="token punctuation">;</span>
    map<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> m<span class="token punctuation">;</span>
</pre></li>
<li>
<p>使用<code>samples</code>变量来表示我们要进行多少次采样，并且在采样过程中对<code>map</code>中的计数器进行操作。这样，就能获得非常漂亮的直方图。单独调用<code>e()</code>时，随机数引擎将生成一个随机数，<code>distro(e)</code>会通过分布对象对随机数的生成进行限定。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> samples<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	m<span class="token punctuation">[</span><span class="token function">distro</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>为了输出到终端窗口中的数据的美观性，需要了解计数器的最大值。<code>max_element</code>函数能帮助我们找到<code>map</code>中所有计数器中的最大的那一个，然后返回指向具有最大计数器那个节点的迭代器。知道了最大值，就可以让所有计数器对其进行除法，这样就能在终端窗口生成固定长度的图像了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	size_t <span class="token function">max_elm</span> <span class="token punctuation">(</span><span class="token function">max_element</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword keyword-return">return</span> a<span class="token punctuation">.</span>second <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t <span class="token function">max_div</span> <span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>max_elm <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token function">size_t</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在来遍历<code>map</code>，然后对<code>*</code>进行打印，对于每一个计数器来说都有一个固定的长度：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token punctuation">[</span>randval<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">:</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> max_elm <span class="token operator">/</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> randval <span class="token operator">&lt;&lt;</span> <span class="token string">" : "</span>
        	<span class="token operator">&lt;&lt;</span> <span class="token function">string</span><span class="token punctuation">(</span>count <span class="token operator">/</span> max_div<span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，会对传入的参数进行检查，我们会指定每个分布所使用的采样率。如果用户给定的参数不合适，程序将报错：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Usage: "</span> <span class="token operator">&lt;&lt;</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        	<span class="token operator">&lt;&lt;</span> <span class="token string">" &lt;samples&gt;\n"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
</pre></li>
<li>
<p><code>std::stoull</code>会将命令行中的参数转换成数字：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	size_t samples <span class="token punctuation">{</span><span class="token function">stoull</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>首先，来尝试<code>uniform_int_distribution</code>和<code>normal_distribution</code>，这两种都是用来生成随机数的经典分布。学过概率论的同学应该很熟悉。均匀分布能接受两个值，确定生成随机数的上限和下限。例如，0和9，那么生成器将会生成<code>[0, 9]</code>之间的随机数。正态分布能接受平均值和标准差作为传入参数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"uniform_int_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>uniform_int_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"normal_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>normal_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>另一个非常有趣的分布是<code>piecewise_constant_distribution</code>。其能接受两个输入范围作为参数。比如定义为<code>0, 5, 10, 30</code>，那么其中的间隔就是0到4，然后是5到9，最后一个间隔是10到29。另一个输入范围定义了权重。比如权重<code>0.2, 0.3, 0.5</code>，那么最后生成随机数落在以上三个间隔中的概率为20%，30%和50%。在每个间隔内，生成数的概率都是相同的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> intervals <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> weights <span class="token punctuation">{</span><span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"piecewise_constant_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>
        piecewise_constant_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
            <span class="token function">begin</span><span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">begin</span><span class="token punctuation">(</span>weights<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        samples<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p><code>piecewise_linear_distribution</code>的构造方式与上一个类似，不过其权重值的特性却完全不同。对于每一个间隔的边缘值，只有一种权重值。从一个边界转换到另一个边界中，概率是线性的。这里我们使用同样的间隔列表，但权重值不同的方式对分布进行实例化：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"piecewise_linear_distribution\n"</span><span class="token punctuation">;</span>
    initializer_list<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span> weights2 <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>
        piecewise_linear_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
            <span class="token function">begin</span><span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>weights2<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>伯努利分布是另一个非常重要的分布，因为其分布只有“是/否”，“命中/未命中”或“头/尾”值，并且这些值的可能性是指定的。其输出只有0或1。另一个有趣的分布，就是<code>discrete_distribution</code>。例子中，我们离散化了一组值<code>1, 2, 4, 8</code>。这些值可被解释为输出为0至3的权重：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bernoulli_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bernoulli_distribution<span class="token punctuation">{</span><span class="token number">0.75</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"discrete_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>discrete_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>不同分布引擎之间有很大的不同。都非常特殊，也都在特定环境下非常有用。如果你没有听说过这些分布，应该对其特性不是特别的了解。不过，我们的程序中会生成非常漂亮的直方图，通过打印图，你会对这些分布有所了解：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"binomial_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>binomial_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"negative_binomial_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>
        negative_binomial_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"geometric_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>geometric_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">0.4</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"exponential_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>exponential_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">0.4</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"gamma_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>gamma_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"weibull_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>weibull_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"extreme_value_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>
        extreme_value_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lognormal_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>lognormal_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"chi_squared_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>chi_squared_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">1.0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cauchy_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>cauchy_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"fisher_f_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>fisher_f_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"student_t_distribution\n"</span><span class="token punctuation">;</span>
    <span class="token function">print_distro</span><span class="token punctuation">(</span>student_t_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">1.0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就可以得到如下输入。首先让我们对每个分布进行1000个的采样看看：</p>
<p><img src="./C++17 STL Cook book_files/8-14-1.png" alt=""></p>
</li>
<li>
<p>然后在用1,000,000个采样，这样获得的每个分布的直方图会更加的清楚。不过，在生成随机数的过程中，我们也会了解到那种引擎比较快，哪种比较慢：</p>
<p><img src="./C++17 STL Cook book_files/8-14-2.png" alt=""></p>
</li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>我们通常都不会太在意随机数引擎，不过随着我们对随机数分布的要求和对生成速度的要求，我们就需要通过随机数引擎来解决这个问题。</p>
<p>为了使用任意的分布，首先实例化一个分布对象。会看到不同分布的构造函数所需要的构造参数并不相同。本节的描述中，只使用了一部分分布引擎，因为其中大部分的用途非常特殊，或是使用起来非常复杂。不用担心，所有分布的描述都可以在C++ STL文档中查到。</p>
<p>不过，当具有一个已经实例化的分布时，我们可以像函数一样对其进行调用(只需要一个随机数引擎对象作为参数)。然后，随机数生成引擎会生成一个随机数，通过特定的分布进行对随机值进行限定，然后得到了所限定的随机数。这就导致不同的直方图具有不同的分布，也就是我们程序输出的结果。</p>
<p>可以使用我们刚刚编写的程序，来确定不同分布的功能。另外，我们也对几个比较重要的分布进行了总结。程序中使用到分布并不都会在下表出现，如果你对某个没出现的分布感兴趣，可以查阅C++ STL文档的相关内容。</p>
<table>
<thead>
<tr>
<th>分布</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/numeric/random/uniform_int_distribution">uniform_int_distribution</a></td>
<td>该分布接受一组上下限值作为构造函数的参数。之后得到的随机值就都是在这个范围中。我们可能得到的每个值的可能性是相同的，直方图将会是一个平坦的图像。这个分布就像是掷骰子，因为掷到骰子的每一个面的概率都是相等的。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/numeric/random/normal_distribution">normal_distribution</a></td>
<td>正态分布或高斯分布，自然界中几乎无处不在。其STL版本能接受一个平均值和一个标准差作为构造函数的参数，其直方图的形状像是屋顶一样。其分布于人类个体高度或动物的IQ值，或学生的成绩，都符合这个分布。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/numeric/random/bernoulli_distribution">bernoulli_distribution</a></td>
<td>当我们想要一个掷硬币的结果时，使用伯努利分布就非常完美。其只会产生0和1，并且其构造函数的参数是产生1的概率。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/numeric/random/discrete_distribution">discrete_distribution</a></td>
<td>当我们有一些限制的时候，我们就可以使用离散分布，需要我们为每个间隔的概率进行定义，从而得到离散集合的值。其构造函数会接受一个权重值类别，并且通过权重值的可能性产生相应的随机数。当我们想要对血型进行随机建模时，每种血型的概率是不一样，这样这种引擎就能很完美地契合这种需求。</td>
</tr>
</tbody>
</table>
</div></div><div id="ebook-heading-x7b2c9x7ae0-x5e76x884cx548cx5e76x53d1" ebook-toc-level-1="" heading="第9章 并行和并发"><div><h1 class="mume-header" id="%E7%AC%AC9%E7%AB%A0-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91">第9章 并行和并发</h1>

<p>C++11之前，C++原生不支持并发和并发。但这并不意味着无法对线程进行操作，只不过需要使用系统库的API进行操作(因为线程与操作系统是不可分开的)。</p>
<p>随着C++11标准的完成，我们有了<code>std::thread</code>，其能给予我们可以在所有操作系统上可移植的线程操作。为了同步线程，C++11也添加了互斥量，并且对一些RAII类型的锁进行了封装。另外，<code>std::condition_variable</code>也能够灵活的在线程间，进行唤醒操作。</p>
<p>另一些有趣的东西就是<code>std::async</code>和<code>std::future</code>——我们可以将普通的函数封装到<code>std::async</code>中，可以在后台异步的运行这些函数。包装后函数的返回值则用<code>std::future</code>来表示，函数的结果将会在运行完成后，放入这个对象中，所以可以在函数完成前，做点别的事情。</p>
<p>另一个STL中值得一提提升就是<em>执行策略</em>，其被添加到已有的69种算法中。这样就可以对现有的STL算法不做任何修改，就能享受其并行化带来的性能提升。</p>
<p>本章中，我们将通过例子来了解其中最为核心的部分。之后，我们也将了解到C++17对并行的支持。不会覆盖所有的细节，但是比较重要的部分肯定会介绍。本书会快速的帮助你了解并行编程机制，至于详细的介绍，可以在线对C++17 STL文档进行查阅。</p>
<p>最后，本章中最后两节值的注意。倒数第二节中，我们将并行化<a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/content/chapter9/content/chapter6/chapter6-5-chinese.md">第6章的ASCII曼德尔布罗特渲染器</a>，使用STL进阶用法让代码改动程度最小。最后一节中，我们将实现一个简单的库，其可以用来隐式并行复杂的任务。</p>
</div></div><div id="ebook-heading-x6807x51c6x7b97x6cd5x7684x81eax52a8x5e76x884c" ebook-toc-level-2="" heading="标准算法的自动并行"><div><h1 class="mume-header" id="%E6%A0%87%E5%87%86%E7%AE%97%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%B9%B6%E8%A1%8C">标准算法的自动并行</h1>

<p>C++17对并行化的一个重要的扩展，就是对标准函数的执行策略进行了修改。69个标准算法都能并行到不同的核上运行，甚至是向量化。</p>
<p>对于使用者来说，如果经常使用STL中的算法，那么就能很轻易的进行并行。可以通过基于现存的STL算法一个执行策略，然后就能享受并行带来的好处。</p>
<p>本节中，我们将实现一个简单的程序(通过一个不太严谨的使用场景)，其中使用了多个STL算法。使用这些算法时，我们将看到如何在C++17中，使用执行策略让这些算法并行化。本节最后一个子节中，我们会了解不同执行策略的区别。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节，将使用标准算法来完成一个程序。这个程序本身就是在模拟我们实际工作中的场景。当使用这些标准算法时，我们为了得到更快的性能，将执行策略嵌入其中：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间。其中<code>execution</code>头文件是C++17之后加入的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;random&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;execution&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>这里声明一个谓词函数，其用来判断给定数值的奇偶：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-bool">bool</span> <span class="token function">odd</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> n <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中先来定义一个很大的<code>vector</code>。我们将对其进行填充，并对其中数值进行计算。这个代码的执行速度是非常非常慢的。对于不同配置的电脑来说，这个<code>vector</code>的尺寸可能会有变化：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token function">d</span> <span class="token punctuation">(</span><span class="token number">50000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了向<code>vector</code>中塞入随机值，我们对随机数生成器进行了实例化，并选择了一种分布进行生成，并且将其打包成为一个可调用的对象。如果你对随机数生成器不太熟，那么你可以回看一下本书的第8章：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	mt19937 gen<span class="token punctuation">;</span>

	uniform_int_distribution<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token function">dis</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-auto">auto</span> <span class="token function">rand_num</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-mutable">mutable</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">dis</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p>现在，<code>std::generate</code>算法会用随机值将<code>vector</code>填满。这个算法是C++17新加入的算法，其能接受一种新的参数——执行策略。我们在这个位置上填入<code>std::execution::par</code>，其能让代码进行自动化并行。通过这个参数的传入，可以使用多线程的方式对<code>vector</code>进行填充，如果我们的电脑有多核CPU，那么就可以大大节约我们的时间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">generate</span><span class="token punctuation">(</span>execution<span class="token double-colon punctuation">::</span>par<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> rand_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>std::sort</code>想必大家都是非常熟悉了。C++17对其也提供了执行策略的参数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">sort</span><span class="token punctuation">(</span>execution<span class="token double-colon punctuation">::</span>par<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>还有<code>std::reverse</code>:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token function">reverse</span><span class="token punctuation">(</span>execution<span class="token double-colon punctuation">::</span>par<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后，我们使用<code>std::count_if</code>来计算<code>vector</code>中奇数的个数。并且也可以通过添加执行策略参数对该算法进行加速：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">odds</span> <span class="token punctuation">(</span><span class="token function">count_if</span><span class="token punctuation">(</span>execution<span class="token double-colon punctuation">::</span>par<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> odd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>最后，将结果进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">100.0</span> <span class="token operator">*</span> odds <span class="token operator">/</span> d<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token operator">&lt;&lt;</span> <span class="token string">"% of the numbers are odd.\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就能得到下面的输出。整个程序中我们就使用了一种执行策略，我们对不同执行策略之间的差异也是非常感兴趣。这个就留给读者当做作业。去了解一下不同的执行策略，比如<code>seq</code>，<code>par</code>和<code>par_vec</code>。 不过，对于不同的执行策略，我们肯定会得到不同的执行时间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>auto_parallel
<span class="token number">50.4</span><span class="token operator">%</span> of the numbers are odd<span class="token punctuation">.</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节并没有设计特别复杂的使用场景，这样就能让我们集中精力与标准库函数的调用上。并行版本的算法和标准串行的算法并没有什么区别。其差别就是多了一个参数，也就是执行策略。</p>
<p>让我们结合以下代码，来看三个核心问题：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token function">generate</span><span class="token punctuation">(</span>execution<span class="token double-colon punctuation">::</span>par<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> rand_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sort</span><span class="token punctuation">(</span> execution<span class="token double-colon punctuation">::</span>par<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">reverse</span><span class="token punctuation">(</span> execution<span class="token double-colon punctuation">::</span>par<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-auto">auto</span> <span class="token function">odds</span> <span class="token punctuation">(</span><span class="token function">count_if</span><span class="token punctuation">(</span>execution<span class="token double-colon punctuation">::</span>par<span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> odd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p><strong>哪些STL可以使用这种方式进行并行？</strong></p>
<p>69种存在的STL算法在C++17标准中，都可以使用这种方式进行并行，还有7种新算法也支持并行。虽然这种升级对于很多实现来说很伤，但是也只是在接口上增加了一个参数——执行策略参数。这也不是意味着我们总要提供一个执行策略参数。并且执行策略参数放在了第一个参数的位置上。</p>
<p>这里有69个升级了的算法。并且有7个新算法在一开始就支持了并发：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">adjacent difference<span class="token punctuation">,</span> adjacent find<span class="token punctuation">.</span>
all_of<span class="token punctuation">,</span> any_of<span class="token punctuation">,</span> none_of
copy
count
equal
fill
find
generate
includes
inner product
in place merge<span class="token punctuation">,</span> merge
is heap<span class="token punctuation">,</span> is partitioned<span class="token punctuation">,</span> is sorted
lexicographical_compare
min element<span class="token punctuation">,</span> minmax element
mismatch
move
n<span class="token operator">-</span>th element
partial sort<span class="token punctuation">,</span> sort copy
partition
remove <span class="token operator">+</span> variations
replace <span class="token operator">+</span> variations
reverse <span class="token operator">/</span> rotate
search
set difference <span class="token operator">/</span> intersection <span class="token operator">/</span> <span class="token keyword keyword-union">union</span> <span class="token operator">/</span>symmetric difference
sort
stable partition
swap ranges
transform
unique
</pre><p>详细的内容可以查看<a href="http://en.cppreference.com/w/cpp/experimental/parallelism/existing">C++ Reference</a>。(<a href="https://www.bfilipek.com/2017/08/cpp17-details-parallel.html">参考页面</a>)</p>
<p>这些算法的升级是一件令人振奋的事！如果我们之前的程序使用了很多的STL算法，那么就很容易的将这些算法进行并行。这里需要注意的是，这样的的改变并不意味着每个程序自动化运行N次都会很快，因为多核编程更为复杂，所要注意的事情更多。</p>
<p>不过，在这之前我们现在都会用<code>std::thread</code>，<code>std::async</code>或是第三方库进行复杂的并行算法设计，而现在我们可以以更加优雅、与操作系统不相关的方式进行算法的并行化。</p>
<p><strong>执行策略是如何工作的？</strong></p>
<p>执行策略会告诉我们的标准函数，以何种方式进行自动化并行。</p>
<p><code>std::execution</code>命名空间下面，有三种策略类型：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">sequenced_policy</a></td>
<td>算法使用串行的方式执行，这与原始执行方式没有什么区别。全局可用的实例命名为<code>std::execution::seq</code>。</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">parallel_policy</a></td>
<td>算法使用多线程的方式进行执行。全局可用的实例命名为<code>std::execution::par</code>。</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">parallel_unsequenced_policy</a></td>
<td>算法使用多线程的方式进行执行。并允许对代码进行向量化。在这个例子中，线程间可以对内存进行交叉访问，向量化的内容可以在同一个线程中执行。全局可用的实例命名为<code>std::execution::par_unseq</code>。</td>
</tr>
</tbody>
</table>
<p>执行策略意味着我们需要进行严格限制。严格的约定，让我们有更多并行策略可以使用：</p>
<ul>
<li>并行算法对所有元素的访问，必须不能导致死锁或数据竞争。</li>
<li>向量化和并行化中，所有可访问的函数不能使用任何一种阻塞式同步。</li>
</ul>
<p>我们需要遵守这些规则，这样才不会将错误引入到程序中。</p>
<blockquote>
<p>Note：</p>
<p>STL的自动并行化，并总能保证有加速。因为具体的情况都不一样，所以可能在很多情况下并行化并没有加速。多核编程还是很有难度的。</p>
</blockquote>
<p><strong>向量化是什么意思？</strong></p>
<p>向量化的特性需要编译器和CPU都支持，让我们先来简单的了解一下向量化是如何工作的。假设我们有一个非常大的<code>vector</code>。简单的实现可以写成如下的方式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span> <span class="token comment">/*...*/</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> sum <span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>编译器将会生成一个对<code>accumulate</code>调用的循环，其可能与下面代码类似：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> sum <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	sum <span class="token operator">+=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>从这点说起，当编译器开启向量化时，就会生成类似如下的代码。每次循环会进行4次累加，这样循环次数就要比之前减少4倍。为了简单说明问题，我们这里没有考虑不为4倍数个元素的情况：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> sum <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	sum <span class="token operator">+=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// if v.size() / 4 has a remainder,</span>
<span class="token comment">// real code has to deal with that also.</span>
</pre><p>为什么要这样做呢？很多CPU指令都能支持这种操作<code>sum += v[i] + v[i+1] + v[i+2] + v[i+3]；</code>，只需要一个指令就能完成。使用尽可能少的指令完成尽可能多的操作，这样就能加速程序的运行。</p>
<p>自动向量化非常困难，因为编译器需非常了解我们的程序，这样才能进行加速的情况下，不让程序的结果出错。目前，至少可以通过使用标准算法来帮助编译器。因为这样能让编译器更加了解哪些数据流能够并行，而不是从复杂的循环中对数据流的依赖进行分析。</p>
</div></div><div id="ebook-heading-x8ba9x7a0bx5e8fx5728x7279x5b9ax65f6x95f4x4f11x7720" ebook-toc-level-2="" heading="让程序在特定时间休眠"><div><h1 class="mume-header" id="%E8%AE%A9%E7%A8%8B%E5%BA%8F%E5%9C%A8%E7%89%B9%E5%AE%9A%E6%97%B6%E9%97%B4%E4%BC%91%E7%9C%A0">让程序在特定时间休眠</h1>

<p>C++11中对于线程的控制非常优雅和简单。在<code>this_thread</code>的命名空间中，包含了只能被运行线程调用的函数。其包含了两个不同的函数，让线程睡眠一段时间，这样就不需要使用任何额外的库，或是操作系统依赖的库来执行这个任务。</p>
<p>本节中，我们将关注于如何将线程暂停一段时间，或是让其休眠一段时间。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将完成一个短小的程序，并让主线程休眠一段时间：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间。<code>chrono_literals</code>空间包含一段时间的缩略值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> chrono_literals<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>我们直接写主函数，并让主线程休眠5秒和300毫秒。感谢<code>chrono_literals</code>，我们可以写成一种非常可读方式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Going to sleep for 5 seconds"</span>
    	    <span class="token string">" and 300 milli seconds.\n"</span><span class="token punctuation">;</span>
    
    this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">5</span>s <span class="token operator">+</span> <span class="token number">300</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>休眠状态是相对的。当然，我们能用绝对时间来表示。让休眠直到某个时间点才终止，这里我们在<code>now</code>的基础上加了3秒：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Going to sleep for another 3 seconds.\n"</span><span class="token punctuation">;</span>

	this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_until</span><span class="token punctuation">(</span>
		chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>在程序退出之前，我们会打印一个表示睡眠结束：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"That's it.\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就能获得如下的输出。Linux，Mac或其他类似UNIX的操作系统会提供time命令，其能对一个可运行程序的耗时进行统计。使用time对我们的程序进行耗时统计，其告诉我们花费了8.32秒，因为我们让主线程休眠了5.3秒和3秒。最后还有一个打印，用来告诉我们主函数的休眠终止：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ time <span class="token punctuation">.</span><span class="token operator">/</span>sleep
Going to sleep <span class="token keyword keyword-for">for</span> <span class="token number">5</span> seconds <span class="token operator">and</span> <span class="token number">300</span> milli seconds<span class="token punctuation">.</span>
Going to sleep <span class="token keyword keyword-for">for</span> another <span class="token number">3</span> seconds<span class="token punctuation">.</span>
That<span class="token number">'</span>s it<span class="token punctuation">.</span>
    
real0m8<span class="token punctuation">.</span><span class="token number">320</span>s
user0m0<span class="token punctuation">.</span><span class="token number">005</span>s
sys <span class="token number">0</span>m0<span class="token punctuation">.</span><span class="token number">003</span>s
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>sleep_for</code>和<code>sleep_until</code>函数都已经在C++11中加入，存放于<code>std::this_thread</code>命名空间中。其能对当前线程进行限时阻塞(并不是整个程序或整个进程)。线程被阻塞时不会消耗CPU时间，操作系统会将其标记挂起的状态，时间到了后线程会自动醒来。这种方式的好处在于，不需要知道操作系统对我们运行的程序做了什么，因为STL会将其中的细节进行包装。</p>
<p><code>this_thread::sleep_for</code>函数能够接受一个<code>chrono::duration</code>值。最简单的方式就是<code>1s</code>或<code>5s+300ms</code>。为了使用这种非常简洁的字面时间表示方式，我们需要对命名空间进行声明<code>using namespace std::chrono_literals;</code>。</p>
<p><code>this_thread::sleep_until</code>函数能够接受一个<code>chrono::time_out</code>参数。这就能够简单的指定对应的壁挂钟时间，来限定线程休眠的时间。</p>
<p>唤醒时间和操作系统的时间的精度一样。大多数操作系统的时间精度通常够用，但是其可能对于一些时间敏感的应用非常不利。</p>
<p>另一种让线程休眠一段时间的方式是使用<code>this_thread::yield</code>。其没有参数，也就意味着这个函数不知道这个线程要休眠多长时间。所以，这个函数并不建议用来对线程进行休眠或停滞一个线程。其只会以协作的方式告诉操作系统，让操作系统对线程和进程重新进行调度。如果没有其他可以调度的线程或进程，那么这个“休眠”线程则会立即执行。正因为如此，很少用<code>yield</code>让线程休眠一段时间。</p>
</div></div><div id="ebook-heading-x542fx52a8x548cx505cx6b62x7ebfx7a0b" ebook-toc-level-2="" heading="启动和停止线程"><div><h1 class="mume-header" id="%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B">启动和停止线程</h1>

<p>C++11中添加了<code>std::thread</code>类，并能使用简洁的方式能够对线程进行启动或停止，线程相关的东西都包含在STL中，并不需要额外的库或是操作系统的实现来对其进行支持。</p>
<p>本节中，我们将实现一个程序对线程进行启动和停止。如果是第一次使用线程的话，就需要了解一些细节。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将会使用多线程进行编程，并且会了解到，当程序的某些部分使用多线程时，代码会如何进行操作：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> chrono_literals<span class="token punctuation">;</span>
</pre></li>
<li>
<p>启动一个线程时，我们需要告诉代码如何执行。所以，先来定义一个函数，这个函数会在线程中执行。这个函数可接受一个参数<code>i</code>，可以看作为线程的ID，这样就可以了解打印输出对应的是哪个线程。另外，我们使用线程ID来控制线程休眠的时间，避免多个线程在同时执行<code>cout</code>。如果出现了同时打印的情况，那就会影响到输出。本章的另一个章节会来详述这个问题：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">thread_with_param</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">1</span>ms <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello from thread "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    
    this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">1</span>s <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Bye from thread "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，会先了解在所使用的系统中能够同时运行多少个线程，使用<code>std::thread::hardware_concurrency</code>进行确定。这个数值通常依赖于机器上有多少个核，或是STL实现中支持多少个核。这也就意味着，对于不同机器，这个函数会返回不同的值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    	<span class="token operator">&lt;&lt;</span> <span class="token string">" concurrent threads are supported.\n"</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在让我们来启动线程，每个线程的ID是不一样的，这里我们启动三个线程。我们使用实例化线程的代码行为<code>thread t {f, x}</code>，这就等于在新线程中调用<code>f(x)</code>。这样，在不同的线程中就可以给于<code>thread_with_param</code>函数不同的参数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	thread t1 <span class="token punctuation">{</span>thread_with_param<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    thread t2 <span class="token punctuation">{</span>thread_with_param<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    thread t3 <span class="token punctuation">{</span>thread_with_param<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>当启动线程后，我们就需要在其完成其工作后将线程进行终止，使用<code>join</code>函数来停止线程。调用<code>join</code>将会阻塞调用线程，直至对应的线程终止为止：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>另一种方式终止的方式是分离。如果不以<code>join</code>或<code>detach</code>的方式进行终止，那么程序只有在<code>thread</code>对象析构时才会终止。通过调用<code>detech</code>，我们将告诉3号线程，即使主线程终止了，你也可以继续运行：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	t3<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>主函数结束前将打印一段信息：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Threads joined.\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就会得到如下的输出。我们可以看到我们的机器上有8个CPU核。然后，我们可以看到每个线程中打印出的<em>hello</em>讯息，但是在主线程最后，我们只对两个线程使用<code>join</code>。第3个线程等待了3秒，但是再主线程结束的时候，其只完成了2秒的等待。这样，我们就没有办法看到线程3的结束信息，因为主函数在结束之后，我们就没有任何机会将其进行杀死了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>threads
<span class="token number">8</span> concurrent threads are supported<span class="token punctuation">.</span>
Hello from thread <span class="token number">1</span>
Hello from thread <span class="token number">2</span>
Hello from thread <span class="token number">3</span>
Bye from thread <span class="token number">1</span>
Bye from thread <span class="token number">2</span>
Threads joined<span class="token punctuation">.</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>启动和停止线程其实没有什么困难的。多线程编程的难点在于，如何让线程在一起工作(共享资源、互相等待，等等)。</p>
<p>为了启动一个线程，我们首先定义一些执行函数。没有特定的规定，普通的函数就可以。我们来看一个简化的例子，启动线程并等待线程结束：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    thread t <span class="token punctuation">{</span>f<span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p><code>std::thread</code>的构造函数允许传入一个函数指针或一个可调用的对象，通过这个参数，我们就可以对函数进行调用。当然，我们也可以使用没有任何参数的函数。</p>
<p>如果系统中有多个CPU核，那么线程就可以并行或并发的运行。并行与并发之间有什么区别呢？当计算机只有一个CPU核时，也可以有很多线程并行，但就不可能是并发的了，因为在单核CPU上，每个时间片上只有一个线程在执行。线程在单核上交错着运行，当一个时间片结束后，会对下一个线程进行执行(不过对于使用者来说，看起来就像是同时在运行)。如果线程间可以不去分享一个CPU和，那么这些线程就是并发运行。其实<strong>并发</strong>才是真正的同时运行。</p>
<p>这样，以下几点是我们绝对无法控制的：</p>
<ul>
<li>共享一个CPU核时，无法控制线程交替运行的顺序。</li>
<li>线程也是有优先级的，优先级会影响线程执行的顺序。</li>
<li>实际上线程是分布在所有CPU核上的，当然操作系统也可以将线程绑定在一个核上。这也就意味着所有的线程可以运行在单核上，也可以运行在具有100个CPU核的机器上。</li>
</ul>
<p>大多数操作系统都会提供对多线程编程提供一些可能性，不过这些特性并没包含在STL中。</p>
<p>在启动和停止线程的时候，告诉他们要做什么样的工作，并且什么时候线程停止工作。对于大多数应用来说就够用了。本节中，我们启动的3个线程。之后，对其中两个进行了<code>join</code>，另一个进行<code>detach</code>。让我们使用一个简单的图来总结一下本节的代码：</p>
<p><img src="./C++17 STL Cook book_files/9-3-1.png" alt=""></p>
<p>这幅图的顺序是自顶向下，你会看到我们将整个程序分成了4个线程。一开始，启动了额外3个线程来完成一些事情，之后主线程仅等待其他线程的结束。</p>
<p>线程结束对函数的执行后，会从函数中返回。标准库会进行相关的操作，将线程从操作系统的中删除，或用其他方式销毁，所以这里就不用操心了。</p>
<p>我们需要关心的就是<code>join</code>。当对线程对象调用函数<code>x.join()</code>时，其会让调用线程休眠，直至<code>x</code>线程返回。如果线程处于一个无限循环中，就意味着程序无法终止。如果想要一个线程继续存活，并持续到自己结束的时候，那就可以调用<code>x.detach()</code>。之后，就不会在等这个线程了。不管我们怎么做——都必须<code>join</code>或<code>detach</code>线程。如果不想使用这两种方式，可以在线程对象的析构函数中调用<code>std::terminate()</code>，这个函数会让程序“突然死亡”。</p>
<p>主函数返回时，整个程序也就结束了。不过，第3个线程<code>t3</code>还在等待，并将对应的信息打印到终端。操作系统才不会在乎——会直接将我们的程序终止，并不管是否有线程还未结束。要怎么解决这个这个问题，就是开发者要考虑的事情了。</p>
</div></div><div id="ebook-heading-x6253x9020x5f02x5e38x5b89x5168x7684x5171x4eabx9501x2014x2014stdunique_lockx548cstdshared_lock" ebook-toc-level-2="" heading="打造异常安全的共享锁——std::unique_lock和std::shared_lock"><div><h1 class="mume-header" id="%E6%89%93%E9%80%A0%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B1%E4%BA%AB%E9%94%81stdunique_lock%E5%92%8Cstdshared_lock">打造异常安全的共享锁——std::unique_lock和std::shared_lock</h1>

<p>由于对于线程的操作严重依赖于操作系统，所以STL提供与系统无关的接口是非常明智的，当然STL也会提供线程间的同步操作。这样就不仅是能够启动和停止线程，使用STL库也能完成线程的同步操作。</p>
<p>本节中，我们将了解到STL中的互斥量和RAII锁。我们使用这些工具对线程进行同步时，也会了解STL中更多同步辅助的方式。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将使用<code>std::shared_mutex</code>在独占(exclusive)和共享(shared)模式下来完成一段程序，并且也会了解到这两种方式意味着什么。另外，我们将不会对手动的对程序进行上锁和解锁的操作，这些操作都交给RAII辅助函数来完成：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;shared_mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> chrono_literals<span class="token punctuation">;</span>
</pre></li>
<li>
<p>整个程序都会围绕共享互斥量展开，为了简单，我们定义了一个全局实例：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">shared_mutex shared_mut<span class="token punctuation">;</span>
</pre></li>
<li>
<p>接下来，我们将会使用<code>std::shared_lock</code>和<code>std::unique_lock</code>这两个RAII辅助者。为了让其类型看起来没那么复杂，这里进行别名操作：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> shrd_lck <span class="token operator">=</span> shared_lock<span class="token operator">&lt;</span>shared_mutex<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> uniq_lck <span class="token operator">=</span> unique_lock<span class="token operator">&lt;</span>shared_mutex<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>开始写主函数之前，先使用互斥锁的独占模式来实现两个辅助函数。下面的函数中，我们将使用<code>unique_lock</code>实例来作为共享互斥锁。其构造函数的第二个参数<code>defer_lock</code>会告诉对象让锁处于解锁的状态。否则，构造函数会尝试对互斥量上锁阻塞程序，直至成功为止。然后，会对<code>exclusive_lock</code>的成员函数<code>try_lock</code>进行调用。该函数会立即返回，并且返回相应的布尔值，布尔值表示互斥量是否已经上锁，或是在其他地方已经锁住：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">print_exclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    uniq_lck l <span class="token punctuation">{</span>shared_mut<span class="token punctuation">,</span> defer_lock<span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span><span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Got exclusive lock.\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Unable to lock exclusively.\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>另一个函数也差不多。其会将程序阻塞，直至其获取相应的锁。然后，会使用抛出异常的方式来模拟发生错误的情况(只会返回一个整数，而非一个非常复杂的异常对象)。虽然，其会立即退出，并且在上下文中我们获取了一个锁住的互斥量，但是这个互斥量也可以被释放。这是因为<code>unique_lock</code>的析构函数在任何情况下都会将对应的锁进行释放：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">exclusive_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    uniq_lck l <span class="token punctuation">{</span>shared_mut<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-throw">throw</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在，让我们来写主函数。首先，先开一个新的代码段，并且实例化一个<code>shared_lock</code>实例。其构造函数将会立即对共享模式下的互斥量进行上锁。我们将会在下一步了解到这一动作的意义：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        shrd_lck sl1 <span class="token punctuation">{</span>shared_mut<span class="token punctuation">}</span><span class="token punctuation">;</span>
        
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"shared lock once.\n"</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们开启另一个代码段，并使用同一个互斥量实例化第二个<code>shared_lock</code>实例。现在具有两个<code>shared_lock</code>实例，并且都具有同一个互斥量的共享锁。实际上，可以使用同一个互斥量实例化很多的<code>shared_lock</code>实例。然后，调用<code>print_exclusive</code>，其会尝试使用互斥量的独占模式对互斥量进行上锁。这样的调用当然不会成功，因为互斥量已经在共享模式下锁住了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        <span class="token punctuation">{</span>
            shrd_lck sl2 <span class="token punctuation">{</span>shared_mut<span class="token punctuation">}</span><span class="token punctuation">;</span>

            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"shared lock twice.\n"</span><span class="token punctuation">;</span>

            <span class="token function">print_exclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</pre></li>
<li>
<p>离开这个代码段后，<code>shared_locks12</code>的析构函数将会释放互斥量的共享锁。<code>print_exclusive</code>函数还是失败，这是因为互斥量依旧处于共享锁模式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"shared lock once again.\n"</span><span class="token punctuation">;</span>

        <span class="token function">print_exclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lock is free.\n"</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>离开这个代码段时，所有<code>shared_lock</code>对象就都被销毁了，并且互斥量再次处于解锁状态，现在我们可以在独占模式下对互斥量进行上锁了。调用<code>exclusive_throw</code>，然后调用<code>print_exclusive</code>。不过因为<code>unique_lock</code>是一个RAII对象，所以是异常安全的，也就是无论<code>exclusive_throw</code>返回了什么，互斥量最后都会再次解锁。这样即便是互斥量处于锁定状态，<code>print_exclusive</code> 也不会被错误的状态所阻塞：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span>
   		<span class="token function">exclusive_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Got exception "</span> <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">print_exclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行这段代码则会得到如下的输出。前两行展示的是两个共享锁实例。然后，<code>print_exclusive</code>函数无法使用独占模式对互斥量上锁。在离开内部代码段后，第二个共享锁解锁，<code>print_exclusive</code>函数依旧会失败。在离开这个代码段后，将会对互斥量所持有的锁进行释放，这样<code>exclusive_throw</code>和<code>print_exclusive</code>最终才能对互斥量进行上锁：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>shared_lock
shared lock once<span class="token punctuation">.</span>
shared lock twice<span class="token punctuation">.</span>
Unable to lock exclusively<span class="token punctuation">.</span>
shared lock once again<span class="token punctuation">.</span>
Unable to lock exclusively<span class="token punctuation">.</span>
lock is free<span class="token punctuation">.</span>
Got exception <span class="token number">123</span>
Got exclusive lock<span class="token punctuation">.</span>
</pre><h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>查阅C++文档时，我们会对不同的互斥量和RAII辅助锁有些困惑。在我们回看这节的代码之前，让我们来对STL的这两个部分进行总结。</p>
<p><strong>互斥量</strong></p>
<p>其为<strong>mut</strong>ual <strong>ex</strong>clusion的缩写。并发时不同的线程对于相关的共享数据同时进行修改时，可能会造成结果错误，我们在这里就可以使用互斥量对象来避免这种情况的发生，STL提供了不同特性的互斥量。不过，这些互斥量的共同点就是具有<code>lock</code>和<code>unlock</code>两个成员函数。</p>
<p>一个互斥量在解锁状态下时，当有线程对其使用<code>lock()</code>时，这个线程就获取了互斥量，并对互斥量进行上锁。这样，但其他线程要对这互斥量进行上锁时，就会处于阻塞状态，知道第一个线程对该互斥量进行释放。<code>std::mutex</code>就可以做到。</p>
<p>这里将STL一些不同的互斥量进行对比：</p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/thread/mutex">mutex</a></td>
<td>具有<code>lock</code>和<code>unlock</code>成员函数的标准互斥量。并提供非阻塞函数<code>try_lock</code>成员函数。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/thread/timed_mutex">timed_mutex</a></td>
<td>与互斥量相同，并提供<code>try_lock_for</code>和<code>try_lock_until</code>成员函数，其能在某个时间段内对程序进行阻塞。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/thread/recursive_mutex">recursive_mutex</a></td>
<td>与互斥量相同，不过当一个线程对实例进行上锁，其可以对同一个互斥量对象多次调用<code>lock</code>而不产生阻塞。持有线程可以多次调用<code>unlock</code>，不过需要和<code>lock</code>调用的次数匹配时，线程才不再拥有这个互斥量。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/thread/recursive_timed_mutex">recursive_timed_mutex</a></td>
<td>提供与<code>timed_mutex</code>和<code>recursive_mutex</code>的特性。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/thread/shared_mutex">shared_mutex</a></td>
<td>这个互斥量在这方面比较特殊，它可以被锁定为独占模式或共享模式。独占模式时，其与标准互斥量的行为一样。共享模式时，其他线程也可能在共享模式下对其进行上锁。其会在最后一个处于共享模式下的锁拥有者进行解锁时，整个互斥量才会解锁。其行为有些类似于<code>shared_ptr</code>，只不过互斥量不对内存进行管理，而是对锁的所有权进行管理。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/thread/shared_timed_mutex">shared_timed_mutex</a></td>
<td>同时具有<code>shared_mutex</code>和<code>timed_mutex</code>两种互斥量独占模式和共享模式的特性。</td>
</tr>
</tbody>
</table>
<p><strong>锁</strong></p>
<p>线程对互斥量上锁之后，很多事情都变的非常简单，我们只需要上锁、访问、解锁三步就能完成我们想要做的工作。不过对于有些比较健忘的开发者来说，在上锁之后，很容易忘记对其进行解锁，或是互斥量在上锁状态下抛出一个异常，如果要对这个异常进行处理，那么代码就会变得很难看。最优的方式就是程序能够自动来处理这种事情。这种问题很类似与内存泄漏，开发者在分配内存之后，忘记使用<code>delete</code>操作进行内存释放。</p>
<p>内存管理部分，我们有<code>unique_ptr</code>，<code>shared_ptr</code>和<code>weak_ptr</code>。这些辅助类可以很完美帮我们避免内存泄漏。互斥量也有类似的帮手，最简单的一个就是<code>std::lock_guard</code>。使用方式如下：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">critical_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> l <span class="token punctuation">{</span>some_mutex<span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token comment">// critical section</span>
<span class="token punctuation">}</span>
</pre><p><code>lock_guard</code>的构造函数能接受一个互斥量，其会立即自动调用<code>lock</code>，构造函数会直到获取互斥锁为止。当实例进行销毁时，其会对互斥量再次进行解锁。这样互斥量就很难陷入到<code>lock/unlock</code>循环错误中。</p>
<p>C++17 STL提供了如下的RAII辅助锁。其都能接受一个模板参数，其与互斥量的类型相同(在C++17中，编译器可以自动推断出相应的类型)：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/thread/lock_guard">lock_guard</a></td>
<td>这个类没有什么其他的，构造函数中调用<code>lock</code>，析构函数中调用<code>unlock</code>。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/thread/scoped_lock">scoped_lock</a></td>
<td>与<code>lock_guard</code>类似，构造函数支持多个互斥量。析构函数中会以相反的顺序进行解锁。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/thread/unique_lock">unique_lock</a></td>
<td>使用独占模式对互斥量进行上锁。构造函数也能接受一个参数用于表示超时到的时间，并不会让锁一直处于上锁的状态。其也可能不对互斥量进行上锁，或是假设互斥量已经锁定，或是尝试对互斥量进行上锁。另外，函数可以在<code>unique_lock</code>锁的声明周期中，对互斥量进行上锁或解锁。</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/thread/shared_lock">shared_lock</a></td>
<td>与<code>unique_lock</code>类似，不过所有操作都是在互斥量的共享模式下进行操作。</td>
</tr>
</tbody>
</table>
<p><code>lock_guard</code>和<code>scoped_lock</code>只拥有构造和析构函数，<code>unique_lock</code>和<code>shared_lock</code>就比较复杂了，但也更为通用。我们将在本章的后续章节中了解到，这些类型如何用于更加复杂的情况。</p>
<p>现在我们来回看一下本节的代码。虽然，只在单线程的上下文中运行程序，但是我们可以了解到如何对辅助锁进行使用。<code>shrd_lck</code>类型为<code>shared_lock&lt;shared_mutex&gt;</code>的缩写，并且其允许我们在共享模式下对一个实例多次上锁。当<code>sl1</code>和<code>sl2</code>存在的情况下，<code>print_exclusive</code>无法使用独占模式对互斥量进行上锁。</p>
<p>现在来看看处于独占模式的上锁函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
    	shrd_lck sl1 <span class="token punctuation">{</span>shared_mut<span class="token punctuation">}</span><span class="token punctuation">;</span>
    	<span class="token punctuation">{</span>
    		shrd_lck sl2 <span class="token punctuation">{</span>shared_mut<span class="token punctuation">}</span><span class="token punctuation">;</span>
    		<span class="token function">print_exclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    	<span class="token function">print_exclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span>
    	<span class="token function">exclusive_throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Got exception "</span> <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">print_exclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p><code>exclusive_throw</code>的返回也比较重要，即便是抛出异常退出，<code>exclusive_throw</code>函数依旧会让互斥量再度锁上。</p>
<p>因为<code>print_exclusive</code>使用了一个奇怪的构造函数，我们就再来看一下这个函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-void">void</span> <span class="token function">print_exclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    uniq_lck l <span class="token punctuation">{</span>shared_mut<span class="token punctuation">,</span> defer_lock<span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span><span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>	
</pre><p>这里我们不仅提供了<code>shared_mut</code>，还有<code>defer_lock</code>作为<code>unique_lock</code>构造函数的参数。<code>defer_lock</code>是一个空的全局对象，其不会对互斥量立即上锁，所以我们可以通过这个参数对<code>unique_lock</code>不同的构造函数进行选择。这样做之后，我们可以调用<code>l.try_lock()</code>，其会告诉我们有没有上锁。在互斥量上锁的情况下，就可以做些别的事情了。如果的确有机会获取锁，依旧需要析构函数对互斥量进行清理。</p>
</div></div><div id="ebook-heading-x907fx514dx6b7bx9501x2014x2014stdscoped_lock" ebook-toc-level-2="" heading="避免死锁——std::scoped_lock"><div><h1 class="mume-header" id="%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81stdscoped_lock">避免死锁——std::scoped_lock</h1>

<p>如果在路上发生了死锁，就会像下图一样：</p>
<p><img src="./C++17 STL Cook book_files/9-5-1.png" alt=""></p>
<p>为了让交通顺畅，可能需要一个大型起重机，将路中间的一辆车挪到其他地方去。如果找不到起重机，那么我们就希望这些司机们能互相配合。当几个司机愿意将车往后退，留给空间给其他车通行，那么每辆车就不会停在原地了。</p>
<p>多线程编程中，开发者肯定需要避免这种情况的发生。不过，程序比较复杂的情况下，这种情况其实很容易发生。</p>
<p>本节中，我们将会故意的创造一个死锁的情况。然后，在相同资源的情况下，如何创造出一个死锁的情形。再使用C++17中，STL的<code>std::scoped_lock</code>如何避免死锁的发生。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中有两对函数要在并发的线程中执行，并且有两个互斥量。其中一对制造死锁，另一对解决死锁。主函数中，我们将使用这两个互斥量：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> chrono_literals<span class="token punctuation">;</span>
</pre></li>
<li>
<p>实例化两个互斥量对象，制造死锁：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">mutex mut_a<span class="token punctuation">;</span>
mutex mut_b<span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了使用两个互斥量制造死锁，我们需要有两个函数。其中一个函数试图对互斥量<code>A</code>进行上锁，然后对互斥量B进行上锁，而另一个函数则试图使用相反的方式运行。让两个函数在等待锁时进行休眠，我们确定这段代码永远处于一个死锁的状态。(这就达到了我们演示的目的。当我们重复运行程序，那么程序在没有任何休眠代码的同时，可能会有成功运行的情况。)需要注意的是，这里我们没有使用<code>\n</code>字符作为换行符，我们使用的是<code>endl</code>。<code>endl</code>会输出一个换行符，同时也会对<code>cout</code>的流缓冲区进行刷新，所以我们可以确保打印信息不会有延迟或同时出现：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">deadlock_func_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bad f1 acquiring mutex A..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> la <span class="token punctuation">{</span>mut_a<span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">100</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bad f1 acquiring mutex B..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> lb <span class="token punctuation">{</span>mut_b<span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bad f1 got both mutexes."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p><code>deadlock_func_2</code>和<code>deadlock_func_1</code>看起来一样，就是<code>A</code>和<code>B</code>的顺序相反：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">deadlock_func_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bad f2 acquiring mutex B..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> lb <span class="token punctuation">{</span>mut_b<span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">100</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bad f2 acquiring mutex A..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> la <span class="token punctuation">{</span>mut_a<span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bad f2 got both mutexes."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在我们将完成与上面函数相比，两个无死锁版本的函数。它们使用了<code>scoped_lock</code>，其会作为构造函数参数的所有互斥量进行上锁。其析构函数会进行解锁操作。锁定这些互斥量时，其内部应用了避免死锁的策略。这里需要注意的是，两个函数还是对<code>A</code>和<code>B</code>互斥量进行操作，并且顺序相反：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">sane_func_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	scoped_lock l <span class="token punctuation">{</span>mut_a<span class="token punctuation">,</span> mut_b<span class="token punctuation">}</span><span class="token punctuation">;</span>
	
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sane f1 got both mutexes."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">sane_func_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	scoped_lock l <span class="token punctuation">{</span>mut_b<span class="token punctuation">,</span> mut_a<span class="token punctuation">}</span><span class="token punctuation">;</span>
	
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sane f2 got both mutexes."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中观察这两种情况。首先，我们使用不会死锁的函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        thread t1 <span class="token punctuation">{</span>sane_func_1<span class="token punctuation">}</span><span class="token punctuation">;</span>
        thread t2 <span class="token punctuation">{</span>sane_func_2<span class="token punctuation">}</span><span class="token punctuation">;</span>
        
        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>然后，调用制造死锁的函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">{</span>
        thread t1 <span class="token punctuation">{</span>deadlock_func_1<span class="token punctuation">}</span><span class="token punctuation">;</span>
        thread t2 <span class="token punctuation">{</span>deadlock_func_2<span class="token punctuation">}</span><span class="token punctuation">;</span>
        
        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，就能得到如下的输出。前两行为无死锁情况下，两个函数的打印结果。接下来的两个函数则产生死锁。因为我们能看到f1函数始终是在等待互斥量B，而f2则在等待互斥量A。两个函数都没做成功的对两个互斥量上锁。我们可以让这个程序持续运行，不管时间是多久，结果都不会变化。程序只能从外部进行杀死，这里我们使用<code>Ctrl + C</code>的组合键，将程序终止：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>avoid_deadlock
sane f1 got both mutexes
sane f2 got both mutexes
bad f2 acquiring mutex B<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
bad f1 acquiring mutex A<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
bad f1 acquiring mutex B<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
bad f2 acquiring mutex A<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>例子中，我们故意制造了死锁，我们也了解了这样一种情况发生的有多快。在一个很大的项目中，多线程开发者在编写代码的时候，都会共享一些互斥量用于保护资源，所有开发者都需要遵循同一种加锁和解锁的顺序。这种策略或规则是很容易遵守的，不过也是很容易遗忘的。另一个问题则是<em>锁序倒置</em>。</p>
<p><code>scoped_lock</code>对于这种情况很有帮助。其实在C++17中添加，其工作原理与<code>lock_guard</code>和<code>unique_lock</code>一样：其构造函数会进行上锁操作，并且析构函数会对互斥量进行解锁操作。<code>scoped_lock</code>特别之处是，可以指定多个互斥量。</p>
<p><code>scoped_lock</code>使用<code>std::lock</code>函数，其会调用一个特殊的算法对所提供的互斥量调用<code>try_lock</code>函数，这是为了避免死锁。因此，在加锁与解锁的顺序相同的情况下，使用<code>scoped_lock</code>或对同一组锁调用<code>std::lock</code>都是非常安全的。</p>
</div></div><div id="ebook-heading-x540cx6b65x5e76x884cx4e2dx4f7fx7528stdcout" ebook-toc-level-2="" heading="同步并行中使用std::cout"><div><h1 class="mume-header" id="%E5%90%8C%E6%AD%A5%E5%B9%B6%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8stdcout">同步并行中使用std::cout</h1>

<p>多线程中的一个麻烦的地方在于，需要对并发线程所要访问的共享数据使用互斥量或其他方式进行保护，以避免让多线程修改失控。</p>
<p>其中<code>std::cout</code>打印函数通常被使用到。如果多个线程同时调用<code>cout</code>，那么其输出将会混合在一起。为了避免输出混在一起，我们将要用我们的函数进行并发安全的打印。</p>
<p>我们将会了解到，如何完成对<code>cout</code>的包装，并使用最少量的代码进行最优的打印。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，将实现一个并发打印安全的函数。避免将打印信息全部混在一起，我们实现了一个辅助类来帮助我们在线程间同步打印信息。</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后实现辅助类，其名字为<code>pcout</code>。其中字母p代表parallel，因为其会将并发的上下文进行同步。<code>pcout</code>会<code>public</code>继承于<code>stringstream</code>。这样，我们就能直接对其实例使用<code>&lt;&lt;</code>操作符了。当<code>pcout</code>实例销毁时，其析构函数会对一个互斥量进行加锁，然后将<code>stringstream</code>缓冲区中的内容进行打印。我们将在下一步了解，如何对这个类进行使用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">pcout</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword keyword-public">public</span> <span class="token class-name">stringstream</span></span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-inline">inline</span> mutex cout_mutex<span class="token punctuation">;</span>
   
    <span class="token operator">~</span><span class="token function">pcout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> l <span class="token punctuation">{</span>cout_mutex<span class="token punctuation">}</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，让我们来完成两个函数，这个两函数可运行在额外的线程上。每个线程都有一个线程ID作为参数。这两个函数的区别在于，第一个就是简单的使用<code>cout</code>进行打印。另一个使用<code>pcout</code>来进行打印。对应的实例都是一个临时变量，只存在于一行代码上。在所有<code>&lt;&lt;</code>调用执行完成后，我们想要的字符流则就打印在屏幕上了。然后，调用<code>pcout</code>实例的析构函数。我们可以了解到析构函数做了什么事：其对一个特定的互斥量进行上锁，所有<code>pcout</code>的实例都会这个互斥量进行共享：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">print_cout</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cout hello from "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">print_pcout</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	pcout<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"pcout hello from "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>首先，我们使用<code>print_cout</code>，其会使用<code>cout</code>进行打印。我们并发的启动10个线程，使用其打印相应的字符串，并等待打印结束：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
    
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	v<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>print_cout<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>t <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre></li>
<li>
<p>然后，使用<code>print_pcout</code>来完成同样的事情：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=====================\n"</span><span class="token punctuation">;</span>

    v<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	v<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>print_pcout<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
	<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>t <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就会得到如下的输出。如我们所见，前10行打印完全串行了。我们无法了解到哪条信息是由哪个线程所打印的。后10行的打印中，我们使用<code>print_pcout</code>进行打印，就不会造成任何串行的情况。可以清楚的看到不同线程所打印出的信息，因为每次运行的时候打印顺序都是以类似随机数的方式出现：</p>
<p><img src="./C++17 STL Cook book_files/9-6-1.png" alt=""></p>
</li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>OK，我们已经构建了“cout包装器”，其可以在并发程序中串行化的对输出信息进行打印。其是如何工作的呢？</p>
<p>当我们一步一步的了解<code>pcout</code>的原理，就会发现其工作的原理并不神奇。首先，实现一个字符流，能接受我们输入的字符串：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">stringstream ss<span class="token punctuation">;</span>
ss <span class="token operator">&lt;&lt;</span> <span class="token string">"This is some printed line "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">123</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><p>然后，其会对全局互斥量进行锁定：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token punctuation">{</span>
	lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> l <span class="token punctuation">{</span>cout_mutex<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>锁住的区域中，其能访问到字符流<code>ss</code>，并对其进行打印。离开这个代码段时，对互斥锁进行释放。<code>cout.flush()</code>这会告诉字符流对象立即将其内容打印到屏幕上。如果没有这一行，程序将会运行的更快，因为多次的打印可能会放在一起打印。我们的代码中，想立即看到打印信息，所以我们使用了<code>flush</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> ss<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>OK，这就很简单了吧，但每次都写这几行代码，就会让整体的代码变的很冗长。我们可以将<code>stringstream</code>的实例化简写为如下的方式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">stringstream<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"This is some printed line "</span> <span class="token operator">&lt;&lt;</span> <span class="token number">123</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><p>这个字符串流对象的实例，可以容纳我们想打印的任何字符，最后对字符串进行析构。字符串流的声明周期只在这一行内存在。之后，我们无法打印任何东西，因为我们无法对其进行访问。最后，哪段代码能访问流的内容呢？其就是<code>stringstream</code>的析构函数。</p>
<p>我们无法对<code>stringstream</code>实例的成员函数进行修改，但是可以对通过继承的方式包装成我们想要的类型：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">pcout</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword keyword-public">public</span> <span class="token class-name">stringstream</span></span> <span class="token punctuation">{</span>
    <span class="token operator">~</span><span class="token function">pcout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> l <span class="token punctuation">{</span>cout_mutex<span class="token punctuation">}</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p>这个类依旧是一个字符串流，并且可以像字符串流一样对这个类型进行使用。不同的是，其会对互斥量进行上锁，并且将其内容使用<code>cout</code>进行输出。</p>
<p>我们也会将<code>cout_mutex</code>对象作为静态实例移入<code>pcout</code>结构体中，所以可以让不同的实例共享一个互斥量。</p>
</div></div><div id="ebook-heading-x8fdbx884cx5ef6x8fdfx521dx59cbx5316x2014x2014stdcall_once" ebook-toc-level-2="" heading="进行延迟初始化——std::call_once"><div><h1 class="mume-header" id="%E8%BF%9B%E8%A1%8C%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96stdcall_once">进行延迟初始化——std::call_once</h1>

<p>有时我们有一些特定的代码段，可以在多个线程间并行执行，不过其中有一些功能需要在进行执行前，完成一次初始化的过程。一个很简单的方式，就是在程序进入并行前，执行已存在的准备函数。</p>
<p>这种方法有如下几个缺点：</p>
<ul>
<li>当并行线程来自于一个库，使用者肯定会忘记调用准备函数。这样会让库函数不是那么容易的让人使用。</li>
<li>当准备函数特别复杂，并且在某些条件下我们要通过条件来判断，是否要执行这个准备函数。</li>
</ul>
<p>本节中，我们将来了解一下<code>std::call_once</code>，其能帮助使用简单且优雅的方式解决上面提到的问题。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将完成一个程序，我们使用多线程对同一段代码进行执行。虽然这里执行的是相同的代码，但是我们的准备函数只需要运行一次：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span> 
</pre></li>
<li>
<p>我们将使用<code>std::call_once</code>。为了对其进行使用，需要对<code>once_flag</code>进行实例化。在对指定函数使用<code>call_once</code>时，需要对所有线程进行同步：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">once_flag callflag<span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在来定义一个只需要执行一次的函数，就让这个函数打印一个感叹号吧：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">once_print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">'!'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>再来定义所有线程都会运行的函数。首先，要通过<code>std::call_once</code>调用<code>once_print</code>。<code>call_once</code>需要我们之前定义的变量<code>callflag</code>。其会被用来对线程进行安排：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span>size_t x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">call_once</span><span class="token punctuation">(</span>callflag<span class="token punctuation">,</span> once_print<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>OK，让我们启动10个线程，并且让他们使用<code>print</code>函数进行执行：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
    
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	v<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>print<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>t <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就会得到如下的输出。首先，我们可以看到由<code>once_print</code>函数打印出的感叹号。然后，我么可以看到线程对应的ID号。另外，其会对所有线程进行同步，所以不会有ID在<code>once_print</code>函数执行前被打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>call_once
<span class="token operator">!</span><span class="token number">1239406758</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p><code>std::call_once</code>工作原理和栅栏类似。其能对一个函数(或是一个可调用的对象)进行访问。第一个线程达到<code>call_once</code>的线程会执行对应的函数。直到函数执行结束，其他线程才能不被<code>call_once</code>所阻塞。当第一个线程从准备函数中返回后，其他线程也就都结束了阻塞。</p>
<p>我们可以对这个过程进行安排，当有一个变量决定其他线程的运行时，线程则必须对这个变量进行等待，直到这个变量准备好了，所有变量才能运行。这个变量就是<code>once_flag callflag;</code>。每一个<code>call_once</code>都需要一个<code>once_flag</code>实例作为参数，来表明预处理函数是否运行了一次。</p>
<p>另一个细节是：如果<code>call_once</code>执行失败了(因为准备函数抛出了异常)，那么下一个线程则会再去尝试执行(这种情况发生在下一次执行不抛出异常的时候)。</p>
</div></div><div id="ebook-heading-x5c06x6267x884cx7684x7a0bx5e8fx63a8x5230x540ex53f0x2014x2014stdasync" ebook-toc-level-2="" heading="将执行的程序推到后台——std::async"><div><h1 class="mume-header" id="%E5%B0%86%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%8E%A8%E5%88%B0%E5%90%8E%E5%8F%B0stdasync">将执行的程序推到后台——std::async</h1>

<p>当我们想要将一些可以执行的代码放在后台，可以用线程将这段程序运行起来。然后，我们就等待运行的结果就好：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">std<span class="token double-colon punctuation">::</span>thread t <span class="token punctuation">{</span>my_function<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// do something else</span>
t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// wait for thread to finish</span>
</pre><p>这里<code>t.join()</code>并不会给我们<code>my_function</code>函数的返回值。为了获取返回值，需要先实现<code>my_function</code>函数，然后将其返回值存储到主线程能访问到的地方。如果这样的情况经常发生，我们就要重复的写很多代码。</p>
<p>C++11之后，<code>std::async</code>能帮我们完成这项任务。我们将写一个简单的程序，并使用异步函数，让线程在同一时间内做很多事情。<code>std::async</code>其实很强大，让我们先来了解其一方面。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将在一个程序中并发进行多个不同事情，不显式创建线程，这次使用<code>std::async</code>和<code>std::future</code>：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p>实现了三个函数，算是完成些很有趣的任务。第一个函数能够接收一个字符串，并且创建一个对于字符串中的字符进行统计的直方图：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> map<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> <span class="token function">histogram</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    map<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span> m<span class="token punctuation">;</span>
    
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span> m<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-return">return</span> m<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>第二个函数也能接收一个字符串，并返回一个排序后的副本：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> string <span class="token function">sorted</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">sort</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>第三个函数会对传入的字符串中元音字母进行计数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-bool">bool</span> <span class="token function">is_vowel</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> vowels<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">"aeiou"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">end</span><span class="token punctuation">(</span>vowels<span class="token punctuation">)</span> <span class="token operator">!=</span>
    		<span class="token function">find</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>vowels<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>vowels<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-static">static</span> size_t <span class="token function">vowels</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token function">count_if</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> is_vowel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们从标准输入中获取字符串。为了不让输入字符串分段，我们禁用了<code>ios::skipws</code>。这样就能得到一个很长的字符串，并且不管这个字符串中有多少个空格。我们会对结果字符串使用<code>pop_back</code>，因为这种方式会让一个字符串中包含太多的终止符：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cin<span class="token punctuation">.</span><span class="token function">unsetf</span><span class="token punctuation">(</span>ios<span class="token double-colon punctuation">::</span>skipws<span class="token punctuation">)</span><span class="token punctuation">;</span>
    string input <span class="token punctuation">{</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cin<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    input<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了获取函数的返回值，并加快对输入字符串的处理速度，我们使用了异步的方式。<code>std::async</code>函数能够接收一个策略和一个函数，以及函数对应的参数。我们对于这个三个函数均使用<code>launch::async</code>策略。并且，三个函数的输入参数是完全相同的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-auto">auto</span> <span class="token function">hist</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span>
    				histogram<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">sorted_str</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span>
    				sorted<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">vowel_count</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span>
    				vowels<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>async</code>的调用会立即返回，因为其并没有执行我们的函数。另外，准备好同步的结构体，用来获取函数所返回的结果。目前的结果使用不同的线程并发的进行计算。此时，我们可以做其他事情，之后再来获取函数的返回值。<code>hist</code>，<code>sorted_str</code>和<code>vowel_count</code>分别为函数<code>histogram</code>，<code>sorted</code> 和<code>vowels</code>的返回值，不过其会通过<code>std::async</code>包装入<code>future</code>类型中。这个对象表示在未来某个时间点上，对象将会获取返回值。通过对<code>future</code>对象使用<code>.get()</code>，我们将会阻塞主函数，直到相应的值返回，然后再进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>c<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">:</span> hist<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Sorted string: "</span>
        <span class="token operator">&lt;&lt;</span> <span class="token function">quoted</span><span class="token punctuation">(</span>sorted_str<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span>
        <span class="token operator">&lt;&lt;</span> <span class="token string">"Total vowels: "</span>
        <span class="token operator">&lt;&lt;</span> vowel_count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行代码，就能得到如下的输出。我们使用一个简短的字符串的例子时，代码并不是真正的在并行，但这个例子中，我们能确保代码是并发的。另外，程序的结构与串行版本相比，并没有改变多少：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ echo <span class="token string">"foo bar baz foobazinga"</span> <span class="token operator">|</span> <span class="token punctuation">.</span><span class="token operator">/</span>async
 <span class="token operator">:</span> <span class="token number">3</span>
a<span class="token operator">:</span> <span class="token number">4</span>
b<span class="token operator">:</span> <span class="token number">3</span>
f<span class="token operator">:</span> <span class="token number">2</span>
g<span class="token operator">:</span> <span class="token number">1</span>
i<span class="token operator">:</span> <span class="token number">1</span>
n<span class="token operator">:</span> <span class="token number">1</span>
o<span class="token operator">:</span> <span class="token number">4</span>
r<span class="token operator">:</span> <span class="token number">1</span>
z<span class="token operator">:</span> <span class="token number">2</span>
Sorted string<span class="token operator">:</span> <span class="token string">"   aaaabbbffginoooorzz"</span>
Total vowels<span class="token operator">:</span> <span class="token number">9</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>如果你没有使用过<code>std::async</code>，那么代码可以简单的写成串行代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">hist</span> <span class="token punctuation">(</span><span class="token function">histogram</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">sorted_str</span> <span class="token punctuation">(</span><span class="token function">sorted</span><span class="token punctuation">(</span> input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">vowel_count</span> <span class="token punctuation">(</span><span class="token function">vowels</span><span class="token punctuation">(</span> input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>c<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">:</span> hist<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Sorted string: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">quoted</span><span class="token punctuation">(</span>sorted_str<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Total vowels: "</span> <span class="token operator">&lt;&lt;</span> vowel_count <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><p>下面的代码，则是并行的版本。我们将三个函数使用<code>async(launch::async, ...)</code>进行包装。这样三个函数都不会由主函数来完成。此外，<code>async</code>会启动新线程，并让线程并发的完成这几个函数。这样我们只需要启动一个线程的开销，就能将对应的工作放在后台进行，而后可以继续执行其他代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">hist</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> histogram<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">sorted_str</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> sorted<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">vowel_count</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> vowels<span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>c<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">:</span> hist<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Sorted string: "</span>
    <span class="token operator">&lt;&lt;</span> <span class="token function">quoted</span><span class="token punctuation">(</span>sorted_str<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span>
    <span class="token operator">&lt;&lt;</span> <span class="token string">"Total vowels: "</span>
    <span class="token operator">&lt;&lt;</span> vowel_count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><p>例如<code>histogram</code>函数则会返回一个<code>map</code>实例，<code>async(..., histogram, ...)</code>将返回给我们的<code>map</code>实例包装进之前就准备好的<code>future</code>对象中。<code>future</code>对象时一种空的占位符，直到线程执行完函数返回时，才有具体的值。结果<code>map</code>将会返回到<code>future</code>对象中，所以我们可以对对象进行访问。<code>get</code>函数能让我们得到被包装起来的结果。</p>
<p>让我们来看一个更加简单的例子。看一下下面的代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">x</span> <span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">;</span>
</pre><p>与之前的代码相比，我们也可以以下面的方式完成代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">x</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> f<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>这都是最基本的。后台执行的方式可能要比标准C++出现还要早。当然，还有一个问题要解决：<code>launch::async</code>是什么东西？<code>launch::async</code>是一个用来定义执行策略的标识。其有两种独立方式和一种组合方式：</p>
<table>
<thead>
<tr>
<th>策略选择</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/thread/launch">launch::async</a></td>
<td>运行新线程，以异步执行任务</td>
</tr>
<tr>
<td><a href="http://zh.cppreference.com/w/cpp/thread/launch">launch::deferred</a></td>
<td>在调用线程上执行任务(惰性求值)。在对<code>future</code>调用<code>get</code>和<code>wait</code>的时候，才进行执行。如果什么都没有发生，那么执行函数就没有运行。</td>
</tr>
<tr>
<td>launch::async | launch::deferred</td>
<td>具有两种策略共同的特性，STL的<code>async</code>实现可以的选择策略。当没有提供策略时，这种策略就作为默认的选择。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note：</p>
<p>不使用策略参数调用<code>async(f, 1, 2, 3)</code>，我们将会选择都是用的策略。<code>async</code>的实现可以自由的选择策略。这也就意味着，我们不能确定任务会执行在一个新的线程上，还是执行在当前线程上。</p>
</blockquote>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>还有件事情我们必须要知道，假设我们写了如下的代码：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>这就会让<code>f</code>和<code>g</code>函数并发执行(这个例子中，我们并不关心其返回值)。运行这段代码时，代码会阻塞在这两个调用上，这并不是我们想看到的情况。</p>
<p>所以，为什么会阻塞呢？<code>async</code>不是非阻塞式、异步的调用吗？没错，不过这里有点特殊：当对一个<code>async</code>使用<code>launch::async</code>策略时，获取一个<code>future</code>对象，之后其析构函数将会以阻塞式等待方式运行。</p>
<p>这也就意味着，这两次调用阻塞的原因就是，<code>future</code>生命周期只有一行的时间！我们可以以获取其返回值的方式，来避免这个问题，从而让<code>future</code>对象的生命周期更长。</p>
</div></div><div id="ebook-heading-x5b9ex73b0x751fx4ea7x8005x6d88x8d39x8005x6a21x578bx2014x2014stdcondition_variable" ebook-toc-level-2="" heading="实现生产者/消费者模型——std::condition_variable"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8Bstdcondition_variable">实现生产者/消费者模型——std::condition_variable</h1>

<p>本节中，我们将使用多线程实现一个经典的生产者/消费者模型。其过程就是一个生产者线程将商品放到队列中，然后另一个消费者线程对这个商品进行消费。如果不需要生产，生产者线程休眠。如果队列中没有商品能够消费，消费者休眠。</p>
<p>这里两个线程都需要对同一个队列进行修改，所以我们需要一个互斥量来保护这个队列。</p>
<p>需要考虑的事情是：如果队列中没有商品了，那么消费者做什么呢？需要每秒对队列进行检查，直到看到新的商品吗？当然，我们可以通过生产者触发一些事件叫醒消费者，这样消费者就能在第一时间获取到新的商品。</p>
<p>C++11中提供了一个很不错的数据结构<code>std::condition_variable</code>，其很适合处理这样的情况。本节中，我们实现一个简单的生产者/消费者应用，来对这个数据结构进行使用。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将实现一个单生产者/消费者程序，每个角色都有自己的线程：</p>
<ol>
<li>
<p>包含必要的头文件，并且声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tuple&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> chrono_literals<span class="token punctuation">;</span>
</pre></li>
<li>
<p>队列进行实例化，并且队列<code>q</code>里只放简单的数字。生产者将商品放入队列中，消费者将商品从队列中取出。为了进行同步，我们需要一个互斥量。这就需要我们对<code>condition_variable</code>进行实例化，其变量名为<code>cv</code>。<code>finished</code>变量将会告诉生产者，无需在继续生产：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">queue<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> q<span class="token punctuation">;</span>
mutex mut<span class="token punctuation">;</span>
condition_variable cv<span class="token punctuation">;</span>
<span class="token keyword keyword-bool">bool</span> finished <span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>首先，我们来实现一个生产者函数。其能接受一个参数<code>items</code>，其会限制生产者生产的最大数量。一个简单的循环中，我们将会隔100毫秒生产一个商品，这个耗时就是在模拟生产的复杂性。然后，我们会对队列的互斥量进行上锁，并同步的对队列进行访问。成功的生产后，将商品加入队列时，我们需要调用<code>cv.notify_all()</code>，函数会叫醒所有消费线程。我们将在后面看到消费者那边是如何工作的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">producer</span><span class="token punctuation">(</span>size_t items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> items<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">100</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">{</span>
            lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> lk <span class="token punctuation">{</span>mut<span class="token punctuation">}</span><span class="token punctuation">;</span>
            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        cv<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>生产完所有商品后，我们会将互斥量再度上锁，因为需要对<code>finished</code>位进行设置。然后，再次调用<code>cv.notify_all()</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token punctuation">{</span>
        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> lk <span class="token punctuation">{</span>mut<span class="token punctuation">}</span><span class="token punctuation">;</span>
        finished <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cv<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在来实现消费者函数。因为只是对队列上的数值进行消费，直到消费完所有的数值，所以这个函数不需要参数。当<code>finished</code>未被设置时，循环会持续执行，并且会对保护队列的互斥量进行上锁，将对队列和<code>finished</code>标识同时进行保护。当互斥量上锁，则锁就会调用<code>cv.wait</code>，并以Lambda表达式为参数。这个Lambda表达式其实就是个条件谓词，如果生产者线程还在继续工作，并且还有商品在队列上，消费者线程就不能停下来：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> l <span class="token punctuation">{</span>mut<span class="token punctuation">}</span><span class="token punctuation">;</span>
        
        cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> finished<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><ol start="6">
<li>
<p><code>cv.wait</code>的调用会对锁进行解锁，并且会等到给予的条件达成时才会继续运行。然后，其会再次对互斥量上锁，并对队列上的商品进行消费，直到队列为空。如果生成者还在继续生成，那么这个循环可能会一直进行下去。否则，当<code>finished</code>被设置时，循环将会终止，这也就表示生产者不会再进行生产：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Got "</span> <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            	<span class="token operator">&lt;&lt;</span> <span class="token string">" from queue.\n"</span><span class="token punctuation">;</span>
            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们让生产者生产10个商品。然后，我们就等待程序的结束：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    thread t1 <span class="token punctuation">{</span>producer<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    thread t2 <span class="token punctuation">{</span>consumer<span class="token punctuation">}</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"finished!\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们将会得到下面的输出。当程序在运行阶段时，我们将看到每一行，差不多隔100毫秒打印出来，因为生产者需要时间进行生产：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>producer_consumer
Got <span class="token number">0</span> from queue<span class="token punctuation">.</span>
Got <span class="token number">1</span> from queue<span class="token punctuation">.</span>
Got <span class="token number">2</span> from queue<span class="token punctuation">.</span>
Got <span class="token number">3</span> from queue<span class="token punctuation">.</span>
Got <span class="token number">4</span> from queue<span class="token punctuation">.</span>
Got <span class="token number">5</span> from queue<span class="token punctuation">.</span>
Got <span class="token number">6</span> from queue<span class="token punctuation">.</span>
Got <span class="token number">7</span> from queue<span class="token punctuation">.</span>
Got <span class="token number">8</span> from queue<span class="token punctuation">.</span>
Got <span class="token number">9</span> from queue<span class="token punctuation">.</span>
finished<span class="token operator">!</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节中，我们只启动了两个线程。第一个线程会生产一些商品，并放到队列中。另一个则是从队列中取走商品。当其中一个线程需要对队列进行访问时，其否需要对公共互斥量<code>mut</code>进行上锁，这样才能对队列进行访问。这样，我们就能保证两个线程不能再同时对队列进行操作。</p>
<p>除了队列和互斥量，我们还声明了2个变量，其也会对生产者和消费者有所影响：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">queue<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> q<span class="token punctuation">;</span>
mutex mut<span class="token punctuation">;</span>
condition_variable cv<span class="token punctuation">;</span>
<span class="token keyword keyword-bool">bool</span> finished <span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p><code>finished</code>变量很容易解释。当其设置为true时，生产者则会对固定数量的产品进行生产。当消费者看到这个值为true的时候，其就要将队列中的商品全部消费完。但是<code>condition_variable cv</code>代表了什么呢？我们在两个不同上下文中使用<code>cv</code>。其中一个上下文则会去等待一个特定的条件，并且另一个会达成对应的条件。</p>
<p>消费者这边将会等待一个特殊的条件。消费者线程会在对互斥量<code>mut</code>使用<code>unique_lock</code>上锁后，进行阻塞循环。然后，会调用<code>cv.wait</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> l <span class="token punctuation">{</span>mut<span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> finished<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token comment">// consume</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre><p>我们写了下面一段代码，这上下来两段代码看起来是等价的。我们会在后面了解到，这两段代码真正的区别到底在哪里：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> l <span class="token punctuation">{</span>mut<span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        l<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        l<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token comment">// consume</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre><p>这就意味着，我们先要进行上锁，然后对我们的应对方案进行检查：</p>
<ol>
<li>还有商品能够消费吗？有的话，继续持有锁，消费，释放锁，结束。</li>
<li>如果没有商品可以消费，但是生产者依旧存在，释放互斥锁，也就是给生产者一个机会向队列中添加商品。然后，尝试再对现状进行检查，如果现状有变，则跳转到1方案中。</li>
</ol>
<p><code>cv.wait</code>为什么与<code>while(q.empty() &amp;&amp; ... )</code>不等价呢？因为在<code>wait</code>不需要再循环中持续的进行上锁和解锁的循环。如果生产者线程处于未激活状态时，这就会导致互斥量持续的被上锁和解锁，这样的操作是没有意义的，而且还会耗费掉不必要的CPU周期。</p>
<p><code>cv.wait(lock, predicate)</code>将会等到<code>predicate()</code>返回true时，结束等待。不过其不会对<code>lock</code>持续的进行解锁与上锁的操作。为了将使用<code>wait</code>阻塞的线程唤醒，我们就需要使用<code>condition_variable</code> 对象，另一个线程会对同一个对象调用<code>notify_one()</code>或<code>notify_all()</code>。等待中的线程将从休眠中醒来，并检查<code>predicate()</code>条件是否成立。</p>
<p><code>wait</code>还有一个很好的地方在于，如果出现了伪唤醒操作，那么线程则会再次进行休眠状态。这也就是当我们发出了过多的叫醒信号时，其不会对程序流有任何影响(但是会影响到性能)。</p>
<p>生产者端，在向队列输出商品后，调用<code>cv.notify_all()</code>，并且在生产最后一个商品时，将<code>finished</code>设置为true，这就等于引导了消费者进行消费。</p>
</div></div><div id="ebook-heading-x5b9ex73b0x591ax751fx4ea7x8005x591ax6d88x8d39x8005x6a21x578bx2014x2014stdcondition_variable" ebook-toc-level-2="" heading="实现多生产者/多消费者模型——std::condition_variable"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8Bstdcondition_variable">实现多生产者/多消费者模型——std::condition_variable</h1>

<p>让我们再来回顾一下生产者/消费者问题，这要比上一节的问题更加复杂。我们创建了多个生成这和多个消费者。并且，我们定义的队列没有限制上限。</p>
<p>当队列中没有商品时，消费者会处于等待状态，而当队列中没有空间可以盛放商品时，生产者也会处于等待状态。</p>
<p>我们将会使用多个<code>std::condition_variable</code>对象来解决这个问题，不过使用的方式与上节有些不同。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将实现一个类似于上节的程序，这次我们有多个生产者和消费者：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> chrono_literals<span class="token punctuation">;</span>
</pre></li>
<li>
<p>接下来从本章的其他小节中拿过来一个同步打印的辅助类型，因为其能帮助我们在大量并发时进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">pcout</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword keyword-public">public</span> <span class="token class-name">stringstream</span></span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-inline">inline</span> mutex cout_mutex<span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">pcout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> l <span class="token punctuation">{</span>cout_mutex<span class="token punctuation">}</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>所有生产者都会将值写入到同一个队列中，并且所有消费者也会从这个队列中获取值。对于这个队列，我们需要使用一个互斥量对队列进行保护，并设置一个标识，其会告诉我们生产者是否已经停止生产：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">queue<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> q<span class="token punctuation">;</span>
mutex q_mutex<span class="token punctuation">;</span>
<span class="token keyword keyword-bool">bool</span> production_stopped <span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将在程序中使用两个<code>condition_variable</code>对象。单生产者/消费者的情况下，只需要一个<code>condition_variable</code>告诉我们队列上面摆放了新商品。本节的例子中，我们将来处理更加复杂的情况。我们需要生产者持续生产，以保证队列上一直有可消费的商品存在。如果商品囤积到一定程度，则生产者休息。<code>go_consume</code>变量就用来提醒消费者消费的，而<code>go_produce</code>则是用来提醒生产者进行生产的：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">condition_variable go_produce<span class="token punctuation">;</span>
condition_variable go_consume<span class="token punctuation">;</span>
</pre></li>
<li>
<p>生产者函数能够接受一个生产者ID，所要生产的商品数量，以及囤积商品值的上限。然后，生产者就会进入循环生产阶段。这里，首先其会对队列的互斥量进行上锁，然后在通过调用<code>go_produce.wait</code>对互斥量进行解锁。队列上的商品数量未达到囤积阈值时，满足等待条件：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">producer</span><span class="token punctuation">(</span>size_t id<span class="token punctuation">,</span> size_t items<span class="token punctuation">,</span> size_t stock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> items<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>q_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        go_produce<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span>
        	<span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> stock<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>生产者开始生产后，就会有商品放入队列中。队列商品的表达式为<code>id * 100 + i</code>。因为百位和线程id强相关，这样我们就能了解到哪些商品是哪些生产者生产的。我们也能将生产事件打印到终端上。格式看起来可能有些奇怪，不过其会与消费者打印输出对齐：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>id <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
		pcout<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" Producer "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">" --&gt; item "</span>
        		<span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>生产商品之后，我们叫醒沉睡中的消费者。每个睡眠周期为90毫秒，这用来模拟生产者生产商品的时间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        go_consume<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">90</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    pcout<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"EXIT: Producer "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在来实现消费者函数，其只接受一个消费者ID作为参数。当生产者停止生产，或是队列上没有商品，消费者就会继续等待。队列上没有商品时，生产者还在生产的话，那么可以肯定的是，队列上肯定会有新商品的产生：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span>size_t id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>production_stopped <span class="token operator">||</span> <span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>q_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>对队列的互斥量上锁之后，我们将会在等待<code>go_consume</code>事件变量时对互斥量进行解锁。Lambda表达式表明，当队列中有商品的时候我们就会对其进行获取。第二个参数<code>1s</code>说明，我们并不想等太久。如果等待时间超过1秒，我们将不会等待。当谓词条件达成，则<code>wait_for</code>函数返回；否则就会因为超时而放弃等待。如果队列中有新商品，我们将会获取这个商品，并进行相应的打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">		<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>go_consume<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token number">1</span>s<span class="token punctuation">,</span>
				<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			pcout<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" item "</span>
					<span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
					<span class="token operator">&lt;&lt;</span> <span class="token string">" --&gt; Consumer "</span>
					<span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
			q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>商品被消费之后，我们将会提醒生产者，并进入130毫秒的休眠状态，这个时间用来模拟消费时间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">            go_produce<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">130</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    pcout<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"EXIT: Producer "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们对工作线程和消费线程各自创建一个<code>vector</code>:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span> workers<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span> consumers<span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后，我们创建3个生产者和5个消费者：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	workers<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>producer<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	consumers<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>consumer<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们会先让生产者线程终止。然后返回，并对<code>production_stopped</code>标识进行设置，这将会让消费者线程同时停止。然后，我们要将这些线程进行回收，然后退出程序：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>t <span class="token operator">:</span> workers<span class="token punctuation">)</span> <span class="token punctuation">{</span> t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    production_stopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>t <span class="token operator">:</span> consumers<span class="token punctuation">)</span> <span class="token punctuation">{</span> t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们将获得如下的输出。输出特别长，我们进行了截断。我们能看到生产者偶尔会休息一下，并且消费者会消费掉对应的商品，直到再次生产。若是将生产者/消费者的休眠时间进行修改，则会得到完全不一样的结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>multi_producer_consumer
Producer <span class="token number">0</span> <span class="token operator">--</span><span class="token operator">&gt;</span> item <span class="token number">0</span>
Producer <span class="token number">1</span> <span class="token operator">--</span><span class="token operator">&gt;</span> item <span class="token number">100</span>
item <span class="token number">0</span> <span class="token operator">--</span><span class="token operator">&gt;</span> Consumer <span class="token number">0</span>
Producer <span class="token number">2</span> <span class="token operator">--</span><span class="token operator">&gt;</span> item <span class="token number">200</span>
item <span class="token number">100</span> <span class="token operator">--</span><span class="token operator">&gt;</span> Consumer <span class="token number">1</span>
item <span class="token number">200</span> <span class="token operator">--</span><span class="token operator">&gt;</span> Consumer <span class="token number">2</span>
Producer <span class="token number">0</span> <span class="token operator">--</span><span class="token operator">&gt;</span> item <span class="token number">1</span>
Producer <span class="token number">1</span> <span class="token operator">--</span><span class="token operator">&gt;</span> item <span class="token number">101</span>
item <span class="token number">1</span> <span class="token operator">--</span><span class="token operator">&gt;</span> Consumer <span class="token number">0</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Producer <span class="token number">0</span> <span class="token operator">--</span><span class="token operator">&gt;</span> item14
EXIT<span class="token operator">:</span> Producer <span class="token number">0</span>
Producer <span class="token number">1</span> <span class="token operator">--</span><span class="token operator">&gt;</span> item <span class="token number">114</span>
EXIT<span class="token operator">:</span> Producer <span class="token number">1</span>
item14 <span class="token operator">--</span><span class="token operator">&gt;</span> Consumer <span class="token number">0</span>
Producer <span class="token number">2</span> <span class="token operator">--</span><span class="token operator">&gt;</span> item <span class="token number">214</span>
EXIT<span class="token operator">:</span> Producer <span class="token number">2</span>
item <span class="token number">114</span> <span class="token operator">--</span><span class="token operator">&gt;</span> Consumer <span class="token number">1</span>
item <span class="token number">214</span> <span class="token operator">--</span><span class="token operator">&gt;</span> Consumer <span class="token number">2</span>
EXIT<span class="token operator">:</span> Consumer <span class="token number">2</span>
EXIT<span class="token operator">:</span> Consumer <span class="token number">3</span>
EXIT<span class="token operator">:</span> Consumer <span class="token number">4</span>
EXIT<span class="token operator">:</span> Consumer <span class="token number">0</span>
EXIT<span class="token operator">:</span> Consumer <span class="token number">1</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>这节可以作为之前章节的扩展。与单生产者和消费者不同，我们实现了M个生产者和N个消费者之间的同步。因此，程序中不是消费者因为队列中没有商品而等待，就是因为队列中囤积了太多商品让生产者等待。</p>
<p>当有多个消费者等待同一个队列中出现新的商品时，程序的模式就又和单生产者/消费者工作的模式相同了。当有一个线程对保护队列的互斥量上锁时，然后对货物进行添加或减少，这样代码就是安全的。这样的话，无论有多少线程在同时等待这个锁，对于我们来说都无所谓。生产者也同理，其中最重要的就是，队列不允许两个及两个以上的线程进行访问。</p>
<p>比单生产者/消费者原理复杂的原因在于，当商品的数量在队列中囤积到一定程度，我们将会让生产者线程停止。为了迎合这个需求，我们使用两个不同的<code>condition_variable</code>：</p>
<ol>
<li><code>go_produce</code>表示队列没有被填满，并且生产者会继续生产，而后将商品放置在队列中。</li>
<li><code>go_consume</code>表示队列已经填满，消费者可以继续消费。</li>
</ol>
<p>这样，生产者会将队列用货物填满，并且<code>go_consume</code>会用如下代码，提醒消费者线程：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>go_consume<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token number">1</span>s<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// got the event without timeout</span>
<span class="token punctuation">}</span>
</pre><p>生产者也会进行等待，直到可以再次生产：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">go_produce<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> stock<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>还有一个细节就是我们不会让消费者线程等太久。在对<code>go_consume.wait_for</code>的调用中，我们添加了超时参数，并且设置为1秒。这对于消费者来说是一种退出机制：当队列为空的状态持续多于1秒，那么就可能没有生产者在工作。</p>
<p>这个处理起来很简单，代码会尽可能让队列中商品的数量达到阈值的上限。更复杂的程序中，当商品的数量为阈值上限的一半时，消费者线程会对生产者线程进行提醒。这样生产者就会在队列为空前继续生产。</p>
<p><code>condition_variable</code>帮助我们完美的解决了一个问题：当一个消费者触发了<code>go_produce</code>的提醒，那么将会有很多生产者竞争的去生产下一个商品。如果只需要生产一个商品，那么只需要一个生产者就好。当<code>go_produce</code>被触发时，所有生产者都争相生产这一个商品，我们将会看到的情况就是商品在队列中的数量超过了阈值的上限。</p>
<p>我们试想一下这种情况，我们有<code>(max - 1)</code>个商品在队列中，并且想在要一个商品将队列填满。不论是一个消费者线程调用了<code>go_produce.notify_one()</code>(只叫醒一个等待线程)或<code>go_produce.notify_all()</code>(叫醒所有等待的线程)，都需要保证只有一个生产者线程调用了<code>go_produce.wait</code>，因为对于其他生成线程来说，一旦互斥锁解锁，那么<code>q.size() &lt; stock</code>(stock货物阈值上限)的条件将不复存在。</p>
</div></div><div id="ebook-heading-x5e76x884casciix66fcx5fb7x5c14x5e03x7f57x7279x6e32x67d3x5668x2014x2014stdasync" ebook-toc-level-2="" heading="并行ASCII曼德尔布罗特渲染器——std::async"><div><h1 class="mume-header" id="%E5%B9%B6%E8%A1%8Cascii%E6%9B%BC%E5%BE%B7%E5%B0%94%E5%B8%83%E7%BD%97%E7%89%B9%E6%B8%B2%E6%9F%93%E5%99%A8stdasync">并行ASCII曼德尔布罗特渲染器——std::async</h1>

<p>还记得第6章中的<a href="file:///F:/%E6%96%87%E6%A1%A3%E6%95%99%E7%A8%8B/C++/CPP-17-STL-cookbook-master/content/chapter9/content/chapter6/chapter6-5-chinese.md">ASCII曼德尔布罗特渲染器</a>吗？本节中，我们将使用多线程来加速其计算的过程。</p>
<p>原始代码中会限定每个坐标的迭代次数，坐标的迭代会让程序变得很慢，现在我们使用并行方式对其进行实现。</p>
<p>然后，我们对代码做少量的修改，并且将<code>std::async</code>和<code>std::future</code>加入到程序中，让程序运行的更快。想要完全理解本节，就要对原始的程序有个较为完整的了解。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将对曼德尔布罗特渲染器进行升级。首先，要提升对选定坐标迭代计算的次数。然后，通过程序并行化，来提高运行的速度：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;complex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>scaler</code> 和<code>scaled_cmplx</code>没有任何改动：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-using">using</span> cmplx <span class="token operator">=</span> complex<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">scaler</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> min_from<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> max_from<span class="token punctuation">,</span>
					<span class="token keyword keyword-double">double</span> min_to<span class="token punctuation">,</span> <span class="token keyword keyword-double">double</span> max_to<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> w_from <span class="token punctuation">{</span>max_from <span class="token operator">-</span> min_from<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-double">double</span> w_to <span class="token punctuation">{</span>max_to <span class="token operator">-</span> min_to<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-int">int</span> mid_from <span class="token punctuation">{</span><span class="token punctuation">(</span>max_from <span class="token operator">-</span> min_from<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> min_from<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword keyword-const">const</span> <span class="token keyword keyword-double">double</span> mid_to <span class="token punctuation">{</span><span class="token punctuation">(</span>max_to <span class="token operator">-</span> min_to<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span> <span class="token operator">+</span> min_to<span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> from<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword keyword-return">return</span> <span class="token keyword keyword-double">double</span><span class="token punctuation">(</span>from <span class="token operator">-</span> mid_from<span class="token punctuation">)</span> <span class="token operator">/</span> w_from <span class="token operator">*</span> w_to <span class="token operator">+</span> mid_to<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">B</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">scaled_cmplx</span><span class="token punctuation">(</span>A scaler_x<span class="token punctuation">,</span> B scaler_y<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword keyword-return">return</span> cmplx<span class="token punctuation">{</span><span class="token function">scaler_x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">scaler_y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p><code>mandelbrot_iterations</code>函数中会增加迭代的次数，为的就是增加计算负荷：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">mandelbrot_iterations</span><span class="token punctuation">(</span>cmplx c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cmplx z <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    size_t iterations <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> size_t max_iterations <span class="token punctuation">{</span><span class="token number">100000</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> iterations <span class="token operator">&lt;</span> max_iterations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>iterations<span class="token punctuation">;</span>
        z <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> iterations<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中的部分代码也不需要进行任何修改：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> size_t w <span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-const">const</span> size_t h <span class="token punctuation">{</span><span class="token number">40</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-auto">auto</span> <span class="token function">scale</span> <span class="token punctuation">(</span><span class="token function">scaled_cmplx</span><span class="token punctuation">(</span>
        <span class="token function">scaler</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">scaler</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-auto">auto</span> <span class="token function">i_to_xy</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   		<span class="token keyword keyword-return">return</span> <span class="token function">scale</span><span class="token punctuation">(</span>x <span class="token operator">%</span> w<span class="token punctuation">,</span> x <span class="token operator">/</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</pre></li>
<li>
<p><code>to_iteration_count</code>函数中，不能直接调用<code>mandelbrot_iterations(x_to_xy(x))</code>，需要使用异步函数<code>std::async</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">to_iteration_count</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span>
        			mandelbrot_iterations<span class="token punctuation">,</span> <span class="token function">i_to_xy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
</pre></li>
<li>
<p>进行最后的修改之前，函数<code>to_iteration_count</code>会返回特定坐标需要迭代的次数。那么就会返回一个<code>future</code>变量，这个变量用于在后面获取异步结果时使用。因此，需要一个<code>vector</code>来盛放所有<code>future</code>变量，所以我们就在这里添加了一个。将输出迭代器作为第三个参数传入<code>transform</code>函数，并在<code>vector</code>变量<code>r</code>中放入新的输出：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token function">v</span> <span class="token punctuation">(</span>w <span class="token operator">*</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span>future<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;&gt;</span> <span class="token function">r</span> <span class="token punctuation">(</span>w <span class="token operator">*</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">iota</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">transform</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span>
    		 to_iteration_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>accumulate</code>不会在对第二个参数中<code>size_t</code>的值进行打印，不过这次改成了<code>future&lt;size_t&gt;</code>。我们需要花点时间对这个类型进行适应(对于一些初学者来说，这里使用<code>auto&amp;</code>类型的话可能会让其产生疑惑)，之后需要调用<code>x.get()</code>来访问<code>x</code>中的值，如果<code>x</code>中的值还没计算出来，程序将会阻塞进行等待：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">binfunc</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>w<span class="token punctuation">,</span> n<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> output_it<span class="token punctuation">,</span> future<span class="token operator">&lt;</span>size_t<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span>
    		<span class="token keyword keyword-mutable">mutable</span> <span class="token punctuation">{</span>
    	<span class="token operator">*</span><span class="token operator">++</span>output_it <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">50</span> <span class="token operator">?</span> <span class="token string">'*'</span> <span class="token operator">:</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>n <span class="token operator">%</span> w <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>output_it <span class="token operator">=</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
   	 	<span class="token keyword keyword-return">return</span> output_it<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  
    <span class="token function">accumulate</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span>
    		  ostream_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>cout<span class="token punctuation">}</span><span class="token punctuation">,</span> binfunc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们也能得到和之前一样的输出。唯一不同的就是执行的速度。我们增加了原始版本的迭代次数，程序应该会更慢，不过好在有并行化的帮助，我们能够计算的更快。我的机器上有4个CPU核，并且支持超线程(也就是有8个虚拟核)，我使用GCC和clang得到了不同结果。最好的加速效果有5.3倍，最差也有3.8倍。当然，这个结果和机器的很多状态有关。</p>
</li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>理解本节代码的关键就在于下面这句和CPU强相关的代码行：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token function">transform</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">begin</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> to_iteration_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p><code>vector v</code>中包含了所有复数坐标，然后这些坐标会通过曼德尔布罗特算法进行迭代。每次的迭代结果则会保存在<code>vector r</code>中。</p>
<p>原始代码中，我们将所要绘制的分形图形保存为一维数据。代码则会对之前所有的工作结果进行打印。这也就意味着并行化是提升性能的一个关键因素。</p>
<p>唯一可能并行化的部分就是从<code>begin(v)</code>到<code>end(v)</code>的处理，每块都具有相同尺寸，并能够分布在所有核上。这样所有核将会对输入数据进行共享。如果使用并行版本的<code>std::transform</code>，就需要带上一个执行策略。不幸的是，这不是问题的正确解决方式，因为每一个曼德尔布罗特集合中的点，迭代的次数是不同的。</p>
<p>我们的方式是使用一个<code>vector</code>收集将要获取每个点所要计算的数量的<code>future</code>变量。代码中<code>vector</code>能容纳<code>w * h</code>个元素，例子中就是<code>100 * 40</code>，也就是说<code>vector</code>实例中存储了4000个<code>future</code>变量，这些变量都会在异步计算中得到属于自己的值。如果我们的系统有4000个CPU核，就可以启动4000个并发的对坐标进行迭代计算。一个常见的机器上并没有那么多核，CPU只能是异步的对于一个元素进行处理，处理完成后再继续下一个。</p>
<p><code>to_iteration_count</code>中调用异步版本的<code>transform</code>时，并不是去计算，而是对线程进行部署，然后立即获得对应的<code>future</code>对象。原始版本会在每个点上阻塞很久，因为迭代需要花费很长时间。</p>
<p>并行版本的程序，也有可能会在那里发生阻塞。打印函数所打印出的结果必须要从<code>future</code>对象中获取，为了完成这个目的，我们调用<code>x.get()</code>用来获取所有结果。诀窍就在这里：等待第一个值被打印时，其他值也同时在计算。所以，当调用<code>get()</code>返回时，下一个<code>future</code>的结果也会很快地被打印出来！</p>
<p>当<code>w * h</code>是一个非常大的数时，创建<code>future</code>对象和同步<code>future</code>对象的开销将会非常可观。本节的例子中，这里的开销并不明显。我的笔记本上有一个i7 4核超线程的CPU(也就是有8个虚拟核)，并行版本与原始版本对比有3-5倍的加速，理想的并行加速应该是8倍。当然，影响机器的因素有很多，并且不同的机器也会有不同的加速比。</p>
</div></div><div id="ebook-heading-x5b9ex73b0x4e00x4e2ax5c0fx578bx81eax52a8x5316x5e76x884cx5e93x2014x2014stdfuture" ebook-toc-level-2="" heading="实现一个小型自动化并行库——std::future"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B9%B6%E8%A1%8C%E5%BA%93stdfuture">实现一个小型自动化并行库——std::future</h1>

<p>大多数复杂的任务都能分解为很多子任务。对于所有子任务，我们可以通过画一张有向图无环图来描述哪些子任务键是有依赖的。我们来看一个例子，假设我们想要产出一个字符串<code>"foo bar foo barthis that "</code>，我们只能通过一个个字符进行产生，然后将这些词汇拼接在一起。为了完成这项工作，我们提供了三个函数<code>create</code>，<code>concat</code>和<code>twice</code>。</p>
<p>考虑到这一点，我们可以通过绘制DAG图来看一下词组间相互的依赖关系：</p>
<p><img src="./C++17 STL Cook book_files/9-12-1.png" alt=""></p>
<p>实现过程中，当一个CPU核上串行的完成这些工作并没有什么问题。通过依赖关系在多个CPU核上执行任务，当所依赖的任务未完成时，只能处于等待状态。</p>
<p>即使使用<code>std::async</code>，这样写出的代码也太无趣了。因为子任务间的依赖关系需要提前建模。本节中，我们将实现两个简单的辅助库，帮助我们将<code>create</code>，<code>concat</code>和<code>twice</code>函数转换成异步的。这样，我们就能找到一种更为优雅的方式，来设置依赖关系图。执行过程中，代码将会以一种智能的方式进行并行计算，并尽快将整个图完成。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将实现一些函数用来模拟计算敏感型任务，这些任务会互相依赖，我们的任务就是让这些任务尽可能的并行执行：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> chrono_literals<span class="token punctuation">;</span>
</pre></li>
<li>
<p>需要对输出进行同步，所以可以使用之前章节中的同步辅助函数来帮助我们：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-struct">struct</span> <span class="token class-name">pcout</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword keyword-public">public</span> <span class="token class-name">stringstream</span></span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-inline">inline</span> mutex cout_mutex<span class="token punctuation">;</span>
    
    <span class="token operator">~</span><span class="token function">pcout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> l <span class="token punctuation">{</span>cout_mutex<span class="token punctuation">}</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在，我们对三个字符串转换函数进行实现。第一个函数会通过一个C风格的字符串来创建一个<code>std::string</code>对象。我们会让这个函数休眠3秒，以模拟计算复杂度：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> string <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    pcout<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"3s CREATE "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">quoted</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">3</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span>s<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>下一个函数需要两个字符串对象作为参数，并且返回拼接后的结果。我们让其休眠5秒：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> string <span class="token function">concat</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    pcout<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"5s CONCAT "</span>
            <span class="token operator">&lt;&lt;</span> <span class="token function">quoted</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span>
            <span class="token operator">&lt;&lt;</span> <span class="token function">quoted</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">5</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>最后一个函数接收一个字符串作为参数，并返回自己和自己拼接后的结果。我们让其休眠3秒：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> string <span class="token function">twice</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    pcout<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"3s TWICE "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">quoted</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">3</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> s <span class="token operator">+</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>对于串行任务来说，这就已经准备好了，但是我们想使用并行的方式来完成。所以，我们还需要实现一些辅助函数。这里需要注意了，下面三个函数看起来有些复杂。<code>asynchronize</code>能接收一个函数<code>f</code>，并返回一个其捕获到的可调用对象。我们可以传入任意数量的参数到这个可调用的对象中，然后其会将这些参数连同<code>f</code>捕获到另一个可调用对象中，并且将这个可调用对象返回给我们。最后一个可调用对象不需要任何参数。之后，其会将参数传入<code>f</code>中，并异步的执行函数<code>f</code>:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">asynchronize</span><span class="token punctuation">(</span>F f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> <span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> f<span class="token punctuation">,</span> xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</pre></li>
<li>
<p>接下来这个函数，将会使用下一步(也就是第8步)中我们声明的函数。其能接受一个函数<code>f</code>，并且将该函数捕获到一个可调用的对象中并返回。该对象可以被多个<code>future</code>对象所调用。然后，对<code>future</code>对象使用<code>.get()</code>，来获取<code>f</code>中的结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">fut_unwrap</span><span class="token punctuation">(</span>F f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">f</span><span class="token punctuation">(</span>xs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>最后一个辅助函数能够接受一个函数<code>f</code>。其会返回一个持有<code>f</code>函数的可调用对象。这个可调用对象可以传入任意个参数，并且会将函数<code>f</code>与这些参数让另一个可调用对象获取。最后，返回给我们的可调用对象无需任何参数。然后，就可以调用<code>xs...</code>包中获取到所有可调用对象。这些对象会返回很多<code>futrue</code>，这些<code>future</code>对象需要使用<code>fut_unwarp</code>进行展开。<code>future</code>展开，并会通过<code>std::async</code>对实际函数<code>f</code>进行执行，在通过<code>future</code>返回函数<code>f</code>执行的结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">async_adapter</span><span class="token punctuation">(</span>F f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-return">return</span> <span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span>
            			<span class="token function">fut_unwrap</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">xs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>OK，完成以上工作的感觉就是“疯狂”，这种表达式的嵌套让我想起了电影《盗梦空间》的场景(上一步的代码中，Lambda表达式会继续返回一个Lambda表达式)。这段带有魔法的代码，我们会在后面来详细的了解。现在，让我们异步的使用<code>create</code>，<code>concat</code>和<code>twice</code>函数。<code>async_adapter</code>是一个非常简单的函数，其会等待<code>future</code>参数，并返回一个<code>future</code>的结果，其会将同步世界转换成异步世界。我们对<code>concat</code>和<code>twice</code>使用这个函数。我们必须对<code>create</code>使用<code>asynchronize</code>，因为其会返回一个<code>future</code>，不过我们会使用<code>future</code>对象获取到的值，而非<code>future</code>对象本身。任务的依赖链，需要从<code>create</code>开始：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">pcreate</span> <span class="token punctuation">(</span><span class="token function">asynchronize</span><span class="token punctuation">(</span>create<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">pconcat</span> <span class="token punctuation">(</span><span class="token function">async_adapter</span><span class="token punctuation">(</span>concat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">ptwice</span> <span class="token punctuation">(</span><span class="token function">async_adapter</span><span class="token punctuation">(</span>twice<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们有了可以自动并行化的函数，其与同步代码的函数名相同，不过添加了前缀<code>p</code>。现在，让我们来设置一些比较复杂依赖关系树。首先，我们创建两个字符串<code>"foo"</code>和<code>"bar"</code>，然后进行拼接，返回<code>"foo bar"</code>。在<code>twice</code>中，字符串将会和自身进行拼接。然后，创建了字符串<code>"this"</code>和<code>"that"</code>，拼接得到<code>"this that"</code>。最后，我们拼接的结果为<code>"foo bar foo bar this that"</code>，结果将会保存在变量<code>callable</code>中。最后，调用<code>callable().get()</code>进行计算，并等待返回值，然后将返回值进行打印。我们没有调用<code>callable()</code>时，计算不会开始，在我们对其进行调用后，就是见证奇迹的时刻：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-auto">auto</span> <span class="token function">result</span> <span class="token punctuation">(</span>
        <span class="token function">pconcat</span><span class="token punctuation">(</span>
            <span class="token function">ptwice</span><span class="token punctuation">(</span>
            <span class="token function">pconcat</span><span class="token punctuation">(</span>
                <span class="token function">pcreate</span><span class="token punctuation">(</span><span class="token string">"foo "</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token function">pcreate</span><span class="token punctuation">(</span><span class="token string">"bar "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">pconcat</span><span class="token punctuation">(</span>
                <span class="token function">pcreate</span><span class="token punctuation">(</span><span class="token string">"this "</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token function">pcreate</span><span class="token punctuation">(</span><span class="token string">"that "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Setup done. Nothing executed yet.\n"</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们就会看到<code>create</code>每一次调用所产生的字符串，然后其他函数也开始执行。这个过程好像是通过智能调度来完成的，整个程序使用16秒完成。如果使用串行的方式，将会使用30s完成。需要注意的是，我们使用4核的机器来运行程序，也就是有4次<code>create</code>调用在同时进行。如果机器没有太多和CPU，那么运行时间会更长：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>chains
Setup done<span class="token punctuation">.</span> Nothing executed yet<span class="token punctuation">.</span>
<span class="token number">3</span>s CREATE <span class="token string">"foo "</span>
<span class="token number">3</span>s CREATE <span class="token string">"bar "</span>
<span class="token number">3</span>s CREATE <span class="token string">"this "</span>
<span class="token number">3</span>s CREATE <span class="token string">"that "</span>
<span class="token number">5</span>s CONCAT <span class="token string">"this "</span> <span class="token string">"that "</span>
<span class="token number">5</span>s CONCAT <span class="token string">"foo "</span> <span class="token string">"bar "</span>
<span class="token number">3</span>s TWICE<span class="token string">"foo bar "</span>
<span class="token number">5</span>s CONCAT <span class="token string">"foo bar foo bar "</span> <span class="token string">"this that "</span>
foo bar foo bar <span class="token keyword keyword-this">this</span> that
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节例子的串行版本，可能看起来如下：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    string result <span class="token punctuation">{</span>
        <span class="token function">concat</span><span class="token punctuation">(</span>
            <span class="token function">twice</span><span class="token punctuation">(</span>
                <span class="token function">concat</span><span class="token punctuation">(</span>
                    <span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"foo "</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"bar "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">concat</span><span class="token punctuation">(</span>
                <span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"this "</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"that "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>本节中，我们完成了一些辅助函数，<code>async_adapter</code>和<code>asynchronize</code>，其能帮助我们对<code>create</code>，<code>concat</code>和<code>twice</code>函数进行包装。然后调用其异步版本<code>pcreate</code>，<code>pconcat</code>和<code>ptwice</code>。</p>
<p>先不看这两个函数复杂的实现，我们先来看一下我们获得了什么。</p>
<p>串行版本的代码可能类似如下写法：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">string result <span class="token punctuation">{</span><span class="token function">concat</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><p>并行版本的写法：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">result</span> <span class="token punctuation">(</span><span class="token function">pconcat</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre><p>好了！现在就是最复杂的环节了。并行最后的结果并不是<code>string</code>，而是一个能够返回一个<code>future&lt;string&gt;</code>实例的可调用对象，我们可以对返回值调用<code>get()</code>得到函数运算后的值。这看起来可能很疯狂。</p>
<p>所以，我们为什么要返回<code>future</code>对象呢？问题在于我们的<code>create</code>，<code>concat</code>和<code>twice</code>函数运行起得来都非常慢。不过，我们通过依赖关系树可以看到，数据流还是有可以独立的部分，也就是可并行的部分。让我们来看一下下面两个例子的流水：</p>
<p><img src="./C++17 STL Cook book_files/9-12-2.png" alt=""></p>
<p>左侧边是单核的流水。所有函数一个接一个的在CPU上进行。这样时间累加起来就是30秒。</p>
<p>右侧边是多核的流水。函数会通过依赖关系并行的运行。在有4个核的机器上，我们将同时创建4个子字符串，然后对其进行拼接，等等的操作。并行版本需要16秒就能完成任务。如果我们没法让函数本身变的更快，则我们无法再进行加速。4个CPU的情况下，我们能有如此的加速，其实我们可以以更好的方式进行调度。</p>
<p>应该怎么做？</p>
<p>我们通常会写成如下的模式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">a</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> create<span class="token punctuation">,</span> <span class="token string">"foo "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">b</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> create<span class="token punctuation">,</span> <span class="token string">"bar "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">c</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> create<span class="token punctuation">,</span> <span class="token string">"this "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">d</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> create<span class="token punctuation">,</span> <span class="token string">"that "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">e</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> concat<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">f</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> concat<span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">g</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> twice<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">h</span> <span class="token punctuation">(</span><span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> concat<span class="token punctuation">,</span> g<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p><code>a</code> , <code>b</code> , <code>c</code>和 <code>d</code>都可以作为一个不错的开始，因为会创建对应的子字符串，并且会在后台同时进行创建。不幸的是，这段代码将会在初始化<code>e</code>的时候被阻塞。为了拼接<code>a</code>和<code>b</code>，我们需要调用<code>get()</code>函数来获取这两个值，函数会对程序进行阻塞，直到获得相应的值为止。这明显不是一个好方法，因为并行代码会在第一个<code>get()</code>调用时阻塞。我们需要更好的策略来解决这个问题。</p>
<p>OK，现在让我们来看看我们在例子中完成的比较复杂的辅助函数。第一个就是<code>asynchronize</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">asynchronize</span><span class="token punctuation">(</span>F f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> <span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> f<span class="token punctuation">,</span> xs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>当我们有一个函数<code>int f(int, int)</code>时，我们可以进行如下的操作：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-auto">auto</span> <span class="token function">f2</span> <span class="token punctuation">(</span> <span class="token function">asynchronize</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">f3</span> <span class="token punctuation">(</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">f4</span> <span class="token punctuation">(</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> result <span class="token punctuation">{</span> f4<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre><p><code>f2</code>就是异步版本的<code>f</code>。其调用方式与<code>f</code>完全相同。之后，其会返回可调用对象，并保存在<code>f3</code>中。现在<code>f3</code>得到了<code>f</code>和参数<code>1</code>和<code>2</code>，不过函数还没运行，只是捕获过程。</p>
<p>我们调用<code>f3()</code>时，最后就会得到一个<code>future</code>实例，因为<code>f3</code>中的返回值是<code>async(launch::async, f, 1, 2);</code>的返回值。某种意义上来说<code>f3</code>表示为<em>集获取函数和函数参数，与抛出<code>std::async</code>返回值与一身的变量</em>。</p>
<p>内部Lambda表达式只通过捕获进行获取，但不接受任何输入参数。因此，可以让任务并行的方式分发，而不会遭遇任何方式的阻塞。我们对同样复杂的<code>async_adapter</code>函数采取同样的策略：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">async_adapter</span><span class="token punctuation">(</span>F f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> <span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> <span class="token function">fut_unwrap</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">xs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p>函数能够返回一个函数<code>f</code>的模拟函数，因为其能接受相同的参数。然后，函数会返回一个可调用对象，并且也不接受任何参数，这里返回的可调用对象与其他辅助函数所返回的有所不同。</p>
<p><code>async(launch::async, fut_unwrap(f), xs()...);</code>是什么意思呢？其中<code>xs()...</code>部分意味着，所有参数都保存在<code>xs</code>包中，供可调用对象使用，并且返回的可调用对象都不需要参数。那些可调用对象通过自身的方式生产<code>future</code>变量，通过对<code>future</code>变量调用<code>get()</code>获得实际返回值。这也就是<code>fut_unwrap</code>所要完成的事情：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">fut_unwrap</span><span class="token punctuation">(</span>F f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> xs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token function">f</span><span class="token punctuation">(</span>xs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre><p><code>fut_unwrap</code>会将函数<code>f</code>转换为一个可调用对象，其能接受一组参数。函数对象执行之后可以对所有的<code>future</code>对象调用<code>.get()</code>，从而获得<code>f</code>函数实际的执行结果。</p>
<p>我们花点时间来消化一下上面的内容。当主函数中调用这些函数，使用<code>auto result (pconcat(...));</code>的方式创建调用链，将所有子字符串最后拼接成一个长字符串。这时对<code>async</code>的调用还未完成。然后，当调用<code>result()</code>时，我们则获得<code>async</code>的返回值，并对其返回值调用<code>.get()</code>，这就能保证任何线程不会发生阻塞。实际上，在<code>async</code>调用前，不会有<code>get()</code>的调用。</p>
<p>最后，我们可以对<code>result()</code>的返回值调用<code>.get()</code>，从而获取最终的结果字符串。</p>
</div></div><div id="ebook-heading-x7b2c10x7ae0-x6587x4ef6x7cfbx7edf" ebook-toc-level-1="" heading="第10章 文件系统"><div><h1 class="mume-header" id="%E7%AC%AC10%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">第10章 文件系统</h1>

<p>如果没有第三方库来帮助我们处理系统路径，那么对文件系统的编程就会非常冗余，因为我们需要处理很多的条件。</p>
<p>有些路径是绝对路径，而有些是相对路径，有时候路径还会互相包含。<code>.</code>表示当前目录，<code>..</code>表示上级目录。然后，不同系统用来分隔目录的斜杠也不同，Linux, MacOS和各种UNIX变体操作系统上使用的是<code>/</code>，而Windows下使用的是<code>\</code>，这样就会导致文件的不同。</p>
<p>因为有时程序难免要实现和文件系统相关的功能，所以C++17的STL中添加了对文件系统友好的库。其好的一点就在于可移植性，所以在一个系统中写好后，就可以在不同的系统间运行。</p>
<p>本章中，我们会了解到<code>path</code>类是如何工作的，因为其是库中最重要的角色。而后，我们将会了解到，强大但简单的<code>directory_iterator</code>和<code>recursive_directory_iterator</code>类，其会对文件操作很有帮助。最后，我们将通过一些小并简单的式例工具来完成一些与文件系统相关的任务。对简单的工具有所了解后，大家就可以构建更加复杂的工具了。</p>
</div></div><div id="ebook-heading-x5b9ex73b0x6807x51c6x5316x8defx5f84" ebook-toc-level-2="" heading="实现标准化路径"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E6%A0%87%E5%87%86%E5%8C%96%E8%B7%AF%E5%BE%84">实现标准化路径</h1>

<p>本节中我们通过一个非常简单的例子来了解<code>std::filesystem::path</code>类，并实现一个智能标准化系统路径的辅助函数。</p>
<p>本节中的例子可以在任意的文件系统中使用，并且返回一种标准化格式的路径。标准化就意味着获取的是绝对路径，路径中不包括<code>.</code>和<code>..</code>。</p>
<p>实现函数的时候，我们将会了解，当使用文件系统库的基础部分时，需要注意哪些细节。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们的程序可以从命令行参数中获得文件系统路径，并使用标准化格式进行打印：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;filesystem&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> filesystem<span class="token punctuation">;</span>
</pre></li>
<li>
<p>主函数中，会对命令行传入的参数进行检查。如果没有传入，我们将会直接返回，并在终端上打印程序具体的使用方式。当提供了一个路径，那我们将用其对<code>filesystem::path</code>对象进行实例化：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Usage: "</span> <span class="token operator">&lt;&lt;</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" &lt;path&gt;\n"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-const">const</span> path dir <span class="token punctuation">{</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>实例化<code>path</code>对象之后，还不能确定这个路径是否真实存在于计算机的文件系统中。这里我们使用了<code>filesystem::exists</code>来确认路径。如果路径不存在，我们会再次返回：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">exists</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Path "</span> <span class="token operator">&lt;&lt;</span> dir <span class="token operator">&lt;&lt;</span> <span class="token string">" does not exist.\n"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>	
</pre></li>
<li>
<p>Okay，如果完成了这个检查，我们就能确定这是一个正确的路径，并且将会对这个路径进行标准化，然后将其进行打印。<code>filesystem::canonical</code>将会为我们返回另一个<code>path</code>对象，可以直接对其进行打印，不过<code>path</code>的<code>&lt;&lt;</code>重载版本会将双引号进行打印。为了去掉双引号，我们通过<code>.c_str()</code>或<code>.string()</code>方法对路径进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> <span class="token function">canonical</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译代码并运行。当我们在家目录下输入相对地址<code>"src"</code>时，程序将会打印出其绝对路径：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>normalizer src
<span class="token operator">/</span>Users<span class="token operator">/</span>tfc<span class="token operator">/</span>src
</pre></li>
<li>
<p>当我们打印一些更复杂的路径时，比如：给定路径中包含桌面文件夹的路径，<code>..</code>，还会有<code>Documents</code>文件夹，然后在到<code>src</code>文件夹。然而，程序会打印出与上次相同的地址！</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>normalizer Desktop<span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>Documents<span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>src
<span class="token operator">/</span>Users<span class="token operator">/</span>tfc<span class="token operator">/</span>src
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>作为一个<code>std::filesystem</code>的新手，看本节的代码应该也没有什么问题。通过文件系统路径字符串初始化了一个<code>path</code>对象。<code>std::filesystem::path</code>类为文件系统库的核心，因为库中大多数函数和类与之相关。</p>
<p><code>filesystem::exists</code>函数可以用来检查给定的地址是否存在。检查文件路径的原因是，<code>path</code>对象中的地址，不确定在文件系统中是否存在。<code>exists</code>能够接受一个<code>path</code>实例，如果地址存在，则返回<code>true</code>。<code>exists</code>无论是相对地址和绝对地址都能够进行判断。</p>
<p>最后，我们使用了<code>filesystem::canonical</code>将给定路径进行标准化。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">path <span class="token function">canonical</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> path<span class="token operator">&amp;</span> p<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> path<span class="token operator">&amp;</span> base <span class="token operator">=</span> <span class="token function">current_path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p><code>canonical</code>函数能接受一个<code>path</code>对象和一个可选的第二参数，也就是另一个地址。如果<code>p</code>路径是一个相对路径，那么<code>base</code>就是其基础路径。完成这些后，<code>canonical</code>会将<code>.</code>和<code>..</code>从路径中移除。</p>
<p>打印时对标准化地址使用了<code>.c_str()</code>函数，这样我们打印出来的地址前后就没有双引号了。</p>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p><code>canonical</code>在对应地址不存在时，会抛出一个<code>filesystem_error</code>类型的异常。为了避免函数抛出异常，我们需要使用<code>exists</code>函数对提供路径进行检查。这样的检查仅仅就是为了避免函数抛出异常吗？肯定不是。</p>
<p><code>exists</code> 和<code>canonical</code>函数都能抛出<code>bad_alloc</code>异常。如果我们遇到了，那程序肯定会失败。更为重要的是，当我们对路径进行标准化处理时，其他人将对应的文件重命名或删除了，则会造成更严重的问题。这样的话，即便是之前进行过检查，<code>canonical</code>还是会抛出一个<code>filesystem_error</code>异常。</p>
<p>大多数系统函数都会有一些重载，他们能够接受相同的参数，甚至是一个<code>std::error_code</code>引用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">path <span class="token function">canonical</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> path<span class="token operator">&amp;</span> p<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> path<span class="token operator">&amp;</span> base <span class="token operator">=</span> <span class="token function">current_path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
path <span class="token function">canonical</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> path<span class="token operator">&amp;</span> p<span class="token punctuation">,</span> error_code<span class="token operator">&amp;</span> ec<span class="token punctuation">)</span><span class="token punctuation">;</span>
path <span class="token function">canonical</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>filesystem<span class="token double-colon punctuation">::</span>path<span class="token operator">&amp;</span> p<span class="token punctuation">,</span>
               <span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>filesystem<span class="token double-colon punctuation">::</span>path<span class="token operator">&amp;</span> base<span class="token punctuation">,</span>
               std<span class="token double-colon punctuation">::</span>error_code<span class="token operator">&amp;</span> ec <span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>我们可以使用<code>try-catch</code>将系统函数进行包围，手动的对其抛出的异常进行处理。需要注意的是，这里只会改变系统相关错误的动作，而无法对其他进行修改。带或不带<code>ec</code>参数，更加基于异常，例如当系统没有可分配内存时，还是会抛出<code>bad_alloc</code>异常。</p>
</div></div><div id="ebook-heading-x4f7fx7528x76f8x5bf9x8defx5f84x83b7x53d6x89c4x8303x7684x6587x4ef6x8defx5f84" ebook-toc-level-2="" heading="使用相对路径获取规范的文件路径"><div><h1 class="mume-header" id="%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96%E8%A7%84%E8%8C%83%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">使用相对路径获取规范的文件路径</h1>

<p>上一节中，我们对路径进行了标准化输出。使用了<code>filesystem::path</code>类，并且了解了如何获取路径，并进行检查，以及其他一些原理性的东西。也能帮助我们将字符串组成路径，从而对路径进行再次解析。</p>
<p><code>path</code>已经将操作系统的一些细节为我们进行了封装，不过我们还是需要了解一些细节。</p>
<p>本节我们也将了解到，如何将绝对路径和相对路径进行合并和分解。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将围绕着相对路径和绝对路径进行，从而了解<code>path</code>类的有时，以及其对应的辅助函数。</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;filesystem&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> filesystem<span class="token punctuation">;</span>
</pre></li>
<li>
<p>然后，我们实例化一个<code>path</code>对象。不过这次，路径中的文件是否存在就没有那么重要了。这里有些函数，在文件不存在的时候会抛出异常。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	path p <span class="token punctuation">{</span><span class="token string">"testdir/foobar.txt"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>现在我们来了解一下不同的文件系统库函数。<code>current_path</code>将返回我们执行程序的路径，也就是工作目录。<code>absolute</code>能接受一个相对地址，就像我们定义的<code>p</code>一样。<code>system_complete</code>在Linux，MacOS和类UNIX操作系统上与<code>absolute</code>的功能相同。在Windows下我们将获取一个带有盘符(比如<code>c:</code>)的绝对地址。<code>canonical</code>与<code>absolute</code>的功能相同，不过其删除了所有的<code>.</code>和<code>..</code>。我们可以使用如下的方式使用这些函数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current_path : "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">current_path</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token operator">&lt;&lt;</span> <span class="token string">"\nabsolute_path : "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">absolute</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
         <span class="token operator">&lt;&lt;</span> <span class="token string">"\nsystem_complete : "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">system_complete</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
         <span class="token operator">&lt;&lt;</span> <span class="token string">"\ncanonical(p) : "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">canonical</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
         <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>path</code>另一个优势在于，其对<code>/</code>操作符进行了重载。通过这种方式我们可以连接文件夹和文件。让我们组合一个，然后进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	cout <span class="token operator">&lt;&lt;</span> path<span class="token punctuation">{</span><span class="token string">"testdir"</span><span class="token punctuation">}</span> <span class="token operator">/</span> <span class="token string">"foobar.txt"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将<code>canonical</code>与合并的路径一起使用。通过给定<code>canonical</code>一个相对地址，比如<code>"foobar.txt"</code>，和一个合并的绝对地址<code>current_path() / "testdir"</code>，其将会返回给我们一个绝对地址。在另一个调用中，我们给定我么的路径为<code>p</code>(假设为<code>"testdir/foobar.txt"</code>)，并且通过<code>current_path()</code>获取当前位置的绝对路径，我们这里就使用<code>"testdir"</code>好了。其结果与<code>current_path()</code>相同，因为间接获得了绝对地址。在这两次调用中，<code>canonical</code>将会返回给我们相同的绝对地址：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token string">"canonical testdir : "</span>
     <span class="token operator">&lt;&lt;</span> <span class="token function">canonical</span><span class="token punctuation">(</span><span class="token string">"foobar.txt"</span><span class="token punctuation">,</span>
    			 <span class="token function">current_path</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token string">"testdir"</span><span class="token punctuation">)</span>
     <span class="token operator">&lt;&lt;</span> <span class="token string">"\ncanonical testdir 2 : "</span>
     <span class="token operator">&lt;&lt;</span> <span class="token function">canonical</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token function">current_path</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token string">"testdir/.."</span><span class="token punctuation">)</span>
     <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们也可以对两个非标准化的路径进行比较。<code>equivalence</code>能接受两个路径，并在内部将两个路径进行标准化，如果这两个路径相同，就会返回true，否则会返回false。这个例子中，相应的路径必须存在，否则就会抛出一个异常：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"equivalence: "</span>
         <span class="token operator">&lt;&lt;</span> <span class="token function">equivalent</span><span class="token punctuation">(</span><span class="token string">"testdir/foobar.txt"</span><span class="token punctuation">,</span>
                       <span class="token string">"testdir/../testdir/foobar.txt"</span><span class="token punctuation">)</span>
         <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行代码，将会得到如下的输出。<code>current_path()</code>会返回我笔记本上的HOME目录，因为我在这个路径下执行的程序。相对路径<code>p</code>会通过 <code>absolute_path</code>，<code>system_complete</code>和<code>canonical</code>预先进行准备。我们能看到<code>absolute_path</code>和<code>system_complete</code>的结果都一样，因为我使用的是Mac系统。在使用Windows操作系统的机器上，<code>system_complete</code>将会前置一个<code>C:</code>，或者是工作路径的磁盘盘符：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>canonical_filepath
current_path<span class="token operator">:</span> <span class="token string">"/Users/tfc"</span>
absolute_path <span class="token operator">:</span> <span class="token string">"/Users/tfc/testdir/foobar.txt"</span>
system_complete <span class="token operator">:</span> <span class="token string">"/Users/tfc/testdir/foobar.txt"</span>
<span class="token function">canonical</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token string">"/Users/tfc/testdir/foobar.txt"</span>
<span class="token string">"testdir/foobar.txt"</span>
canonical testdir <span class="token operator">:</span> <span class="token string">"/Users/tfc/testdir/foobar.txt"</span>
canonical testdir <span class="token number">2</span> <span class="token operator">:</span> <span class="token string">"/Users/tfc/testdir/foobar.txt"</span>
equivalence<span class="token operator">:</span> <span class="token number">1</span>
</pre></li>
<li>
<p>这个简单的程序中，就不对异常进行处理了。当从<code>testdir</code>文件夹中将<code>foobar.txt</code>文件删除时，程序将因为抛出异常的原因而终止。<code>canonical</code>函数需要路径真实存在。还有一个<code>weakly_canonical</code>，但其不符合我们的要求。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>canonial_filepath
current_path<span class="token operator">:</span> <span class="token string">"/Users/tfc"</span>
absolute_path <span class="token operator">:</span> <span class="token string">"/Users/tfc/testdir/foobar.txt"</span>
system_complete <span class="token operator">:</span> <span class="token string">"/Users/tfc/testdir/foobar.txt"</span>
terminate called after throwing an instance of
<span class="token string">'std::filesystem::v1::__cxx11::filesystem_error'</span>
<span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>filesystem error<span class="token operator">:</span> cannot canonicalize<span class="token operator">:</span>
No such file <span class="token operator">or</span> directory <span class="token punctuation">[</span>testdir<span class="token operator">/</span>foobar<span class="token punctuation">.</span>txt<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">/</span>Users<span class="token operator">/</span>tfc<span class="token punctuation">]</span>
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节的目的就是如何快速的组成新的路径。其主要还有通过<code>path</code>类重载的<code>/</code>操作符来完成。另外，文件系统函数的相对路径和绝对路径是一致的，并且路径中包含<code>.</code>和<code>..</code>。</p>
<p>很多函数会返回一个转换或未转换的<code>path</code>实例。我们不会将所有函数都列在这里，如果想要了解它们，去看下C++手册是个不错的选择。</p>
<p><code>path</code>类中有很多的成员函数，很值得一看。让我们来了解一下，对于一个路径来说，成员函数返回的是哪一部分。下面的图就为我们描述了在Windows和UNIX/Linux下，对应函数所返回的路径：</p>
<p><img src="./C++17 STL Cook book_files/10-2-1.png" alt=""></p>
<p>这样我们就能很容易的了解到，<code>path</code>的那个函数返回的是绝对地址。相对地址中，<code>root_path</code>，<code>root_name</code> 和 <code>root_directory</code>部分都空的。<code>relative_path</code>将会返回一个相对地址。</p>
</div></div><div id="ebook-heading-x5217x51fax76eex5f55x4e0bx7684x6240x6709x6587x4ef6" ebook-toc-level-2="" heading="列出目录下的所有文件"><div><h1 class="mume-header" id="%E5%88%97%E5%87%BA%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6">列出目录下的所有文件</h1>

<p>每个操作系统都会提供一些工具，以列出目录下的所有文件。Linux，MacOS和类UNIX的操作系统中，<code>ls</code>就是一个最简单的例子。Windows和Dos系统下，命令为<code>dir</code>。其会提供一些文件的补充信息，比如文件大小，访问权限等。</p>
<p>可以通过对文件夹的递归和文件遍历来对这样的工具进行实现。所以，让我们来试一下吧！</p>
<p>我们的<code>ls/dir</code>命令会将目录下的文件名，元素索引，以及一些访问权限标识，以及对应文件的文件大小，分别进行展示。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将实现一个很小的工具，为使用者列出对应文件夹下的所有文件。会将文件名，文件类型，大小和访问权限分别列出来。</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;filesystem&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> filesystem<span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>file_info</code>是我们要实现的一个辅助函数。其能接受一个<code>directory_entry</code>对象的引用，并从这个路径中提取相应的信息，实例化<code>file_status</code>对象(使用<code>status</code>函数)，其会包含文件类型和权限信息。最后，如果是一个常规文件，则会提取其文件大小。对于文件夹或一些特殊的文件，我们将返回大小设置为0。所有的信息都将会封装到一个元组中：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> tuple<span class="token operator">&lt;</span>path<span class="token punctuation">,</span> file_status<span class="token punctuation">,</span> size_t<span class="token operator">&gt;</span>
<span class="token function">file_info</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> directory_entry <span class="token operator">&amp;</span>entry<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token function">fs</span> <span class="token punctuation">(</span><span class="token function">status</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span>entry<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            fs<span class="token punctuation">,</span>
            <span class="token function">is_regular_file</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">file_size</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0u</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>另一个辅助函数就是<code>type_char</code>。路径不能仅表示目录和简单文本/二进制文件。操作系统提供了多种抽象类型，比如字符/块形式的硬件设备接口。STL库也提供了为此提供了很多为此函数。我们通过返回<code>'d'</code>表示文件夹，通过返回<code>'f'</code>表示普通文件等。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-char">char</span> <span class="token function">type_char</span><span class="token punctuation">(</span>file_status fs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">is_directory</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token string">'d'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">is_symlink</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token string">'l'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">is_character_file</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token string">'c'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">is_block_file</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token string">'b'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">is_fifo</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token string">'p'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">is_socket</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token string">'s'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">is_other</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token string">'o'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">is_regular_file</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token string">'f'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-return">return</span> <span class="token string">'?'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>下一个辅助函数为<code>rwx</code>。其能接受一个<code>perms</code>变量(其为文件系统库的一个<code>enum</code>类)，并且会返回一个字符串，比如<code>rwxrwxrwx</code>，用来表示文件的权限设置。<code>"rwx"</code>分别为<strong>r</strong>ead, <strong>w</strong>rite和e<strong>x</strong>ecution，分别代表了文件的权限属性。每三个字符表示一个组，也就代表对应的组或成员，能对文件进行的操作。<code>rwxrwxrwx</code>则代表着每个人多能对这个文件进行访问和修改。<code>rw-r--r--</code>代表着所有者可以的对文件进行读取和修改，不过其他人只能对其进行读取操作。我们将这些<code>读取/修改/执行</code>所代表的字母进行组合，就能形成文件的访问权限列表。Lambda表达式可以帮助我们完成重复性的检查工作，检查<code>perms</code>变量<code>p</code>中是否包含特定的掩码位，然后返回<code>'-'</code>或正确的字符。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> string <span class="token function">rwx</span><span class="token punctuation">(</span>perms p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">check</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">(</span>perms bit<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;</span> bit<span class="token punctuation">)</span> <span class="token operator">==</span> perms<span class="token double-colon punctuation">::</span>none <span class="token operator">?</span> <span class="token string">'-'</span> <span class="token operator">:</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">{</span><span class="token function">check</span><span class="token punctuation">(</span>perms<span class="token double-colon punctuation">::</span>owner_read<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">check</span><span class="token punctuation">(</span>perms<span class="token double-colon punctuation">::</span>owner_write<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">check</span><span class="token punctuation">(</span>perms<span class="token double-colon punctuation">::</span>owner_exec<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">check</span><span class="token punctuation">(</span>perms<span class="token double-colon punctuation">::</span>group_read<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">check</span><span class="token punctuation">(</span>perms<span class="token double-colon punctuation">::</span>group_write<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">check</span><span class="token punctuation">(</span>perms<span class="token double-colon punctuation">::</span>group_exec<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">check</span><span class="token punctuation">(</span>perms<span class="token double-colon punctuation">::</span>others_read<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">check</span><span class="token punctuation">(</span>perms<span class="token double-colon punctuation">::</span>others_write<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token function">check</span><span class="token punctuation">(</span>perms<span class="token double-colon punctuation">::</span>others_exec<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>最后一个辅助函数能接受一个整型的文件大小，并将其转换为跟容易读懂的模式。将其大小除以表示的对应边界，然后使用K, M或G来表示这个文件的大小：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> string <span class="token function">size_string</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    stringstream ss<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">1000000000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	ss <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">1000000000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'G'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">1000000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	ss <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">1000000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'M'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	ss <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'K'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span> ss <span class="token operator">&lt;&lt;</span> size <span class="token operator">&lt;&lt;</span> <span class="token string">'B'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-return">return</span> ss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在来实现主函数。我们会对用户在命令行输入的路径进行检查。如果没有传入，则默认为当前路径。然后，再来检查文件夹是否存在。如果不存在，就不会列出任何文件：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    path dir <span class="token punctuation">{</span>argc <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">?</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token string">"."</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">exists</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Path "</span> <span class="token operator">&lt;&lt;</span> dir <span class="token operator">&lt;&lt;</span> <span class="token string">" does not exist.\n"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在，将使用文件信息元组来填充一个<code>vector</code>。实例化一个<code>directory_iterator</code>，并且将其传入<code>path</code>对象的构造函数中。并通过目录迭代器对文件进行迭代，我们将<code>directory_entry</code>对象转换成文件信息元组，然后将其插入相应的<code>vector</code>。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    vector<span class="token operator">&lt;</span>tuple<span class="token operator">&lt;</span>path<span class="token punctuation">,</span> file_status<span class="token punctuation">,</span> size_t<span class="token operator">&gt;&gt;</span> items<span class="token punctuation">;</span>
    
    <span class="token function">transform</span><span class="token punctuation">(</span>directory_iterator<span class="token punctuation">{</span>dir<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    	<span class="token function">back_inserter</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">,</span> file_info<span class="token punctuation">)</span><span class="token punctuation">;</span>	
</pre></li>
<li>
<p>现在，将所有文件的信息都存在于<code>vector</code>之中，并且使用辅助函数将其进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>path<span class="token punctuation">,</span> status<span class="token punctuation">,</span> size<span class="token punctuation">]</span> <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">type_char</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span>
             <span class="token operator">&lt;&lt;</span> <span class="token function">rwx</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">permissions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span>
             <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> right <span class="token operator">&lt;&lt;</span> <span class="token function">size_string</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span>
             <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> path<span class="token punctuation">.</span><span class="token function">filename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
             <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，并通过命令行传入C++文档文件所在的地址。我们能了解到对应文件夹所包含的文件，因为文件夹下只有<code>'d'</code>和<code>'f'</code>作为输出的表示。这些文件具有不同的权限，并且都有不同的大小。需要注意的是，这些文件的显示顺序，是按照名字在字母表中的顺序排序，不过我们不依赖这个顺序，因为C++17标准不需要字母表排序：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>list <span class="token operator">~</span><span class="token operator">/</span>Documents<span class="token operator">/</span>cpp_reference<span class="token operator">/</span>en<span class="token operator">/</span>cpp
drwxrwxr<span class="token operator">-</span>x <span class="token number">0</span>B   algorithm
frw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span> <span class="token number">88</span>K  algorithm<span class="token punctuation">.</span>html
drwxrwxr<span class="token operator">-</span>x <span class="token number">0</span>B   atomic
frw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span> <span class="token number">35</span>K  atomic<span class="token punctuation">.</span>html
drwxrwxr<span class="token operator">-</span>x <span class="token number">0</span>B   chrono
frw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span> <span class="token number">34</span>K  chrono<span class="token punctuation">.</span>html
frw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span> <span class="token number">21</span>K  comment<span class="token punctuation">.</span>html
frw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span> <span class="token number">21</span>K  comments<span class="token punctuation">.</span>html
frw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span> <span class="token number">220</span>K compiler_support<span class="token punctuation">.</span>html
drwxrwxr<span class="token operator">-</span>x <span class="token number">0</span>B   <span class="token keyword keyword-concept">concept</span>
<span class="token class-name">frw</span><span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span> <span class="token number">67</span>K  <span class="token keyword keyword-concept">concept</span><span class="token punctuation">.</span>html
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x <span class="token number">0</span>B   container
frw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span> <span class="token number">285</span>K container<span class="token punctuation">.</span>html
drwxrwxr<span class="token operator">-</span>x <span class="token number">0</span>B   error
frw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span> <span class="token number">52</span>K  error<span class="token punctuation">.</span>html
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节中，我们迭代了文件夹中的所有文件，并且对每个文件的状态和大小进行检查。对于每个文件的操作都非常直接和简单，我们对文件夹的遍历看起来也很魔幻。</p>
<p>为了对我们的文件夹进行遍历，只是对<code>directory_iterator</code>进行实例化，然后对该对象进行遍历。使用文件系统库来遍历一个文件夹是非常简单的。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> directory_entry <span class="token operator">&amp;</span>e <span class="token operator">:</span> directory_iterator<span class="token punctuation">{</span>dir<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// do something</span>
<span class="token punctuation">}</span>
</pre><p>除了以下几点，<code>directory_iterator</code>也没有什么特别的：</p>
<ul>
<li>会对文件夹中的每个文件访问一次</li>
<li>文件中元素的遍历顺序未指定</li>
<li>文件节元素中<code>.</code>和<code>..</code>都已经被过滤掉</li>
</ul>
<p>不过，<code>directory_iterator</code>看起来是一个迭代器，并且同时具有一个可迭代的范围。为什么需要注意这个呢？对于简单的<code>for</code>循环来说，其需要一个可迭代的范围。本节例程中，我们会将其当做一个迭代器使用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token function">transform</span><span class="token punctuation">(</span>directory_iterator<span class="token punctuation">{</span>dir<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
		 <span class="token function">back_inserter</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">,</span> file_info<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>实际上，就是一个迭代器类型，只不过这个类将<code>std::begin</code>和<code>std::end</code>函数进行了重载。当调用<code>begin</code>和<code>end</code>时，其会返回相应的迭代器。虽说第一眼看起来比较奇怪，但是让这个类型的确更加有用。</p>
</div></div><div id="ebook-heading-x5b9ex73b0x4e00x4e2ax7c7bx4f3cgrepx7684x6587x672cx641cx7d22x5de5x5177" ebook-toc-level-2="" heading="实现一个类似grep的文本搜索工具"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCgrep%E7%9A%84%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7">实现一个类似grep的文本搜索工具</h1>

<p>大多数操作系统都会提供本地的搜索引擎。用户可以使用一些快捷键，对本地文件进行查找。</p>
<p>这种功能出现之前，命令行用户会通过<code>grep</code>或<code>awk</code>工具对文件进行查找。用户可以简单的输入<code>grep -r foobar .</code>，然后工具将会基于当前目录，进行递归的的查找，并显示包含有<code>"foobar"</code>名字的文件。</p>
<p>本节中，将实现这样一种应用。我们的<code>grep</code>使用命令行方式使用，并基于给定文件夹递归的对文件进行查找。然后，将找到的文件名打印出来。我们将使用线性的模式匹配方式，将匹配文件中的对应行号进行打印。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将实现小工具，用于查找与用户提供的文本段匹配的文件。这工具与UNIX中的<code>grep</code>工具类似，不过为了简单起见，其功能没有那么强大：</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;regex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;filesystem&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> filesystem<span class="token punctuation">;</span>
</pre></li>
<li>
<p>先来实现一个辅助函数，这个函数能接受一个文件地址和一个正则表达式对象，正则表达式对象用来描述我们要查找的文本段。然后，实例化一个<code>vector</code>，用于保存匹配的文件行和其对应的内容。然后，实例化一个输入文件流对象，读取文件，并进行逐行的文本匹配。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> string<span class="token operator">&gt;&gt;</span>
<span class="token function">matches</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> path <span class="token operator">&amp;</span>p<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> regex <span class="token operator">&amp;</span>re<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> string<span class="token operator">&gt;&gt;</span> d<span class="token punctuation">;</span>
    ifstream is <span class="token punctuation">{</span>p<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>通过<code>getline</code>函数对文件进行逐行读取，当字符串中包含有我们提供文本段，则<code>regex_search</code>返回true，如果匹配会将字符串和对应的行号保存在<code>vector</code>中。最后，我们将返回所有匹配的结果：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    string s<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t line <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token function">getline</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>line<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">regex_search</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> re<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	d<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> <span class="token function">move</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-return">return</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数会先对用户提供的文本段进行检查，如果这个文本段不能用，则返回错误信息：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Usage: "</span> <span class="token operator">&lt;&lt;</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" &lt;pattern&gt;\n"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>接下来，会通过输入文本创建一个正则表达式对象。如果表达式是一个非法的正则表达式，这将会导致一个异常抛出。如果触发了异常，我们将对异常进行捕获并处理：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    regex pattern<span class="token punctuation">;</span>

    <span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span> pattern <span class="token operator">=</span> regex<span class="token punctuation">{</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> regex_error <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Invalid regular expression provided.n"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在，可以对文件系统进行迭代，然后对我们提供的文本段进行匹配。使用<code>recursive_directory_iterator</code>对工作目录下的所有文件进行迭代。原理和之前章节的<code>directory_iterator</code>类似，不过会对子目录进行递归迭代。对于每个匹配的文件，我们都会调用辅助函数<code>matches</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>entry <span class="token operator">:</span>
            recursive_directory_iterator<span class="token punctuation">{</span><span class="token function">current_path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> <span class="token function">ms</span> <span class="token punctuation">(</span><span class="token function">matches</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>如果有匹配的结果，我们将会对文件地址，对应文本行数和匹配行的内容进行打印：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>number<span class="token punctuation">,</span> content<span class="token punctuation">]</span> <span class="token operator">:</span> ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> entry<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> number
        	 <span class="token operator">&lt;&lt;</span> <span class="token string">" - "</span> <span class="token operator">&lt;&lt;</span> content <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在，准备一个文件<code>foobar.txt</code>，其中包含一些测试行：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">foo
bar
baz
</pre></li>
<li>
<p>编译并运行程序，就会得到如下输出。我们在<code>/Users/tfc/testdir</code>文件夹下运行这个程序，我们先来对<code>bar</code>进行查找。在这个文件夹下，其会在<code>foobar.txt</code>的第二行和<code>testdir/dir1</code>文件夹下的另外一个文件<code>text1.txt</code>中匹配到：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>grepper bar
<span class="token operator">/</span>Users<span class="token operator">/</span>tfc<span class="token operator">/</span>testdir<span class="token operator">/</span>dir1<span class="token operator">/</span>text1<span class="token punctuation">.</span>txt<span class="token operator">:</span><span class="token number">1</span> <span class="token operator">-</span> foo bar bla blubb
<span class="token operator">/</span>Users<span class="token operator">/</span>tfc<span class="token operator">/</span>testdir<span class="token operator">/</span>foobar<span class="token punctuation">.</span>txt<span class="token operator">:</span><span class="token number">2</span> <span class="token operator">-</span> bar
</pre></li>
<li>
<p>再次运行程序，这次我们对<code>baz</code>进行查找，其会在第三行找到对应内容：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>grepper baz
<span class="token operator">/</span>Users<span class="token operator">/</span>tfc<span class="token operator">/</span>testdir<span class="token operator">/</span>foobar<span class="token punctuation">.</span>txt<span class="token operator">:</span><span class="token number">3</span> <span class="token operator">-</span> baz
</pre><h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>本节的主要任务是使用正则表达式对文件的内容进行查找。不过，让我们关注一下<code>recursive_directory_iterator</code>，因为我们会使用这个迭代器来进行本节的子文件夹的递归迭代。</p>
<p>与<code>directory_iterator</code>和<code>recursive_directory_iterator</code>迭代类似，其可以用来对子文件夹进行递归，就如其名字一样。当进入文件系统中的一个文件夹时，将会产生一个<code>directory_entry</code>实例。当递归到子文件夹时，也会产生对应的<code>directory_entry</code>实例。</p>
<p><code>recursive_directory_iterator</code>具有一些有趣的成员函数：</p>
<ul>
<li><code>depth()</code>代表我们需要迭代多少层子文件夹。</li>
<li><code>recursion_pending()</code>代表在进行当前迭代器后，是否会在进行对子文件夹进行迭代。</li>
<li><code>disable_recursion_pending()</code>当迭代器需要再对子文件夹进行迭代时，提前调用这个函数，则会让递归停止。</li>
<li><code>pop()</code>将会终止当前级别的迭代，并返回上一级目录。</li>
</ul>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>我们需要了解的另一个就是<code>directory_options</code>枚举类。<code>recursive_directory_iterator</code>能将<code>directory_options</code>的实例作为其构造函数的第二个参数，通常将<code>directory_options::none</code>作为默认值传入。其他值为：</p>
<ul>
<li><code>follow_directory_symlink</code>能允许对符号链接的文件夹进行递归迭代。</li>
<li><code>skip_permission_denied</code>这会告诉迭代器，是否跳过由于权限错误而无法访问的目录。</li>
</ul>
<p>这两个选项可以通过<code>|</code>进行组合。</p>
</div></div><div id="ebook-heading-x5b9ex73b0x4e00x4e2ax81eax52a8x6587x4ef6x91cdx547dx540dx5668" ebook-toc-level-2="" heading="实现一个自动文件重命名器"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D%E5%99%A8">实现一个自动文件重命名器</h1>

<p>本节的动机是因为我自己经常需要使用到这样的功能。我们将假日中的照片汇总在一起时，不同朋友的照片和视频都在一个文件夹中，并且每个文件的后缀看起来都不一样。一些JPEG文件有<code>.jpg</code>的扩展，而另一些为<code>.jpeg</code>，还有一些则为<code>.JPEG</code>。</p>
<p>一些人会让文件具有统一的扩展，其会使用一些有用的命令对于所有文件进行重命名。同时，我们会将使用下划线来替代空格。</p>
<p>本节中，我们将试下一个类似的工具，叫做<code>renamer</code>。其能接受一些列输入文本段，作为其替代，类似如下的方式：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ renamer jpeg jpg JPEG jpg
</pre><p>本节中，重命名器将会对当前目录进行递归，然后找到文件后缀为<code>jpeg</code>和<code>JPEG</code>的所有文件，并将这些文件的后缀统一为<code>jpg</code>。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>我们将实现一个工具，通过对文件夹的递归对于所有文件名匹配的文件进行重命名。所有匹配到的文件，都会使用用户提供的文本段进行替换。</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;regex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;filesystem&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> filesystem<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将实现一个简单的辅助函数，其能接受一个使用字符串表示的输入文件地址和一组替换对。每一个替换对都有一个文本段和其要替换文本段。对替换范围进行循环时，我们使用了<code>regex_replace</code>用于对输入字符串进行匹配，然后返回转换后的字符串。之后，我们将返回结果字符串。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-static">static</span> string <span class="token function">replace</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> T <span class="token operator">&amp;</span>replacements<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>pattern<span class="token punctuation">,</span> repl<span class="token punctuation">]</span> <span class="token operator">:</span> replacements<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	s <span class="token operator">=</span> <span class="token function">regex_replace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> pattern<span class="token punctuation">,</span> repl<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-return">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们首先对命令行的正确性进行检查。可以成对的接受命令行参数，因为我们想要匹配段和替换段相对应。<code>argv</code>的第一个元素为执行文件的名字。当用户提供了成对的匹配段和替换段时，<code>argc</code>肯定是大于3的奇数：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">3</span> <span class="token operator">||</span> argc <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Usage: "</span> <span class="token operator">&lt;&lt;</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        	 <span class="token operator">&lt;&lt;</span> <span class="token string">" &lt;pattern&gt; &lt;replacement&gt; ...\n"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>我们对输入对进行检查时，会将对应的<code>vector</code>进行填充：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>regex<span class="token punctuation">,</span> string<span class="token operator">&gt;&gt;</span> patterns<span class="token punctuation">;</span>

    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	patterns<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在，可以对整个文件系统进行遍历。简单起见，将当前目录作为遍历的默认起始地址。对于每一个文件夹入口，我们将其原始路径命名为<code>opath</code>。然后，只在没有剩余路径的情况下使用文件名，并根据之前创建的匹配列表，对对应的匹配段进行替换。我们将拷贝<code>opath</code>到<code>rpath</code>中，并且将文件名进行替换。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>entry <span class="token operator">:</span>
    		recursive_directory_iterator<span class="token punctuation">{</span><span class="token function">current_path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   		 		path opath <span class="token punctuation">{</span>entry<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    			string rname <span class="token punctuation">{</span><span class="token function">replace</span><span class="token punctuation">(</span>opath<span class="token punctuation">.</span><span class="token function">filename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    			patterns<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        
        path rpath <span class="token punctuation">{</span>opath<span class="token punctuation">}</span><span class="token punctuation">;</span>
        rpath<span class="token punctuation">.</span><span class="token function">replace_filename</span><span class="token punctuation">(</span>rname<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p>对于匹配的文件，我们将打印其重命名后的名字。当重命名后的文件存在，我们将不会对其进行处理。会跳过这个文件。当然，我们也可以添加一些数字或其他字符到地址中，从而解决这个问题：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>opath <span class="token operator">!=</span> rpath<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cout <span class="token operator">&lt;&lt;</span> opath<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" --&gt; "</span>
            	<span class="token operator">&lt;&lt;</span> rpath<span class="token punctuation">.</span><span class="token function">filename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">exists</span><span class="token punctuation">(</span>rpath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error: Can't rename."</span>
            		<span class="token string">" Destination file exists.\n"</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
            	<span class="token function">rename</span><span class="token punctuation">(</span>opath<span class="token punctuation">,</span> rpath<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们将会得到如下的输出。我的文件夹下面有一些JPEG文件，但是都是以不同的后缀名结尾，有<code>jpg</code>，<code>jpeg</code>和<code>JPEG</code>。然后，执行程序将<code>jpeg</code>和<code>JPEG</code>替换成<code>jpg</code>。这样，就可以对文件名进行统一化。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ ls
birthday_party<span class="token punctuation">.</span>jpeg holiday_in_dubai<span class="token punctuation">.</span>jpgholiday_in_spain<span class="token punctuation">.</span>jpg
trip_to_new_york<span class="token punctuation">.</span>JPEG
$ <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>renamer jpeg jpg JPEG jpg
<span class="token operator">/</span>Users<span class="token operator">/</span>tfc<span class="token operator">/</span>pictures<span class="token operator">/</span>birthday_party<span class="token punctuation">.</span>jpeg <span class="token operator">--</span><span class="token operator">&gt;</span> birthday_party<span class="token punctuation">.</span>jpg
<span class="token operator">/</span>Users<span class="token operator">/</span>tfc<span class="token operator">/</span>pictures<span class="token operator">/</span>trip_to_new_york<span class="token punctuation">.</span>JPEG <span class="token operator">--</span><span class="token operator">&gt;</span> trip_to_new_york<span class="token punctuation">.</span>jpg
$ ls
birthday_party<span class="token punctuation">.</span>jpg holiday_in_dubai<span class="token punctuation">.</span>jpg holiday_in_spain<span class="token punctuation">.</span>jpg
trip_to_new_york<span class="token punctuation">.</span>jpg
</pre></li>
</ol>
</div></div><div id="ebook-heading-x5b9ex73b0x4e00x4e2ax78c1x76d8x4f7fx7528x7edfx8ba1x5668" ebook-toc-level-2="" heading="实现一个磁盘使用统计器"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%99%A8">实现一个磁盘使用统计器</h1>

<p>我们已经实现了一个列出文件夹下所有文件的工具，不过和系统自带的工具一样，其都不会对文件夹的大小进行打印。</p>
<p>为了获取文件夹的大小，我们需要将其子文件夹进行迭代，然后将其包含的所有文件的大小进行累加，才能得到该文件夹的大小。</p>
<p>本节中，我们将实现一个工具用来做这件事。这个工具能在任意的文件夹下运行，并且对文件夹中包含的文件总体大小进行统计。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，我们将会实现一个程序用于迭代目录中的所有文件，并将所有文件的大小进行统计。对于统计一个文件的大小就很简单，但是要统计一个文件夹的大小，就需要将文件夹下的所有文件的大小进行相加。</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;filesystem&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> filesystem<span class="token punctuation">;</span>
</pre></li>
<li>
<p>我们将实现一个辅助函数使用<code>directory_entry</code>对象作为其参数，然后返回其在文件系统中对应的大小。如果传入的不是一个文件夹地址，将通过<code>file_size</code>获得文件的大小。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> size_t <span class="token function">entry_size</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> directory_entry <span class="token operator">&amp;</span>entry<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_directory</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> <span class="token function">file_size</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre></li>
<li>
<p>如果传入的是一个文件夹，需要对其中所有元素进行文件大小的计算。需要调用辅助函数<code>entry_size</code>对子文件夹进行再次递归：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-return">return</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>directory_iterator<span class="token punctuation">{</span>entry<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0u</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t accum<span class="token punctuation">,</span> <span class="token keyword keyword-const">const</span> directory_entry <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token keyword keyword-return">return</span> accum <span class="token operator">+</span> <span class="token function">entry_size</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>为了具有更好的可读性，本节使用了其他章节中的<code>size_string</code>函数。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> string <span class="token function">size_string</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    stringstream ss<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">1000000000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	ss <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">1000000000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'G'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">1000000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	ss <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">1000000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'M'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	ss <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'K'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span> ss <span class="token operator">&lt;&lt;</span> size <span class="token operator">&lt;&lt;</span> <span class="token string">'B'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-return">return</span> ss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，首先就是要检查用户通过命令行提供的文件系统路径。如果没有提供，则默认为当前文件夹。处理之前，我们会检查路径是否存在。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    path dir <span class="token punctuation">{</span>argc <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">?</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token string">"."</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">exists</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Path "</span> <span class="token operator">&lt;&lt;</span> dir <span class="token operator">&lt;&lt;</span> <span class="token string">" does not exist.\n"</span><span class="token punctuation">;</span>
    	<span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
</pre></li>
<li>
<p>现在，我们可以对所有的文件夹进行迭代，然后打印其名字和大小：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>entry <span class="token operator">:</span> directory_iterator<span class="token punctuation">{</span>dir<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> right
             <span class="token operator">&lt;&lt;</span> <span class="token function">size_string</span><span class="token punctuation">(</span><span class="token function">entry_size</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">)</span>
             <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> entry<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
             <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们将获得如下的输出。我提供了一个C++离线手册的目录，其当然具有子目录，我们可以用我们的程序对其大小进行统计：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>file_size <span class="token operator">~</span><span class="token operator">/</span>Documents<span class="token operator">/</span>cpp_reference<span class="token operator">/</span>en<span class="token operator">/</span>
<span class="token number">19</span>M c
<span class="token number">12</span>K c<span class="token punctuation">.</span>html
<span class="token number">147</span>M cpp
<span class="token number">17</span>K cpp<span class="token punctuation">.</span>html
<span class="token number">22</span>K index<span class="token punctuation">.</span>html
<span class="token number">22</span>K Main_Page<span class="token punctuation">.</span>html
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>整个程序通过<code>file_size</code>对普通的文件进行大小的统计。当程序遇到一个文件夹，其将会对子文件夹进行递归，然后通过<code>file_size</code>计算出文件夹中包含所有文件的大小。</p>
<p>有件事我们需要区别一下，当我们直接调用<code>file_size</code>时，或需要进行递归时，需要通过<code>is_directory</code>谓词进行判断。这对于只包含有普通文件和文件夹的文件夹是有用的。</p>
<p>与我们的简单程序一样，程序会在如下的情况下崩溃，因为有未处理的异常抛出：</p>
<ul>
<li><code>file_size</code>只能对普通文件和符号链接有效。否则，会抛出异常。</li>
<li><code>file_size</code>对符号链接有效，如果链接失效，函数还是会抛出异常。</li>
</ul>
<p>为了让本节的程序更加成熟，我们需要更多的防御性编程，避免遇到错误的文件和手动处理异常。</p>
</div></div><div id="ebook-heading-x8ba1x7b97x6587x4ef6x7c7bx578bx7684x7edfx8ba1x4fe1x606f" ebook-toc-level-2="" heading="计算文件类型的统计信息"><div><h1 class="mume-header" id="%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF">计算文件类型的统计信息</h1>

<p>上一节中，我们实现了一个用于统计任意文件夹中所有文件大小的工具。</p>
<p>本节中，我们将递归的对文件夹中的文件名后缀进行统计。这样对每种文件类型的文件进行个数统计，并且计算每种文件类型大小的平均值。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中将实现一个简单的工具用于对给定的文件夹进行递归，同时对所有文件的数量和大小进行统计，并通过文件后缀进行分组。最后，会对文件夹中具有的文件名扩展进行打印，并打印出有多少个对应类型扩展的文件和文件的平均大小。</p>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;filesystem&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> filesystem<span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>size_string</code>函数已经在上一节中使用过了。这里我们继续使用：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> string <span class="token function">size_string</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    stringstream ss<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">1000000000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	ss <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">1000000000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'G'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">1000000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	ss <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">1000000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'M'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	ss <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'K'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span> ss <span class="token operator">&lt;&lt;</span> size <span class="token operator">&lt;&lt;</span> <span class="token string">'B'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-return">return</span> ss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>然后，实现一个函数用于接受一个<code>path</code>对象，并对该路径下的所有文件进行遍历。我们使用一个<code>map</code>来收集所有的信息，用对应的扩展名与总体数量和所有文件的总大小进行统计：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> pair<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> size_t<span class="token operator">&gt;&gt;</span> <span class="token function">ext_stats</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> path <span class="token operator">&amp;</span>dir<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> pair<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> size_t<span class="token operator">&gt;&gt;</span> m<span class="token punctuation">;</span>
    
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>entry <span class="token operator">:</span>
    	recursive_directory_iterator<span class="token punctuation">{</span>dir<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	
</pre></li>
<li>
<p>如果目录入口是一个目录，我们将跳过这个入口。跳过的意思就是不会对这个目录进行递归操作。<code>recursive_directory_iterator</code>可以完成这个工作，但是不需要去查找所有文件夹中的文件。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        <span class="token keyword keyword-const">const</span> path p <span class="token punctuation">{</span>entry<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-const">const</span> file_status fs <span class="token punctuation">{</span><span class="token function">status</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">is_directory</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>		
</pre></li>
<li>
<p>接下来，会对文件的扩展名进行提取。如果文件没有扩展名，就会对其进行忽略：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">		<span class="token keyword keyword-const">const</span> string ext <span class="token punctuation">{</span>p<span class="token punctuation">.</span><span class="token function">extension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

		<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ext<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</pre></li>
<li>
<p>接着，计算我们查找到文件的总体大小。然后，将会对<code>map</code>中同一扩展的对象进行聚合。如果对应类型还不存在，创建起来也很容易。我们可以简单的对文件计数进行增加，并且对扩展总体大小进行累加：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">        <span class="token keyword keyword-const">const</span> size_t size <span class="token punctuation">{</span><span class="token function">file_size</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>size_accum<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>ext<span class="token punctuation">]</span><span class="token punctuation">;</span>

        size_accum <span class="token operator">+=</span> size<span class="token punctuation">;</span>
        count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>之后，我们会返回这个<code>map</code>：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token keyword keyword-return">return</span> m<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们会从用户提供的路径中获取对应的路径，或是使用当前路径。当然，需要对地址是否存在进行检查，否则继续下去就没有任何意义：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    path dir <span class="token punctuation">{</span>argc <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">?</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token string">"."</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">exists</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Path "</span> <span class="token operator">&lt;&lt;</span> dir <span class="token operator">&lt;&lt;</span> <span class="token string">" does not exist.\n"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>可以对<code>ext_stats</code>进行遍历。因为<code>map</code>中的<code>accum_size</code>元素包含有同类型扩展文件的总大小，然后用其除以总数量，以计算出平均值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>ext<span class="token punctuation">,</span> stats<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token function">ext_stats</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>accum_size<span class="token punctuation">,</span> count<span class="token punctuation">]</span> <span class="token operator">=</span> stats<span class="token punctuation">;</span>
        
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> left <span class="token operator">&lt;&lt;</span> ext <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span>
             <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> right <span class="token operator">&lt;&lt;</span> count
             <span class="token operator">&lt;&lt;</span> <span class="token string">" items, avg size "</span>
             <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token function">size_string</span><span class="token punctuation">(</span>accum_size <span class="token operator">/</span> count<span class="token punctuation">)</span>
             <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，我们将会得到如下的输出。我将C++离线手册的地址，作为命令行的参数：</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ <span class="token punctuation">.</span><span class="token operator">/</span>file_type <span class="token operator">~</span><span class="token operator">/</span>Documents<span class="token operator">/</span>cpp_reference<span class="token operator">/</span>
<span class="token punctuation">.</span>css <span class="token operator">:</span><span class="token number">2</span> items<span class="token punctuation">,</span> avg size <span class="token number">41</span>K
<span class="token punctuation">.</span>gif <span class="token operator">:</span><span class="token number">7</span> items<span class="token punctuation">,</span> avg size <span class="token number">902</span>B
<span class="token punctuation">.</span>html<span class="token operator">:</span> <span class="token number">4355</span> items<span class="token punctuation">,</span> avg size <span class="token number">38</span>K
<span class="token punctuation">.</span>js<span class="token operator">:</span><span class="token number">3</span> items<span class="token punctuation">,</span> avg size <span class="token number">4</span>K
<span class="token punctuation">.</span>php <span class="token operator">:</span><span class="token number">1</span> items<span class="token punctuation">,</span> avg size <span class="token number">739</span>B
<span class="token punctuation">.</span>png <span class="token operator">:</span> <span class="token number">34</span> items<span class="token punctuation">,</span> avg size <span class="token number">2</span>K
<span class="token punctuation">.</span>svg <span class="token operator">:</span> <span class="token number">53</span> items<span class="token punctuation">,</span> avg size <span class="token number">6</span>K
<span class="token punctuation">.</span>ttf <span class="token operator">:</span><span class="token number">2</span> items<span class="token punctuation">,</span> avg size <span class="token number">421</span>K
</pre></div></div><div id="ebook-heading-x5b9ex73b0x4e00x4e2ax5de5x5177xff1ax901ax8fc7x7b26x53f7x94fex63a5x51cfx5c11x91cdx590dx6587x4ef6xff0cx4ecex800cx63a7x5236x6587x4ef6x5939x5927x5c0f" ebook-toc-level-2="" heading="实现一个工具：通过符号链接减少重复文件，从而控制文件夹大小"><div><h1 class="mume-header" id="%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7%E9%80%9A%E8%BF%87%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%87%8F%E5%B0%91%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6%E4%BB%8E%E8%80%8C%E6%8E%A7%E5%88%B6%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F">实现一个工具：通过符号链接减少重复文件，从而控制文件夹大小</h1>

<p>很多工具以不同的方式对数据进行压缩。其中最著名的文件压缩算法/格式就是ZIP和RAR。这种工具通过减少文件内部冗余，从而减少文件的大小。</p>
<p>将文件压缩成压缩包外，另一个非常简单的减少磁盘使用率的范式就是删除重复的文件。本节中，我们将实现一个小工具，其会对目录进行递归。递归中将对文件内容进行对比，如果找到相同的文件，我们将对其中一个进行删除。所有删除的文件则由一个符号链接替代，该链接指向目前唯一存在的文件。这种方式可以不通过压缩对空间进行节省，同时对所有的数据能够进行保存。</p>
<h2 class="mume-header" id="how-to-do-it">How to do it...</h2>

<p>本节中，将实现一个小工具用来查找那些重复的文件。我们将会删除其中一个重复的文件，并使用符号链接的方式对其进行替换，这样就能减小文件夹的大小。</p>
<blockquote>
<p>Note：</p>
<p>为了对系统数据进行备份，我们将使用STL函数对文件进行删除。一个简单的拼写错误就可能会删除很多并不想删除的文件。</p>
</blockquote>
<ol>
<li>
<p>包含必要的头文件，并声明所使用的命名空间：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;filesystem&gt;</span></span>

<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword keyword-using">using</span> <span class="token keyword keyword-namespace">namespace</span> filesystem<span class="token punctuation">;</span>
</pre></li>
<li>
<p>为了查找重复的文件，我们将构造一个哈希表，并对将文件哈希值与其第一次产生的地址相对应。最好的方式就是通过哈希算法，对文件计算出一个MD5或SHA码。为了保证例子的简洁，我们将会把文件读入一个字符串中，然后使用<code>hash</code>函数计算出对应的哈希值：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> size_t <span class="token function">hash_from_path</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> path <span class="token operator">&amp;</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    ifstream is <span class="token punctuation">{</span>p<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    	ios<span class="token double-colon punctuation">::</span>in <span class="token operator">|</span> ios<span class="token double-colon punctuation">::</span>binary<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-throw">throw</span> errno<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
    string s<span class="token punctuation">;</span>
    
    is<span class="token punctuation">.</span><span class="token function">seekg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ios<span class="token double-colon punctuation">::</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">tellg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    is<span class="token punctuation">.</span><span class="token function">seekg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ios<span class="token double-colon punctuation">::</span>beg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    s<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>istreambuf_iterator<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>is<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-return">return</span> hash<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>然后，我们会实现一个哈希表，并且删除重复的文件。其会对当前文件夹和其子文件夹进行遍历：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-static">static</span> size_t <span class="token function">reduce_dupes</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> path <span class="token operator">&amp;</span>dir<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    unordered_map<span class="token operator">&lt;</span>size_t<span class="token punctuation">,</span> path<span class="token operator">&gt;</span> m<span class="token punctuation">;</span>
    size_t count <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span>entry <span class="token operator">:</span>
    	 recursive_directory_iterator<span class="token punctuation">{</span>dir<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
</pre></li>
<li>
<p>对于每个文件入口，我们都会进行检查，当其是文件夹时就会跳过。对于每一个文件，我们都会产生一个哈希值，并且尝试将其插入哈希表中。当哈希表已经包含有相同的哈希值，这也就意味着有文件重复了。并且插入操作会终止，<code>try_emplace</code>所返回的第二个值就是false:</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-const">const</span> path p <span class="token punctuation">{</span>entry<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">is_directory</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-auto">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>it<span class="token punctuation">,</span> success<span class="token punctuation">]</span> <span class="token operator">=</span>
        m<span class="token punctuation">.</span><span class="token function">try_emplace</span><span class="token punctuation">(</span><span class="token function">hash_from_path</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre></li>
<li>
<p><code>try_emplace</code>的返回值将告诉我们，该键是否是第一次插入的。这样我们就能找到重复的，并告诉用户文件有重复的，并将重复的进行删除。删除之后，我们将为重复的文件创建符号链接：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Removed "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
             <span class="token operator">&lt;&lt;</span> <span class="token string">" because it is a duplicate of "</span>
             <span class="token operator">&lt;&lt;</span> it<span class="token operator">-&gt;</span>second<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
        
        <span class="token function">remove</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">create_symlink</span><span class="token punctuation">(</span><span class="token function">absolute</span><span class="token punctuation">(</span>it<span class="token operator">-&gt;</span>second<span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>	
</pre></li>
<li>
<p>对文件系统进行插入后，我们将会返回重复文件的数量：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">	<span class="token punctuation">}</span>

	<span class="token keyword keyword-return">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>主函数中，我们会对用户在命令行中提供的目录进行检查。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Usage: "</span> <span class="token operator">&lt;&lt;</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" &lt;path&gt;\n"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    path dir <span class="token punctuation">{</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">exists</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Path "</span> <span class="token operator">&lt;&lt;</span> dir <span class="token operator">&lt;&lt;</span> <span class="token string">" does not exist.\n"</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</pre></li>
<li>
<p>现在我们只需要对<code>reduce_dupes</code>进行调用，并打印出有多少文件被删除了：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">    <span class="token keyword keyword-const">const</span> size_t dupes <span class="token punctuation">{</span><span class="token function">reduce_dupes</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Removed "</span> <span class="token operator">&lt;&lt;</span> dupes <span class="token operator">&lt;&lt;</span> <span class="token string">" duplicates.\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></li>
<li>
<p>编译并运行程序，输出中有一些看起来比较复杂的文件。程序执行之后，我会使用<code>du</code>工具来检查文件夹的大小，并证明这种方法是有效的。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">$ du <span class="token operator">-</span>sh dupe_dir
<span class="token number">1.1</span>Mdupe_dir

$ <span class="token punctuation">.</span><span class="token operator">/</span>dupe_compress dupe_dir
Removed dupe_dir<span class="token operator">/</span>dir2<span class="token operator">/</span>bar<span class="token punctuation">.</span>jpg because it is a duplicate of
dupe_dir<span class="token operator">/</span>dir1<span class="token operator">/</span>bar<span class="token punctuation">.</span>jpg
Removed dupe_dir<span class="token operator">/</span>dir2<span class="token operator">/</span>base10<span class="token punctuation">.</span>png because it is a duplicate of
dupe_dir<span class="token operator">/</span>dir1<span class="token operator">/</span>base10<span class="token punctuation">.</span>png
Removed dupe_dir<span class="token operator">/</span>dir2<span class="token operator">/</span>baz<span class="token punctuation">.</span>jpeg because it is a duplicate of
dupe_dir<span class="token operator">/</span>dir1<span class="token operator">/</span>baz<span class="token punctuation">.</span>jpeg
Removed dupe_dir<span class="token operator">/</span>dir2<span class="token operator">/</span>feed_fish<span class="token punctuation">.</span>jpg because it is a duplicate of
dupe_dir<span class="token operator">/</span>dir1<span class="token operator">/</span>feed_fish<span class="token punctuation">.</span>jpg
Removed dupe_dir<span class="token operator">/</span>dir2<span class="token operator">/</span>foo<span class="token punctuation">.</span>jpg because it is a duplicate of
dupe_dir<span class="token operator">/</span>dir1<span class="token operator">/</span>foo<span class="token punctuation">.</span>jpg
Removed dupe_dir<span class="token operator">/</span>dir2<span class="token operator">/</span>fox<span class="token punctuation">.</span>jpg because it is a duplicate of
dupe_dir<span class="token operator">/</span>dir1<span class="token operator">/</span>fox<span class="token punctuation">.</span>jpg
Removed <span class="token number">6</span> duplicates<span class="token punctuation">.</span>
    
$ du <span class="token operator">-</span>sh dupe_dir
<span class="token number">584</span>Kdupe_dir
</pre></li>
</ol>
<h2 class="mume-header" id="how-it-works">How it works...</h2>

<p>使用<code>create_symlink</code>函数在文件系统中链接一个文件，指向另一个地方。这样就能避免重复的文件出现，也可以使用<code>create_hard_link</code>设置一些硬链接。硬链接和软连接相比，有不同的技术含义。有些格式的文件系统可能不支持硬链接，或者是使用一定数量的硬链接，指向相同的文件。另一个问题就是，硬链接没有办法让两个文件系统进行链接。</p>
<p>不过，除开实现细节，使用<code>create_symlink</code>或<code>create_hard_link</code>时，会出现一个明显的错误。下面的几行代码中就有一个bug。你能很快的找到它吗？</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp">path a <span class="token punctuation">{</span><span class="token string">"some_dir/some_file.txt"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
path b <span class="token punctuation">{</span><span class="token string">"other_dir/other_file.txt"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">remove</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">create_symlink</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><p>在程序执行的时候，不会发生任何问题，不过符号链接将失效。符号链接将错误的指向<code>some_dir/some_file.txt</code>。正确指向的地址应该是<code>/absolute/path/some_dir/some_file.txt</code>或<code>../some_dir/some_file.txt</code>。<code>create_symlink</code>使用正确的绝对地址，可以使用如下写法：</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp"><span class="token function">create_symlink</span><span class="token punctuation">(</span><span class="token function">absolute</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre><blockquote>
<p>Note：</p>
<p><code>create_symlink</code>不会对链接进行检查</p>
</blockquote>
<h2 class="mume-header" id="theres-more">There's more...</h2>

<p>可以看到，哈希函数非常简单。为了让程序没有多余的依赖，我们采用了这种方式。</p>
<p>我们的哈希函数有什么问题呢？有两个问题：</p>
<ul>
<li>会将一个文件完全读入到字符串中。如果对于很大的文件来说，这将是一场灾难。</li>
<li>C++ 中的哈希函数<code>hash&lt;string&gt;</code>可能不是这样使用的。</li>
</ul>
<p>要寻找一个更好的哈希函数时，我们需要找一个快速、内存友好、简单的，并且保证不同的文件具有不同的哈希值，最后一个需求可能是最关键的。因为我们使用哈希值了判断两个文件是否一致，当我们认为两个文件一致时，但哈希值不一样，就能肯定有数据受到了损失。</p>
<p>比较好的哈希算法有MD5和SHA(有变体)。为了让我们程序使用这样的函数，可能需要使用OpenSSL中的密码学API。</p>
</div></div>
    </div>
  

</body></html>